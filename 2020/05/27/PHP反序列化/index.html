<!DOCTYPE html>
<html>
    <!-- Head -->
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">

    <!-- Page Title -->
    
        <title>PHP反序列化 | Hexo</title>
    
    <link rel="icon" href="/img/avatar-default.png">
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    
    
<script src="/js/script.js"></script>

    
<link rel="stylesheet" href="/css/style.css">

    
    <style>
        .deactiveColor{
            color: #37474f;
        }
        .activeColor{
            color: #006064;
        }
        a:hover{
            color: #006064;
        }
        .header-btn{
            color: #37474f;
        }
        
        .post-content img{
            margin: 50px auto;
        }
        
    </style>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
    <body>
        <div class="container">

            <!-- Top Anchor -->
            <div id="top"></div>

            <!-- Header -->
            <header class="header-wrapper">
    <div class="header-title-wrapper">
        <!-- Page Title -->
        <p class="header-title">
             
                
                    PHP反序列化
                
            
        </p>  
    </div>    

    
        <!-- Division Line -->
        <div class="division"></div> 
    
    
    <div class="header-detail">
        <!-- Header Button -->
        <div class="header-btn-wrapper">
            
                <span>
                    <a class="home-btn header-btn" href="/" title="homepage"><i class="fa fa-home"></i></a>
                </span>

                
                    <span>
                        <a class="catalog-btn header-btn"><i class="fa fa-list-ul"></i></a>
                    </span>
                
            
        </div>
    </div>
</header>

            <!-- Main -->
            <main>
                <article class="post-wrapper">
    

    
        <!-- Article Catalog -->
        <div class="catalog-dropdown col-xs-12 col-sm-12">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PHP反序列化"><span class="toc-number">1.</span> <span class="toc-text">PHP反序列化</span></a></li></ol>
        </div>
    

    
        <!--For now, Lightbox Only Show in Post Layout -->
        

        
        
            <!-- Article Img Lightbox -->
            <div class="gallery">
    
    
    <div class="lightbox">
        <!-- Close Button -->
        <span class="close-gallery">&times;</span>
        
        <!-- Photo -->
        <img class="gallery-photo">
    </div>
</div>
        
    

    

    <!-- Article Content -->
    <div class="post-content">
        <h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>序列化和反序列化的概念</p>
<p>​        把对象转换为字节序列的过程称为对象的序列化。<br>　　把字节序列恢复为对象的过程称为对象的反序列化。</p>
<p>对象的序列化主要有两种用途：</p>
<p>　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br>　　2） 在网络上传送对象的字节序列。</p>
<p>参考博客：<a href="https://www.cnblogs.com/tsinghuaxiaobao/p/5729706.html" target="_blank" rel="noopener">https://www.cnblogs.com/tsinghuaxiaobao/p/5729706.html</a></p>
<blockquote>
<p>序列化概念：</p>
<p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>
<p>序列化使其他代码可以查看或修改，那些不序列化便无法访问的对象实例数据。确切地说，代码执行序列化需要特殊的权限：即指定了 SerializationFormatter 标志的 SecurityPermission。在默认策略下，通过 Internet 下载的代码或 Internet 代码不会授予该权限；只有本地计算机上的代码才被授予该权限。</p>
<p>通常，对象实例的所有<a href="https://baike.baidu.com/item/字段/2885972" target="_blank" rel="noopener">字段</a>都会被序列化，这意味着数据会被表示为实例的序列化数据。这样，能够解释该格式的代码有可能能够确定这些数据的值，而不依赖于该成员的可访问性。类似地，反序列化从序列化的表示形式中提取数据，并直接设置对象状态，这也与可访问性规则无关。</p>
<p>对于任何可能包含重要的安全性数据的对象，如果可能，应该使该对象不可序列化。如果它必须为可序列化的，请尝试生成特定字段来保存不可序列化的重要数据。如果无法实现这一点，则应注意该数据会被公开给任何拥有序列化权限的代码，并确保不让任何恶意代码获得该权限。</p>
<p>反序列化<br>将二进制数据换回原对象，构造方法：ObjectInputStream（InputStream in），方法: Object readObject() 从 ObjectInputStream 读取对象</p>
<pre><code>publicclassDeserialization {
publicstaticvoidmain(String[] args) throwsIOException, Exception{
File file= newFile(&quot;F:&quot;+File.separator+&quot;serialize.txt&quot;);
//反序列化到指定的文本
ObjectInputStream ois=newObjectInputStream(newFileInputStream(file));
Object obj=ois.readObject();
Book book=(Book) obj;
System.out.println(&quot;我们通过使用字节流的序列化操作，看到了如下信息内容：\n&quot;+book);
ois.close();
}
}</code></pre></blockquote>
<p>参考博客：<a href="https://www.cnblogs.com/tr1ple/p/11156279.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/11156279.html</a></p>
<p>1、PHP中序列化与反序列化的函数分别是：serialize(value), unserialize(str)<br>如：</p>
<pre><code>&lt;?php
    //php的序列化与反序列化
    //serialize(value)
    //unserialize(str)
    $arr = array(
        &#39;name&#39;=&gt;&#39;xiaoming&#39;,
        &#39;sex&#39;=&gt;&#39;男&#39;,
        &#39;age&#39;=&gt;20
    );
    $str    = serialize($arr);
    var_dump($str);
    $arr2   = unserialize($str);
    var_dump($arr2);
?&gt;</code></pre><p>　　序列化为的结果为：<br>　　string(67) “a:3:{s:4:”name”;s:8:”xiaoming”;s:3:”sex”;s:3:”男”;s:3:”age”;i:20;}”<br>　　还原后的结果：</p>
<p>　　array(3) { [“name”]=&gt; string(8) “xiaoming” [“sex”]=&gt; string(3) “男” [“age”]=&gt; int(20) }</p>
<p>2、序列化的注意点：</p>
<p>当数组值中包含双引号，单引号或双引号时，会出现一些问题，可以使用base64_encode()与base64_decode()对数据做编码与解码</p>
<p>参考博客：<a href="https://www.cnblogs.com/luodao1991/p/3812945.html" target="_blank" rel="noopener">https://www.cnblogs.com/luodao1991/p/3812945.html</a></p>
<p>常见的PHP魔术方法：</p>
<pre><code>__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。
__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。
__toString：当对象被当做一个字符串使用时调用。
__sleep:序列化对象之前就调用此方法(其返回需要一个数组)
__wakeup:反序列化恢复对象之前调用该方法
__call:当调用对象中不存在的方法会自动调用该方法。
__get:在调用私有属性的时候会自动执行
__isset()在不可访问的属性上调用isset()或empty()触发
__unset()在不可访问的属性上使用unset()时触发</code></pre><p>参考博客：<a href="https://www.cnblogs.com/luodao1991/p/3812945.html" target="_blank" rel="noopener">https://www.cnblogs.com/luodao1991/p/3812945.html</a></p>
<p>一、</p>
<pre><code>__construct() 和 __destruct()
__construct()被称为构造方法，也就是在创造一个对象时候，首先会去执行的一个方法。</code></pre><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814185851146-2079186395.png" alt="img"></p>
<p>测试：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;
    public $filename = &#39;&#39;;
    public $data = &#39;&#39;;

    function __construct($filename, $data) {
        $this-&gt;filename = $filename;
        $this-&gt;data = $data;
        echo &#39;construct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }
}$a = new test(&#39;test.txt&#39;, &#39;data&#39;);</code></pre><p>测试结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190308787-849746794.png" alt="img"></p>
<p>同样的，我们编写一个类的析构方法，__destruct()</p>
<p>析构函数的作用：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190554740-2101728295.png" alt="img"></p>
<p>代码如下：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;
    public $filename = &#39;&#39;;
    public $data = &#39;&#39;;

    function __construct($filename, $data) {
        $this-&gt;filename = $filename;
        $this-&gt;data = $data;
        echo &#39;construct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    function __destruct() {
        echo &#39;destruct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }
}

$a = new test(&#39;test.txt&#39;, &#39;data&#39;);</code></pre><p>运行结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190455881-983907146.png" alt="img">二、</p>
<pre><code>__sleep()   __wakeup()   __toString()</code></pre><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814211728646-872838140.png" alt="img"></p>
<p>测试：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;

    # 用于保存重载的数据 
    private $data = array();

    public $filename = &#39;&#39;;

    public $content = &#39;&#39;;

    function __construct($filename, $content) {
        $this-&gt;filename = $filename;
        $this-&gt;content = $content;
        echo &#39;construct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    function __destruct() {
        echo &#39;destruct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    # 反序列化时候触发
    function __wakeup() {
        // file_put_contents($this-&gt;filename, $this-&gt;data);
        echo &#39;wakeup function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    # 一般情况用在序列化操作时候，用于保留数据
    function __sleep() {
        echo &#39;sleep function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
        return array(&#39;flag&#39;, &#39;filename&#39;, &#39;data&#39;);
    }

    # 当需要输出得到对象名称时候会调用
    function __toString() {
        return $this-&gt;data;
    }

    public function set_flag($flag) {
        $this-&gt;flag = $flag;
    }

    public function get_flag() {
        return $this-&gt;flag;
    }
}

$key = serialize(new test(&#39;test.txt&#39;, &#39;test&#39;));

var_dump($key);

$b = unserialize($key);</code></pre><p>运行结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814213555818-482422847.png" alt="img"></p>
<p>在进行序列化的时候，执行了<code>__sleep()</code>方法，在反序列化的时候执行了<code>__wakeup()</code>方法。</p>
<p>然后是__toString()方法：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;

    # 用于保存重载的数据 
    private $data = array();

    public $filename = &#39;&#39;;

    public $content = &#39;&#39;;

    function __construct($filename, $content) {
        $this-&gt;filename = $filename;
        $this-&gt;content = $content;
        echo &#39;construct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    function __destruct() {
        echo &#39;destruct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    # 当需要输出得到对象名称时候会调用
    function __toString() {
        return $this-&gt;content;
    }
}

$a = new test(&#39;test.txt&#39;, &#39;data&#39;);
echo $a.&quot;&lt;br&gt;&quot;;</code></pre><p>结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814214737553-1134269474.png" alt="img"></p>
<p>三、</p>
<p><code>__set()   __get()   __isset()   __unset()</code>   作用如下：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814192333631-967052636.png" alt="img"></p>
<p>我们一样是来写一个代码进行验证：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;

    # 用于保存重载的数据 
    private $data = array();

    public $filename = &#39;&#39;;

    public $content = &#39;&#39;;

    function __construct($filename, $content) {
        $this-&gt;filename = $filename;
        $this-&gt;content = $content;
        echo &#39;construct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    function __destruct() {
        echo &#39;destruct function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
    }

    function __set($key, $value) {
        echo &#39;set function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
        $this-&gt;data[$key] = $value;
    }

    function __get($key) {
        echo &#39;get function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
        if (array_key_exists($key, $this-&gt;data)) {
            return $this-&gt;data[$key];
        } else {
            return null;
        }
    }

    function __isset($key) {
        echo &#39;isset function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
        return isset($this-&gt;data[$key]);
    }

    function __unset($key) {
        echo &#39;unset function in test class&#39;;
        echo &quot;&lt;br&gt;&quot;;
        unset($this-&gt;data[$key]);
    }

    public function set_flag($flag) {
        $this-&gt;flag = $flag;
    }

    public function get_flag() {
        return $this-&gt;flag;
    }
}


$a = new test(&#39;test.txt&#39;, &#39;data&#39;);

# __set() 被调用
$a-&gt;var = 1;

# __get() 被调用
echo $a-&gt;var;

# __isset() 被调用
var_dump(isset($a-&gt;var));

# __unset() 被调用
unset($a-&gt;var);

var_dump(isset($a-&gt;var));

echo &quot;\n&quot;;</code></pre><p>运行结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814194054396-358365891.png" alt="img"></p>
<p>我们可以看到调用的顺序为： 构造方法 =&gt; set方法（我们此时为类中并没有定义过的一个类属性进行赋值触发了set方法） =&gt; get方法 =&gt; isset方法 =&gt; unset方法 =&gt; isset方法 =&gt; 析构方法</p>
<p>同时也可以发现，析构方法在所有的代码被执行结束之后进行的。</p>
<p>四、</p>
<p>  <code>__call()   __callStatic()</code>   </p>
<p>官方文档中的解释：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814210046146-2097402032.png" alt="img"></p>
<p>类似以上介绍过的<strong>set()和</strong>get()，刚刚是访问不存在或者不可访问属性时候进行的调用。现在是访问不存在或者不可访问的方法时候：</p>
<p>代码如下：</p>
<pre><code>class test {

    private $flag = &#39;&#39;;

    # 用于保存重载的数据 
    private $data = array();

    public $filename = &#39;&#39;;

    public $content = &#39;&#39;;

    function __call($funcname, $args) {
        echo &#39;function name is: &#39; . $funcname. &#39; args is: &#39; . implode(&#39;, &#39;, $args);
        echo &quot;&lt;br&gt;&quot;;
    }

    public static function __callStatic($funcname, $args) {
        echo &#39;static function name is: &#39; . $funcname. &#39; args is: &#39; . implode(&#39;, &#39;, $args);
        echo &quot;&lt;br&gt;&quot;;
    }

    public function set_flag($flag) {
        $this-&gt;flag = $flag;
    }

    public function get_flag() {
        return $this-&gt;flag;
    }
}

$obj = new test;

# 调用一个不存在或者无法访问到的方法时候将会调用__call()
$obj-&gt;run(&#39;run args, test&#39;);

# 调用一个不存在的静态方法，将会去调用__callStatic()
$obj::run(&#39;static test&#39;);</code></pre><p>运行结果：</p>
<p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814211405100-441748676.png" alt="img"></p>
  
    </div> 

    
        <!-- Division Line -->
        <div class="division"></div> 
    

    <div class="post-info-wrapper">
            
                    <!-- Post Info -->
                    <p class="post-date">2020-05-27</p>
                    
                    
                        <p class="post-info-categories">
                            
                        </p>
                    

                    
            
    </div>
</article>


    

            </main>

            <!-- 'To Top' Btn-->
            
                <div id="to-top">
    <a href="#top" class="toTop">
        <i class="fa fa-pagelines"></i>
    </a>
</div>
            

            <!-- Footer -->
            
                <footer class="footer-wrapper col-xs-12 col-sm-12">
    <div class="footer-banner-wrapper">
        <p class="footer-banner">Powered by <a href="https://hexo.io/" target="_blank" rel="noopener" title="Hexo">Hexo</a></p>
        <P class="footer-banner">Theme <a href="https://github.com/Lonezj/hexo-theme-wind" target="_blank" rel="noopener" title="Wind">wind</a></P>
    </div>
</footer>
            
        </div>

        <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css">
        <link rel="stylesheet" href="/css/google-prettify-monokai.css" type="text/css">
        <script src="//cdn.bootcss.com/prettify/r298/prettify.min.js" type="text/javascript"></script>
    </body>
</html>